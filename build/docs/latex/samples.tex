This S\+DK includes a number of sample applications. Each sample documents a feature of the S\+DK in both prose and the associated C code. The following samples are included\+:


\begin{DoxyItemize}
\item \hyperlink{example_decode_to_md5}{decode\+\_\+to\+\_\+md5} Frame by frame M\+D5 checksum.
\item \hyperlink{example_decode_with_drops}{decode\+\_\+with\+\_\+drops} Drops frames while decoding.
\item \hyperlink{example_simple_decoder}{simple\+\_\+decoder} Simplified decoder loop.
\item \hyperlink{example_lossless_encoder}{lossless\+\_\+encoder} Simplified lossless encoder.
\item \hyperlink{example_set_maps}{set\+\_\+maps} Set active and R\+OI maps.
\item \hyperlink{example_simple_encoder}{simple\+\_\+encoder} Simplified encoder loop.
\item \hyperlink{example_twopass_encoder}{twopass\+\_\+encoder} Two-\/pass encoder loop.
\item \hyperlink{example_scalable_encoder}{scalable\+\_\+encoder} Scalable encoder loop.
\item \hyperlink{example_aom_cx_set_ref}{aom\+\_\+cx\+\_\+set\+\_\+ref} Set encoder reference frame.
\item \hyperlink{example_lightfield_encoder}{lightfield\+\_\+encoder} Lightfield encoder example.
\item \hyperlink{example_lightfield_tile_list_decoder}{lightfield\+\_\+tile\+\_\+list\+\_\+decoder} Lightfield tile list decoder example.
\item \hyperlink{example_lightfield_decoder}{lightfield\+\_\+decoder} Lightfield decoder example.
\item \hyperlink{example_lightfield_bitstream_parsing}{lightfield\+\_\+bitstream\+\_\+parsing} Lightfield bitstream parsing example.
\end{DoxyItemize}

In addition, the S\+DK contains a number of utilities. Since these utilities are built upon the concepts described in the sample code listed above, they are not documented in pieces like the samples are. Their source is included here for reference. The following utilities are included\+:


\begin{DoxyItemize}
\item \hyperlink{example_aomdec}{aomdec} Full featured decoder.
\item \hyperlink{example_aomenc}{aomenc} Full featured encoder. 
\end{DoxyItemize}\hypertarget{example_decode_to_md5}{}\subsection{decode\+\_\+to\+\_\+md5}\label{example_decode_to_md5}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Frame-by-frame MD5 Checksum}
13 \textcolor{comment}{// ===========================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This example builds upon the simple decoder loop to show how checksums}
16 \textcolor{comment}{// of the decoded output can be generated. These are used for validating}
17 \textcolor{comment}{// decoder implementations against the reference implementation, for example.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// MD5 algorithm}
20 \textcolor{comment}{// -------------}
21 \textcolor{comment}{// The Message-Digest 5 (MD5) is a well known hash function. We have provided}
22 \textcolor{comment}{// an implementation derived from the RSA Data Security, Inc. MD5 Message-Digest}
23 \textcolor{comment}{// Algorithm for your use. Our implmentation only changes the interface of this}
24 \textcolor{comment}{// reference code. You must include the `md5\_utils.h` header for access to these}
25 \textcolor{comment}{// functions.}
26 \textcolor{comment}{//}
27 \textcolor{comment}{// Processing The Decoded Data}
28 \textcolor{comment}{// ---------------------------}
29 \textcolor{comment}{// Each row of the image is passed to the MD5 accumulator. First the Y plane}
30 \textcolor{comment}{// is processed, then U, then V. It is important to honor the image's `stride`}
31 \textcolor{comment}{// values.}
32 
33 \textcolor{preprocessor}{#include <stdio.h>}
34 \textcolor{preprocessor}{#include <stdlib.h>}
35 \textcolor{preprocessor}{#include <string.h>}
36 
37 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
38 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
39 \textcolor{preprocessor}{#include "common/md5\_utils.h"}
40 \textcolor{preprocessor}{#include "common/tools\_common.h"}
41 \textcolor{preprocessor}{#include "common/video\_reader.h"}
42 
43 \textcolor{keyword}{static} \textcolor{keywordtype}{void} get\_image\_md5(\textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} digest[16]) \{
44   \textcolor{keywordtype}{int} plane, y;
45   MD5Context md5;
46 
47   MD5Init(&md5);
48 
49   \textcolor{keywordflow}{for} (plane = 0; plane < 3; ++plane) \{
50     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buf = img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[plane];
51     \textcolor{keyword}{const} \textcolor{keywordtype}{int} stride = img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[plane];
52     \textcolor{keyword}{const} \textcolor{keywordtype}{int} w = plane ? (img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} + 1) >> 1 : img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w};
53     \textcolor{keyword}{const} \textcolor{keywordtype}{int} h = plane ? (img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} + 1) >> 1 : img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h};
54 
55     \textcolor{keywordflow}{for} (y = 0; y < h; ++y) \{
56       MD5Update(&md5, buf, w);
57       buf += stride;
58     \}
59   \}
60 
61   MD5Final(digest, &md5);
62 \}
63 
64 \textcolor{keyword}{static} \textcolor{keywordtype}{void} print\_md5(FILE *stream, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} digest[16]) \{
65   \textcolor{keywordtype}{int} i;
66 
67   \textcolor{keywordflow}{for} (i = 0; i < 16; ++i) fprintf(stream, \textcolor{stringliteral}{"%02x"}, digest[i]);
68 \}
69 
70 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
71 
72 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
73   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile>\(\backslash\)n"}, exec\_name);
74   exit(EXIT\_FAILURE);
75 \}
76 
77 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
78   \textcolor{keywordtype}{int} frame\_cnt = 0;
79   FILE *outfile = NULL;
80   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
81   AvxVideoReader *reader = NULL;
82   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
83   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
84 
85   exec\_name = argv[0];
86 
87   \textcolor{keywordflow}{if} (argc != 3) die(\textcolor{stringliteral}{"Invalid number of arguments."});
88 
89   reader = aom\_video\_reader\_open(argv[1]);
90   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
91 
92   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
93     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
94 
95   info = aom\_video\_reader\_get\_info(reader);
96 
97   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
98   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
99 
100   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
101 
102   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
103     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder"});
104 
105   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
106     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
107     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
108     \textcolor{keywordtype}{size\_t} frame\_size = 0;
109     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
110         aom\_video\_reader\_get\_frame(reader, &frame\_size);
111     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
112       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame"});
113 
114     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL) \{
115       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} digest[16];
116 
117       get\_image\_md5(img, digest);
118       print\_md5(outfile, digest);
119       fprintf(outfile, \textcolor{stringliteral}{"  img-%dx%d-%04d.i420\(\backslash\)n"}, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h},
120               ++frame\_cnt);
121     \}
122   \}
123 
124   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_cnt);
125   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
126 
127   aom\_video\_reader\_close(reader);
128 
129   fclose(outfile);
130   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
131 \}
\end{DoxyCodeInclude}
 \hypertarget{example_decode_with_drops}{}\subsection{decode\+\_\+with\+\_\+drops}\label{example_decode_with_drops}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Decode With Drops Example}
13 \textcolor{comment}{// =========================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example utility which drops a series of frames, as specified}
16 \textcolor{comment}{// on the command line. This is useful for observing the error recovery}
17 \textcolor{comment}{// features of the codec.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// Usage}
20 \textcolor{comment}{// -----}
21 \textcolor{comment}{// This example adds a single argument to the `simple\_decoder` example,}
22 \textcolor{comment}{// which specifies the range or pattern of frames to drop. The parameter is}
23 \textcolor{comment}{// parsed as follows:}
24 \textcolor{comment}{//}
25 \textcolor{comment}{// Dropping A Range Of Frames}
26 \textcolor{comment}{// --------------------------}
27 \textcolor{comment}{// To drop a range of frames, specify the starting frame and the ending}
28 \textcolor{comment}{// frame to drop, separated by a dash. The following command will drop}
29 \textcolor{comment}{// frames 5 through 10 (base 1).}
30 \textcolor{comment}{//}
31 \textcolor{comment}{//  $ ./decode\_with\_drops in.ivf out.i420 5-10}
32 \textcolor{comment}{//}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// Dropping A Pattern Of Frames}
35 \textcolor{comment}{// ----------------------------}
36 \textcolor{comment}{// To drop a pattern of frames, specify the number of frames to drop and}
37 \textcolor{comment}{// the number of frames after which to repeat the pattern, separated by}
38 \textcolor{comment}{// a forward-slash. The following command will drop 3 of 7 frames.}
39 \textcolor{comment}{// Specifically, it will decode 4 frames, then drop 3 frames, and then}
40 \textcolor{comment}{// repeat.}
41 \textcolor{comment}{//}
42 \textcolor{comment}{//  $ ./decode\_with\_drops in.ivf out.i420 3/7}
43 \textcolor{comment}{//}
44 \textcolor{comment}{//}
45 \textcolor{comment}{// Extra Variables}
46 \textcolor{comment}{// ---------------}
47 \textcolor{comment}{// This example maintains the pattern passed on the command line in the}
48 \textcolor{comment}{// `n`, `m`, and `is\_range` variables:}
49 \textcolor{comment}{//}
50 \textcolor{comment}{//}
51 \textcolor{comment}{// Making The Drop Decision}
52 \textcolor{comment}{// ------------------------}
53 \textcolor{comment}{// The example decides whether to drop the frame based on the current}
54 \textcolor{comment}{// frame number, immediately before decoding the frame.}
55 
56 \textcolor{preprocessor}{#include <stdio.h>}
57 \textcolor{preprocessor}{#include <stdlib.h>}
58 \textcolor{preprocessor}{#include <string.h>}
59 
60 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
61 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
62 \textcolor{preprocessor}{#include "common/tools\_common.h"}
63 \textcolor{preprocessor}{#include "common/video\_reader.h"}
64 
65 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
66 
67 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
68   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile> <N-M|N/M>\(\backslash\)n"}, exec\_name);
69   exit(EXIT\_FAILURE);
70 \}
71 
72 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
73   \textcolor{keywordtype}{int} frame\_cnt = 0;
74   FILE *outfile = NULL;
75   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
76   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
77   AvxVideoReader *reader = NULL;
78   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
79   \textcolor{keywordtype}{int} n = 0;
80   \textcolor{keywordtype}{int} m = 0;
81   \textcolor{keywordtype}{int} is\_range = 0;
82   \textcolor{keywordtype}{char} *nptr = NULL;
83 
84   exec\_name = argv[0];
85 
86   \textcolor{keywordflow}{if} (argc != 4) die(\textcolor{stringliteral}{"Invalid number of arguments."});
87 
88   reader = aom\_video\_reader\_open(argv[1]);
89   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
90 
91   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
92     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
93 
94   n = (int)strtol(argv[3], &nptr, 0);
95   m = (int)strtol(nptr + 1, NULL, 0);
96   is\_range = (*nptr == \textcolor{charliteral}{'-'});
97   \textcolor{keywordflow}{if} (!n || !m || (*nptr != \textcolor{charliteral}{'-'} && *nptr != \textcolor{charliteral}{'/'}))
98     die(\textcolor{stringliteral}{"Couldn't parse pattern %s.\(\backslash\)n"}, argv[3]);
99 
100   info = aom\_video\_reader\_get\_info(reader);
101 
102   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
103   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
104 
105   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
106 
107   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
108     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
109 
110   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
111     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
112     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
113     \textcolor{keywordtype}{size\_t} frame\_size = 0;
114     \textcolor{keywordtype}{int} skip;
115     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
116         aom\_video\_reader\_get\_frame(reader, &frame\_size);
117     ++frame\_cnt;
118 
119     skip = (is\_range && frame\_cnt >= n && frame\_cnt <= m) ||
120            (!is\_range && m - (frame\_cnt - 1) % m <= n);
121 
122     \textcolor{keywordflow}{if} (!skip) \{
123       putc(\textcolor{charliteral}{'.'}, stdout);
124       \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
125         die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
126 
127       \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL)
128         aom\_img\_write(img, outfile);
129     \} \textcolor{keywordflow}{else} \{
130       putc(\textcolor{charliteral}{'X'}, stdout);
131     \}
132 
133     fflush(stdout);
134   \}
135 
136   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_cnt);
137   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
138 
139   printf(\textcolor{stringliteral}{"Play: ffplay -f rawvideo -pix\_fmt yuv420p -s %dx%d %s\(\backslash\)n"},
140          info->frame\_width, info->frame\_height, argv[2]);
141 
142   aom\_video\_reader\_close(reader);
143   fclose(outfile);
144 
145   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
146 \}
\end{DoxyCodeInclude}
 \hypertarget{example_simple_decoder}{}\subsection{simple\+\_\+decoder}\label{example_simple_decoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Simple Decoder}
13 \textcolor{comment}{// ==============}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a simple decoder loop. It takes an input file}
16 \textcolor{comment}{// containing the compressed data (in IVF format), passes it through the}
17 \textcolor{comment}{// decoder, and writes the decompressed frames to disk. Other decoder}
18 \textcolor{comment}{// examples build upon this one.}
19 \textcolor{comment}{//}
20 \textcolor{comment}{// The details of the IVF format have been elided from this example for}
21 \textcolor{comment}{// simplicity of presentation, as IVF files will not generally be used by}
22 \textcolor{comment}{// your application. In general, an IVF file consists of a file header,}
23 \textcolor{comment}{// followed by a variable number of frames. Each frame consists of a frame}
24 \textcolor{comment}{// header followed by a variable length payload. The length of the payload}
25 \textcolor{comment}{// is specified in the first four bytes of the frame header. The payload is}
26 \textcolor{comment}{// the raw compressed data.}
27 \textcolor{comment}{//}
28 \textcolor{comment}{// Standard Includes}
29 \textcolor{comment}{// -----------------}
30 \textcolor{comment}{// For decoders, you only have to include `aom\_decoder.h` and then any}
31 \textcolor{comment}{// header files for the specific codecs you use. In this case, we're using}
32 \textcolor{comment}{// aom.}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// Initializing The Codec}
35 \textcolor{comment}{// ----------------------}
36 \textcolor{comment}{// The libaom decoder is initialized by the call to aom\_codec\_dec\_init().}
37 \textcolor{comment}{// Determining the codec interface to use is handled by AvxVideoReader and the}
38 \textcolor{comment}{// functions prefixed with aom\_video\_reader\_. Discussion of those functions is}
39 \textcolor{comment}{// beyond the scope of this example, but the main gist is to open the input file}
40 \textcolor{comment}{// and parse just enough of it to determine if it's a AVx file and which AVx}
41 \textcolor{comment}{// codec is contained within the file.}
42 \textcolor{comment}{// Note the NULL pointer passed to aom\_codec\_dec\_init(). We do that in this}
43 \textcolor{comment}{// example because we want the algorithm to determine the stream configuration}
44 \textcolor{comment}{// (width/height) and allocate memory automatically.}
45 \textcolor{comment}{//}
46 \textcolor{comment}{// Decoding A Frame}
47 \textcolor{comment}{// ----------------}
48 \textcolor{comment}{// Once the frame has been read into memory, it is decoded using the}
49 \textcolor{comment}{// `aom\_codec\_decode` function. The call takes a pointer to the data}
50 \textcolor{comment}{// (`frame`) and the length of the data (`frame\_size`). No application data}
51 \textcolor{comment}{// is associated with the frame in this example, so the `user\_priv`}
52 \textcolor{comment}{// parameter is NULL.}
53 \textcolor{comment}{//}
54 \textcolor{comment}{// Codecs may produce a variable number of output frames for every call to}
55 \textcolor{comment}{// `aom\_codec\_decode`. These frames are retrieved by the}
56 \textcolor{comment}{// `aom\_codec\_get\_frame` iterator function. The iterator variable `iter` is}
57 \textcolor{comment}{// initialized to NULL each time `aom\_codec\_decode` is called.}
58 \textcolor{comment}{// `aom\_codec\_get\_frame` is called in a loop, returning a pointer to a}
59 \textcolor{comment}{// decoded image or NULL to indicate the end of list.}
60 \textcolor{comment}{//}
61 \textcolor{comment}{// Processing The Decoded Data}
62 \textcolor{comment}{// ---------------------------}
63 \textcolor{comment}{// In this example, we simply write the encoded data to disk. It is}
64 \textcolor{comment}{// important to honor the image's `stride` values.}
65 \textcolor{comment}{//}
66 \textcolor{comment}{// Cleanup}
67 \textcolor{comment}{// -------}
68 \textcolor{comment}{// The `aom\_codec\_destroy` call frees any memory allocated by the codec.}
69 \textcolor{comment}{//}
70 \textcolor{comment}{// Error Handling}
71 \textcolor{comment}{// --------------}
72 \textcolor{comment}{// This example does not special case any error return codes. If there was}
73 \textcolor{comment}{// an error, a descriptive message is printed and the program exits. With}
74 \textcolor{comment}{// few exceptions, aom\_codec functions return an enumerated error status,}
75 \textcolor{comment}{// with the value `0` indicating success.}
76 
77 \textcolor{preprocessor}{#include <stdio.h>}
78 \textcolor{preprocessor}{#include <stdlib.h>}
79 \textcolor{preprocessor}{#include <string.h>}
80 
81 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
82 \textcolor{preprocessor}{#include "common/tools\_common.h"}
83 \textcolor{preprocessor}{#include "common/video\_reader.h"}
84 
85 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
86 
87 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
88   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile>\(\backslash\)n"}, exec\_name);
89   exit(EXIT\_FAILURE);
90 \}
91 
92 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
93   \textcolor{keywordtype}{int} frame\_cnt = 0;
94   FILE *outfile = NULL;
95   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
96   AvxVideoReader *reader = NULL;
97   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
98   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
99 
100   exec\_name = argv[0];
101 
102   \textcolor{keywordflow}{if} (argc != 3) die(\textcolor{stringliteral}{"Invalid number of arguments."});
103 
104   reader = aom\_video\_reader\_open(argv[1]);
105   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
106 
107   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
108     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
109 
110   info = aom\_video\_reader\_get\_info(reader);
111 
112   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
113   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
114 
115   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
116 
117   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
118     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
119 
120   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
121     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
122     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
123     \textcolor{keywordtype}{size\_t} frame\_size = 0;
124     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
125         aom\_video\_reader\_get\_frame(reader, &frame\_size);
126     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
127       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
128 
129     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL) \{
130       aom\_img\_write(img, outfile);
131       ++frame\_cnt;
132     \}
133   \}
134 
135   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_cnt);
136   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
137 
138   printf(\textcolor{stringliteral}{"Play: ffplay -f rawvideo -pix\_fmt yuv420p -s %dx%d %s\(\backslash\)n"},
139          info->frame\_width, info->frame\_height, argv[2]);
140 
141   aom\_video\_reader\_close(reader);
142 
143   fclose(outfile);
144 
145   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
146 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lossless_encoder}{}\subsection{lossless\+\_\+encoder}\label{example_lossless_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{preprocessor}{#include <stdio.h>}
13 \textcolor{preprocessor}{#include <stdlib.h>}
14 \textcolor{preprocessor}{#include <string.h>}
15 
16 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
17 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
18 \textcolor{preprocessor}{#include "common/tools\_common.h"}
19 \textcolor{preprocessor}{#include "common/video\_writer.h"}
20 
21 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
22 
23 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
24   fprintf(stderr,
25           \textcolor{stringliteral}{"lossless\_encoder: Example demonstrating lossless "}
26           \textcolor{stringliteral}{"encoding feature. Supports raw input only.\(\backslash\)n"});
27   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <width> <height> <infile> <outfile>\(\backslash\)n"}, exec\_name);
28   exit(EXIT\_FAILURE);
29 \}
30 
31 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \hyperlink{structaom__image}{aom\_image\_t} *img,
32                         \textcolor{keywordtype}{int} frame\_index, \textcolor{keywordtype}{int} flags, AvxVideoWriter *writer) \{
33   \textcolor{keywordtype}{int} got\_pkts = 0;
34   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
35   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
36   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res =
37       \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(codec, img, frame\_index, 1, flags);
38   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(codec, \textcolor{stringliteral}{"Failed to encode frame"});
39 
40   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(codec, &iter)) != NULL) \{
41     got\_pkts = 1;
42 
43     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
44       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
45       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
46                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
47                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts)) \{
48         die\_codec(codec, \textcolor{stringliteral}{"Failed to write compressed frame"});
49       \}
50       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
51       fflush(stdout);
52     \}
53   \}
54 
55   \textcolor{keywordflow}{return} got\_pkts;
56 \}
57 
58 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
59   FILE *infile = NULL;
60   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
61   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
62   \textcolor{keywordtype}{int} frame\_count = 0;
63   \hyperlink{structaom__image}{aom\_image\_t} raw;
64   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
65   AvxVideoInfo info;
66   AvxVideoWriter *writer = NULL;
67   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
68   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
69 
70   exec\_name = argv[0];
71 
72   \textcolor{comment}{// Clear explicitly, as simply assigning "\{ 0 \}" generates}
73   \textcolor{comment}{// "missing-field-initializers" warning in some compilers.}
74   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
75 
76   \textcolor{keywordflow}{if} (argc < 5) die(\textcolor{stringliteral}{"Invalid number of arguments"});
77 
78   encoder = get\_aom\_encoder\_by\_name(\textcolor{stringliteral}{"av1"});
79   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
80 
81   info.codec\_fourcc = encoder->fourcc;
82   info.frame\_width = (int)strtol(argv[1], NULL, 0);
83   info.frame\_height = (int)strtol(argv[2], NULL, 0);
84   info.time\_base.numerator = 1;
85   info.time\_base.denominator = fps;
86 
87   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0 ||
88       (info.frame\_width % 2) != 0 || (info.frame\_height % 2) != 0) \{
89     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
90   \}
91 
92   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
93                      info.frame\_height, 1)) \{
94     die(\textcolor{stringliteral}{"Failed to allocate image."});
95   \}
96 
97   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
98 
99   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
100   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
101 
102   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
103   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
104   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
105   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
106 
107   writer = aom\_video\_writer\_open(argv[4], kContainerIVF, &info);
108   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[4]);
109 
110   \textcolor{keywordflow}{if} (!(infile = fopen(argv[3], \textcolor{stringliteral}{"rb"})))
111     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[3]);
112 
113   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), &cfg, 0))
114     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
115 
116   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5afe875c6bb02f236be503c8c7b1f15875}{AV1E\_SET\_LOSSLESS}, 1))
117     die\_codec(&codec, \textcolor{stringliteral}{"Failed to use lossless mode"});
118 
119   \textcolor{comment}{// Encode frames.}
120   \textcolor{keywordflow}{while} (aom\_img\_read(&raw, infile)) \{
121     encode\_frame(&codec, &raw, frame\_count++, 0, writer);
122   \}
123 
124   \textcolor{comment}{// Flush encoder.}
125   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 0, writer)) \{
126   \}
127 
128   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
129   fclose(infile);
130   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_count);
131 
132   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
133   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
134 
135   aom\_video\_writer\_close(writer);
136 
137   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
138 \}
\end{DoxyCodeInclude}
 \hypertarget{example_set_maps}{}\subsection{set\+\_\+maps}\label{example_set_maps}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// AOM Set Active and ROI Maps}
13 \textcolor{comment}{// ===========================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example demonstrating how to control the AOM encoder's}
16 \textcolor{comment}{// ROI and Active maps.}
17 \textcolor{comment}{//}
18 \textcolor{comment}{// ROI (Reigon of Interest) maps are a way for the application to assign}
19 \textcolor{comment}{// each macroblock in the image to a region, and then set quantizer and}
20 \textcolor{comment}{// filtering parameters on that image.}
21 \textcolor{comment}{//}
22 \textcolor{comment}{// Active maps are a way for the application to specify on a}
23 \textcolor{comment}{// macroblock-by-macroblock basis whether there is any activity in that}
24 \textcolor{comment}{// macroblock.}
25 \textcolor{comment}{//}
26 \textcolor{comment}{//}
27 \textcolor{comment}{// Configuration}
28 \textcolor{comment}{// -------------}
29 \textcolor{comment}{// An ROI map is set on frame 22. If the width of the image in macroblocks}
30 \textcolor{comment}{// is evenly divisble by 4, then the output will appear to have distinct}
31 \textcolor{comment}{// columns, where the quantizer, loopfilter, and static threshold differ}
32 \textcolor{comment}{// from column to column.}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// An active map is set on frame 33. If the width of the image in macroblocks}
35 \textcolor{comment}{// is evenly divisble by 4, then the output will appear to have distinct}
36 \textcolor{comment}{// columns, where one column will have motion and the next will not.}
37 \textcolor{comment}{//}
38 \textcolor{comment}{// The active map is cleared on frame 44.}
39 \textcolor{comment}{//}
40 \textcolor{comment}{// Observing The Effects}
41 \textcolor{comment}{// ---------------------}
42 \textcolor{comment}{// Use the `simple\_decoder` example to decode this sample, and observe}
43 \textcolor{comment}{// the change in the image at frames 22, 33, and 44.}
44 
45 \textcolor{preprocessor}{#include <assert.h>}
46 \textcolor{preprocessor}{#include <stdio.h>}
47 \textcolor{preprocessor}{#include <stdlib.h>}
48 \textcolor{preprocessor}{#include <string.h>}
49 
50 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
51 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
52 \textcolor{preprocessor}{#include "common/tools\_common.h"}
53 \textcolor{preprocessor}{#include "common/video\_writer.h"}
54 
55 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
56 
57 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
58   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile> <outfile>\(\backslash\)n"},
59           exec\_name);
60   exit(EXIT\_FAILURE);
61 \}
62 
63 \textcolor{keyword}{static} \textcolor{keywordtype}{void} set\_active\_map(\textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg,
64                            \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec) \{
65   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i;
66   \hyperlink{structaom__active__map}{aom\_active\_map\_t} map = \{ 0, 0, 0 \};
67 
68   map.\hyperlink{structaom__active__map_a0d7ce0e1050137bf9b88e8649ea7aec2}{rows} = (cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} + 15) / 16;
69   map.\hyperlink{structaom__active__map_a3a105e0d8f2643cdc542e2f078b9e6b2}{cols} = (cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} + 15) / 16;
70 
71   map.\hyperlink{structaom__active__map_a8916917bce716b1d954a9f476d98142e}{active\_map} = (uint8\_t *)malloc(map.\hyperlink{structaom__active__map_a0d7ce0e1050137bf9b88e8649ea7aec2}{rows} * map.\hyperlink{structaom__active__map_a3a105e0d8f2643cdc542e2f078b9e6b2}{cols});
72   \textcolor{keywordflow}{for} (i = 0; i < map.\hyperlink{structaom__active__map_a0d7ce0e1050137bf9b88e8649ea7aec2}{rows} * map.\hyperlink{structaom__active__map_a3a105e0d8f2643cdc542e2f078b9e6b2}{cols}; ++i) map.\hyperlink{structaom__active__map_a8916917bce716b1d954a9f476d98142e}{active\_map}[i] = i % 2;
73 
74   if (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a709937e1e0eb160e49720e6fd5164d1e}{AOME\_SET\_ACTIVEMAP}, &map))
75     die\_codec(codec, \textcolor{stringliteral}{"Failed to set active map"});
76 
77   free(map.\hyperlink{structaom__active__map_a8916917bce716b1d954a9f476d98142e}{active\_map});
78 \}
79 
80 \textcolor{keyword}{static} \textcolor{keywordtype}{void} unset\_active\_map(\textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg,
81                              \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec) \{
82   \hyperlink{structaom__active__map}{aom\_active\_map\_t} map = \{ 0, 0, 0 \};
83 
84   map.\hyperlink{structaom__active__map_a0d7ce0e1050137bf9b88e8649ea7aec2}{rows} = (cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} + 15) / 16;
85   map.\hyperlink{structaom__active__map_a3a105e0d8f2643cdc542e2f078b9e6b2}{cols} = (cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} + 15) / 16;
86   map.\hyperlink{structaom__active__map_a8916917bce716b1d954a9f476d98142e}{active\_map} = NULL;
87 
88   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a709937e1e0eb160e49720e6fd5164d1e}{AOME\_SET\_ACTIVEMAP}, &map))
89     die\_codec(codec, \textcolor{stringliteral}{"Failed to set active map"});
90 \}
91 
92 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \hyperlink{structaom__image}{aom\_image\_t} *img,
93                         \textcolor{keywordtype}{int} frame\_index, AvxVideoWriter *writer) \{
94   \textcolor{keywordtype}{int} got\_pkts = 0;
95   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
96   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
97   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(codec, img, frame\_index, 1, 0
      );
98   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(codec, \textcolor{stringliteral}{"Failed to encode frame"});
99 
100   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(codec, &iter)) != NULL) \{
101     got\_pkts = 1;
102 
103     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
104       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
105       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
106                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
107                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts)) \{
108         die\_codec(codec, \textcolor{stringliteral}{"Failed to write compressed frame"});
109       \}
110 
111       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
112       fflush(stdout);
113     \}
114   \}
115 
116   \textcolor{keywordflow}{return} got\_pkts;
117 \}
118 
119 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
120   FILE *infile = NULL;
121   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
122   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
123   \textcolor{keywordtype}{int} frame\_count = 0;
124   \textcolor{keyword}{const} \textcolor{keywordtype}{int} limit = 15;
125   \hyperlink{structaom__image}{aom\_image\_t} raw;
126   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
127   AvxVideoInfo info;
128   AvxVideoWriter *writer = NULL;
129   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
130   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 2;  \textcolor{comment}{// TODO(dkovalev) add command line argument}
131   \textcolor{keyword}{const} \textcolor{keywordtype}{double} bits\_per\_pixel\_per\_frame = 0.067;
132 
133   exec\_name = argv[0];
134   \textcolor{keywordflow}{if} (argc != 6) die(\textcolor{stringliteral}{"Invalid number of arguments"});
135 
136   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
137 
138   encoder = get\_aom\_encoder\_by\_name(argv[1]);
139   \textcolor{keywordflow}{if} (encoder == NULL) \{
140     die(\textcolor{stringliteral}{"Unsupported codec."});
141   \}
142   assert(encoder != NULL);
143   info.codec\_fourcc = encoder->fourcc;
144   info.frame\_width = (int)strtol(argv[2], NULL, 0);
145   info.frame\_height = (int)strtol(argv[3], NULL, 0);
146   info.time\_base.numerator = 1;
147   info.time\_base.denominator = fps;
148 
149   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0 ||
150       (info.frame\_width % 2) != 0 || (info.frame\_height % 2) != 0) \{
151     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
152   \}
153 
154   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
155                      info.frame\_height, 1)) \{
156     die(\textcolor{stringliteral}{"Failed to allocate image."});
157   \}
158 
159   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
160 
161   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
162   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
163 
164   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
165   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
166   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
167   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
168   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} =
169       (\textcolor{keywordtype}{unsigned} int)(bits\_per\_pixel\_per\_frame * cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} * cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} * fps / 1000);
170   cfg.\hyperlink{structaom__codec__enc__cfg_a614a49318f2011cc8735d7e51b910fa4}{g\_lag\_in\_frames} = 0;
171 
172   writer = aom\_video\_writer\_open(argv[5], kContainerIVF, &info);
173   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[5]);
174 
175   \textcolor{keywordflow}{if} (!(infile = fopen(argv[4], \textcolor{stringliteral}{"rb"})))
176     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[4]);
177 
178   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), &cfg, 0))
179     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
180 
181   \textcolor{comment}{// Encode frames.}
182   \textcolor{keywordflow}{while} (aom\_img\_read(&raw, infile) && frame\_count < limit) \{
183     ++frame\_count;
184 
185     \textcolor{keywordflow}{if} (frame\_count == 5) \{
186       set\_active\_map(&cfg, &codec);
187     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (frame\_count == 11) \{
188       unset\_active\_map(&cfg, &codec);
189     \}
190 
191     encode\_frame(&codec, &raw, frame\_count, writer);
192   \}
193 
194   \textcolor{comment}{// Flush encoder.}
195   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, writer)) \{
196   \}
197 
198   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
199   fclose(infile);
200   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_count);
201 
202   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
203   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
204 
205   aom\_video\_writer\_close(writer);
206 
207   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
208 \}
\end{DoxyCodeInclude}
 \hypertarget{example_simple_encoder}{}\subsection{simple\+\_\+encoder}\label{example_simple_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Simple Encoder}
13 \textcolor{comment}{// ==============}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a simple encoder loop. It takes an input file in}
16 \textcolor{comment}{// YV12 format, passes it through the encoder, and writes the compressed}
17 \textcolor{comment}{// frames to disk in IVF format. Other decoder examples build upon this}
18 \textcolor{comment}{// one.}
19 \textcolor{comment}{//}
20 \textcolor{comment}{// The details of the IVF format have been elided from this example for}
21 \textcolor{comment}{// simplicity of presentation, as IVF files will not generally be used by}
22 \textcolor{comment}{// your application. In general, an IVF file consists of a file header,}
23 \textcolor{comment}{// followed by a variable number of frames. Each frame consists of a frame}
24 \textcolor{comment}{// header followed by a variable length payload. The length of the payload}
25 \textcolor{comment}{// is specified in the first four bytes of the frame header. The payload is}
26 \textcolor{comment}{// the raw compressed data.}
27 \textcolor{comment}{//}
28 \textcolor{comment}{// Standard Includes}
29 \textcolor{comment}{// -----------------}
30 \textcolor{comment}{// For encoders, you only have to include `aom\_encoder.h` and then any}
31 \textcolor{comment}{// header files for the specific codecs you use. In this case, we're using}
32 \textcolor{comment}{// aom.}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// Getting The Default Configuration}
35 \textcolor{comment}{// ---------------------------------}
36 \textcolor{comment}{// Encoders have the notion of "usage profiles." For example, an encoder}
37 \textcolor{comment}{// may want to publish default configurations for both a video}
38 \textcolor{comment}{// conferencing application and a best quality offline encoder. These}
39 \textcolor{comment}{// obviously have very different default settings. Consult the}
40 \textcolor{comment}{// documentation for your codec to see if it provides any default}
41 \textcolor{comment}{// configurations. All codecs provide a default configuration, number 0,}
42 \textcolor{comment}{// which is valid for material in the vacinity of QCIF/QVGA.}
43 \textcolor{comment}{//}
44 \textcolor{comment}{// Updating The Configuration}
45 \textcolor{comment}{// ---------------------------------}
46 \textcolor{comment}{// Almost all applications will want to update the default configuration}
47 \textcolor{comment}{// with settings specific to their usage. Here we set the width and height}
48 \textcolor{comment}{// of the video file to that specified on the command line. We also scale}
49 \textcolor{comment}{// the default bitrate based on the ratio between the default resolution}
50 \textcolor{comment}{// and the resolution specified on the command line.}
51 \textcolor{comment}{//}
52 \textcolor{comment}{// Initializing The Codec}
53 \textcolor{comment}{// ----------------------}
54 \textcolor{comment}{// The encoder is initialized by the following code.}
55 \textcolor{comment}{//}
56 \textcolor{comment}{// Encoding A Frame}
57 \textcolor{comment}{// ----------------}
58 \textcolor{comment}{// The frame is read as a continuous block (size width * height * 3 / 2)}
59 \textcolor{comment}{// from the input file. If a frame was read (the input file has not hit}
60 \textcolor{comment}{// EOF) then the frame is passed to the encoder. Otherwise, a NULL}
61 \textcolor{comment}{// is passed, indicating the End-Of-Stream condition to the encoder. The}
62 \textcolor{comment}{// `frame\_cnt` is reused as the presentation time stamp (PTS) and each}
63 \textcolor{comment}{// frame is shown for one frame-time in duration. The flags parameter is}
64 \textcolor{comment}{// unused in this example.}
65 
66 \textcolor{comment}{// Forced Keyframes}
67 \textcolor{comment}{// ----------------}
68 \textcolor{comment}{// Keyframes can be forced by setting the AOM\_EFLAG\_FORCE\_KF bit of the}
69 \textcolor{comment}{// flags passed to `aom\_codec\_control()`. In this example, we force a}
70 \textcolor{comment}{// keyframe every <keyframe-interval> frames. Note, the output stream can}
71 \textcolor{comment}{// contain additional keyframes beyond those that have been forced using the}
72 \textcolor{comment}{// AOM\_EFLAG\_FORCE\_KF flag because of automatic keyframe placement by the}
73 \textcolor{comment}{// encoder.}
74 \textcolor{comment}{//}
75 \textcolor{comment}{// Processing The Encoded Data}
76 \textcolor{comment}{// ---------------------------}
77 \textcolor{comment}{// Each packet of type `AOM\_CODEC\_CX\_FRAME\_PKT` contains the encoded data}
78 \textcolor{comment}{// for this frame. We write a IVF frame header, followed by the raw data.}
79 \textcolor{comment}{//}
80 \textcolor{comment}{// Cleanup}
81 \textcolor{comment}{// -------}
82 \textcolor{comment}{// The `aom\_codec\_destroy` call frees any memory allocated by the codec.}
83 \textcolor{comment}{//}
84 \textcolor{comment}{// Error Handling}
85 \textcolor{comment}{// --------------}
86 \textcolor{comment}{// This example does not special case any error return codes. If there was}
87 \textcolor{comment}{// an error, a descriptive message is printed and the program exits. With}
88 \textcolor{comment}{// few exeptions, aom\_codec functions return an enumerated error status,}
89 \textcolor{comment}{// with the value `0` indicating success.}
90 \textcolor{comment}{//}
91 \textcolor{comment}{// Error Resiliency Features}
92 \textcolor{comment}{// -------------------------}
93 \textcolor{comment}{// Error resiliency is controlled by the g\_error\_resilient member of the}
94 \textcolor{comment}{// configuration structure. Use the `decode\_with\_drops` example to decode with}
95 \textcolor{comment}{// frames 5-10 dropped. Compare the output for a file encoded with this example}
96 \textcolor{comment}{// versus one encoded with the `simple\_encoder` example.}
97 
98 \textcolor{preprocessor}{#include <stdio.h>}
99 \textcolor{preprocessor}{#include <stdlib.h>}
100 \textcolor{preprocessor}{#include <string.h>}
101 
102 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
103 \textcolor{preprocessor}{#include "common/tools\_common.h"}
104 \textcolor{preprocessor}{#include "common/video\_writer.h"}
105 
106 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
107 
108 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
109   fprintf(stderr,
110           \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile> <outfile> "}
111           \textcolor{stringliteral}{"<keyframe-interval> <error-resilient> <frames to encode>\(\backslash\)n"}
112           \textcolor{stringliteral}{"See comments in simple\_encoder.c for more information.\(\backslash\)n"},
113           exec\_name);
114   exit(EXIT\_FAILURE);
115 \}
116 
117 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \hyperlink{structaom__image}{aom\_image\_t} *img,
118                         \textcolor{keywordtype}{int} frame\_index, \textcolor{keywordtype}{int} flags, AvxVideoWriter *writer) \{
119   \textcolor{keywordtype}{int} got\_pkts = 0;
120   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
121   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
122   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res =
123       \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(codec, img, frame\_index, 1, flags);
124   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(codec, \textcolor{stringliteral}{"Failed to encode frame"});
125 
126   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(codec, &iter)) != NULL) \{
127     got\_pkts = 1;
128 
129     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
130       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
131       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
132                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
133                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts)) \{
134         die\_codec(codec, \textcolor{stringliteral}{"Failed to write compressed frame"});
135       \}
136       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
137       fflush(stdout);
138     \}
139   \}
140 
141   \textcolor{keywordflow}{return} got\_pkts;
142 \}
143 
144 \textcolor{comment}{// TODO(tomfinegan): Improve command line parsing and add args for bitrate/fps.}
145 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
146   FILE *infile = NULL;
147   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
148   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
149   \textcolor{keywordtype}{int} frame\_count = 0;
150   \hyperlink{structaom__image}{aom\_image\_t} raw;
151   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
152   AvxVideoInfo info;
153   AvxVideoWriter *writer = NULL;
154   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
155   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
156   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 200;
157   \textcolor{keywordtype}{int} keyframe\_interval = 0;
158   \textcolor{keywordtype}{int} max\_frames = 0;
159   \textcolor{keywordtype}{int} frames\_encoded = 0;
160   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *codec\_arg = NULL;
161   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *width\_arg = NULL;
162   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *height\_arg = NULL;
163   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *infile\_arg = NULL;
164   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_arg = NULL;
165   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *keyframe\_interval\_arg = NULL;
166 
167   exec\_name = argv[0];
168 
169   \textcolor{comment}{// Clear explicitly, as simply assigning "\{ 0 \}" generates}
170   \textcolor{comment}{// "missing-field-initializers" warning in some compilers.}
171   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
172 
173   \textcolor{keywordflow}{if} (argc != 9) die(\textcolor{stringliteral}{"Invalid number of arguments"});
174 
175   codec\_arg = argv[1];
176   width\_arg = argv[2];
177   height\_arg = argv[3];
178   infile\_arg = argv[4];
179   outfile\_arg = argv[5];
180   keyframe\_interval\_arg = argv[6];
181   max\_frames = (int)strtol(argv[8], NULL, 0);
182 
183   encoder = get\_aom\_encoder\_by\_name(codec\_arg);
184   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
185 
186   info.codec\_fourcc = encoder->fourcc;
187   info.frame\_width = (int)strtol(width\_arg, NULL, 0);
188   info.frame\_height = (int)strtol(height\_arg, NULL, 0);
189   info.time\_base.numerator = 1;
190   info.time\_base.denominator = fps;
191 
192   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0 ||
193       (info.frame\_width % 2) != 0 || (info.frame\_height % 2) != 0) \{
194     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
195   \}
196 
197   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
198                      info.frame\_height, 1)) \{
199     die(\textcolor{stringliteral}{"Failed to allocate image."});
200   \}
201 
202   keyframe\_interval = (int)strtol(keyframe\_interval\_arg, NULL, 0);
203   \textcolor{keywordflow}{if} (keyframe\_interval < 0) die(\textcolor{stringliteral}{"Invalid keyframe interval value."});
204 
205   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
206 
207   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
208   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
209 
210   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
211   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
212   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
213   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
214   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
215   cfg.\hyperlink{structaom__codec__enc__cfg_a8f3763485bb1f6eea6466b2fe0da2304}{g\_error\_resilient} = (\hyperlink{group__encoder_ga5f326af84993f371bb165883bb5a5a59}{aom\_codec\_er\_flags\_t})strtoul(argv[7], NULL,
       0);
216 
217   writer = aom\_video\_writer\_open(outfile\_arg, kContainerIVF, &info);
218   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, outfile\_arg);
219 
220   \textcolor{keywordflow}{if} (!(infile = fopen(infile\_arg, \textcolor{stringliteral}{"rb"})))
221     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, infile\_arg);
222 
223   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), &cfg, 0))
224     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
225 
226   \textcolor{comment}{// Encode frames.}
227   \textcolor{keywordflow}{while} (aom\_img\_read(&raw, infile)) \{
228     \textcolor{keywordtype}{int} flags = 0;
229     \textcolor{keywordflow}{if} (keyframe\_interval > 0 && frame\_count % keyframe\_interval == 0)
230       flags |= \hyperlink{group__encoder_ga86a6a9053205149cccc98481b5460337}{AOM\_EFLAG\_FORCE\_KF};
231     encode\_frame(&codec, &raw, frame\_count++, flags, writer);
232     frames\_encoded++;
233     \textcolor{keywordflow}{if} (max\_frames > 0 && frames\_encoded >= max\_frames) \textcolor{keywordflow}{break};
234   \}
235 
236   \textcolor{comment}{// Flush encoder.}
237   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 0, writer)) \textcolor{keywordflow}{continue};
238 
239   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
240   fclose(infile);
241   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_count);
242 
243   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
244   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
245 
246   aom\_video\_writer\_close(writer);
247 
248   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
249 \}
\end{DoxyCodeInclude}
 \hypertarget{example_twopass_encoder}{}\subsection{twopass\+\_\+encoder}\label{example_twopass_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Two Pass Encoder}
13 \textcolor{comment}{// ================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a two pass encoder loop. It takes an input file in}
16 \textcolor{comment}{// YV12 format, passes it through the encoder twice, and writes the compressed}
17 \textcolor{comment}{// frames to disk in IVF format. It builds upon the simple\_encoder example.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// Twopass Variables}
20 \textcolor{comment}{// -----------------}
21 \textcolor{comment}{// Twopass mode needs to track the current pass number and the buffer of}
22 \textcolor{comment}{// statistics packets.}
23 \textcolor{comment}{//}
24 \textcolor{comment}{// Updating The Configuration}
25 \textcolor{comment}{// ---------------------------------}
26 \textcolor{comment}{// In two pass mode, the configuration has to be updated on each pass. The}
27 \textcolor{comment}{// statistics buffer is passed on the last pass.}
28 \textcolor{comment}{//}
29 \textcolor{comment}{// Encoding A Frame}
30 \textcolor{comment}{// ----------------}
31 \textcolor{comment}{// Encoding a frame in two pass mode is identical to the simple encoder}
32 \textcolor{comment}{// example.}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// Processing Statistics Packets}
35 \textcolor{comment}{// -----------------------------}
36 \textcolor{comment}{// Each packet of type `AOM\_CODEC\_CX\_FRAME\_PKT` contains the encoded data}
37 \textcolor{comment}{// for this frame. We write a IVF frame header, followed by the raw data.}
38 \textcolor{comment}{//}
39 \textcolor{comment}{//}
40 \textcolor{comment}{// Pass Progress Reporting}
41 \textcolor{comment}{// -----------------------------}
42 \textcolor{comment}{// It's sometimes helpful to see when each pass completes.}
43 \textcolor{comment}{//}
44 \textcolor{comment}{//}
45 \textcolor{comment}{// Clean-up}
46 \textcolor{comment}{// -----------------------------}
47 \textcolor{comment}{// Destruction of the encoder instance must be done on each pass. The}
48 \textcolor{comment}{// raw image should be destroyed at the end as usual.}
49 
50 \textcolor{preprocessor}{#include <stdio.h>}
51 \textcolor{preprocessor}{#include <stdlib.h>}
52 \textcolor{preprocessor}{#include <string.h>}
53 
54 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
55 \textcolor{preprocessor}{#include "common/tools\_common.h"}
56 \textcolor{preprocessor}{#include "common/video\_writer.h"}
57 
58 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
59 
60 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
61   fprintf(stderr,
62           \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile> <outfile> "}
63           \textcolor{stringliteral}{"<limit(optional)>\(\backslash\)n"},
64           exec\_name);
65   exit(EXIT\_FAILURE);
66 \}
67 
68 \textcolor{keyword}{static} \textcolor{keywordtype}{int} get\_frame\_stats(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} 
      \hyperlink{structaom__image}{aom\_image\_t} *img,
69                            \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} duration,
70                            \hyperlink{group__encoder_gacbef92200b831adb94283f84128f83de}{aom\_enc\_frame\_flags\_t} flags,
71                            \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} *stats) \{
72   \textcolor{keywordtype}{int} got\_pkts = 0;
73   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
74   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
75   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ctx, img, pts, duration, 
      flags);
76   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ctx, \textcolor{stringliteral}{"Failed to get frame stats."});
77 
78   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ctx, &iter)) != NULL) \{
79     got\_pkts = 1;
80 
81     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda7dcdcb6c401cac64ca98b51f52de8d4b}{AOM\_CODEC\_STATS\_PKT}) \{
82       \textcolor{keyword}{const} uint8\_t *\textcolor{keyword}{const} pkt\_buf = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.
      \hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf};
83       \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} pkt\_size = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
84       stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf} = realloc(stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf}, stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz} + pkt\_size);
85       memcpy((uint8\_t *)stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf} + stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz}, pkt\_buf, pkt\_size);
86       stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz} += pkt\_size;
87     \}
88   \}
89 
90   \textcolor{keywordflow}{return} got\_pkts;
91 \}
92 
93 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img,
94                         \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} duration,
95                         \hyperlink{group__encoder_gacbef92200b831adb94283f84128f83de}{aom\_enc\_frame\_flags\_t} flags, AvxVideoWriter *writer) \{
96   \textcolor{keywordtype}{int} got\_pkts = 0;
97   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
98   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
99   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ctx, img, pts, duration, 
      flags);
100   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ctx, \textcolor{stringliteral}{"Failed to encode frame."});
101 
102   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ctx, &iter)) != NULL) \{
103     got\_pkts = 1;
104     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
105       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
106 
107       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
108                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
109                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts))
110         die\_codec(ctx, \textcolor{stringliteral}{"Failed to write compressed frame."});
111       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
112       fflush(stdout);
113     \}
114   \}
115 
116   \textcolor{keywordflow}{return} got\_pkts;
117 \}
118 
119 \textcolor{keyword}{static} \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} pass0(\hyperlink{structaom__image}{aom\_image\_t} *raw, FILE *infile,
120                              \textcolor{keyword}{const} AvxInterface *encoder,
121                              \textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg, \textcolor{keywordtype}{int} limit) \{
122   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
123   \textcolor{keywordtype}{int} frame\_count = 0;
124   \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} stats = \{ NULL, 0 \};
125 
126   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), cfg, 0))
127     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
128 
129   \textcolor{comment}{// Calculate frame statistics.}
130   \textcolor{keywordflow}{while} (aom\_img\_read(raw, infile) && frame\_count < limit) \{
131     ++frame\_count;
132     get\_frame\_stats(&codec, raw, frame\_count, 1, 0, &stats);
133   \}
134 
135   \textcolor{comment}{// Flush encoder.}
136   \textcolor{keywordflow}{while} (get\_frame\_stats(&codec, NULL, frame\_count, 1, 0, &stats)) \{
137   \}
138 
139   printf(\textcolor{stringliteral}{"Pass 0 complete. Processed %d frames.\(\backslash\)n"}, frame\_count);
140   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
141 
142   \textcolor{keywordflow}{return} stats;
143 \}
144 
145 \textcolor{keyword}{static} \textcolor{keywordtype}{void} pass1(\hyperlink{structaom__image}{aom\_image\_t} *raw, FILE *infile, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_name,
146                   \textcolor{keyword}{const} AvxInterface *encoder, \textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg,
147                   \textcolor{keywordtype}{int} limit) \{
148   AvxVideoInfo info = \{ encoder->fourcc,
149                         cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w},
150                         cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h},
151                         \{ cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num}, cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.
      \hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} \},
152                         0 \};
153   AvxVideoWriter *writer = NULL;
154   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
155   \textcolor{keywordtype}{int} frame\_count = 0;
156 
157   writer = aom\_video\_writer\_open(outfile\_name, kContainerIVF, &info);
158   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing"}, outfile\_name);
159 
160   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), cfg, 0))
161     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
162 
163   \textcolor{comment}{// Encode frames.}
164   \textcolor{keywordflow}{while} (aom\_img\_read(raw, infile) && frame\_count < limit) \{
165     ++frame\_count;
166     encode\_frame(&codec, raw, frame\_count, 1, 0, writer);
167   \}
168 
169   \textcolor{comment}{// Flush encoder.}
170   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 1, 0, writer)) \{
171   \}
172 
173   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
174 
175   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
176 
177   aom\_video\_writer\_close(writer);
178 
179   printf(\textcolor{stringliteral}{"Pass 1 complete. Processed %d frames.\(\backslash\)n"}, frame\_count);
180 \}
181 
182 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
183   FILE *infile = NULL;
184   \textcolor{keywordtype}{int} w, h;
185   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
186   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
187   \hyperlink{structaom__image}{aom\_image\_t} raw;
188   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
189   \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} stats;
190 
191   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
192   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;       \textcolor{comment}{// TODO(dkovalev) add command line argument}
193   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 200;  \textcolor{comment}{// kbit/s TODO(dkovalev) add command line argument}
194   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} codec\_arg = argv[1];
195   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} width\_arg = argv[2];
196   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} height\_arg = argv[3];
197   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} infile\_arg = argv[4];
198   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} outfile\_arg = argv[5];
199   \textcolor{keywordtype}{int} limit = 0;
200   exec\_name = argv[0];
201 
202   \textcolor{keywordflow}{if} (argc < 6) die(\textcolor{stringliteral}{"Invalid number of arguments"});
203 
204   \textcolor{keywordflow}{if} (argc > 6) limit = (int)strtol(argv[6], NULL, 0);
205 
206   \textcolor{keywordflow}{if} (limit == 0) limit = 100;
207 
208   encoder = get\_aom\_encoder\_by\_name(codec\_arg);
209   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
210 
211   w = (int)strtol(width\_arg, NULL, 0);
212   h = (int)strtol(height\_arg, NULL, 0);
213 
214   \textcolor{keywordflow}{if} (w <= 0 || h <= 0 || (w % 2) != 0 || (h % 2) != 0)
215     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, w, h);
216 
217   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, w, h, 1))
218     die(\textcolor{stringliteral}{"Failed to allocate image"}, w, h);
219 
220   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
221 
222   \textcolor{comment}{// Configuration}
223   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
224   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
225 
226   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = w;
227   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = h;
228   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = 1;
229   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = fps;
230   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
231 
232   \textcolor{keywordflow}{if} (!(infile = fopen(infile\_arg, \textcolor{stringliteral}{"rb"})))
233     die(\textcolor{stringliteral}{"Failed to open %s for reading"}, infile\_arg);
234 
235   \textcolor{comment}{// Pass 0}
236   cfg.\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} = \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS};
237   stats = pass0(&raw, infile, encoder, &cfg, limit);
238 
239   \textcolor{comment}{// Pass 1}
240   rewind(infile);
241   cfg.\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} = \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1a621c3f07937527618dc06e962425f6cc}{AOM\_RC\_LAST\_PASS};
242   cfg.\hyperlink{structaom__codec__enc__cfg_ad5c6f5c96ec54cabc71edb01045a1f04}{rc\_twopass\_stats\_in} = stats;
243   pass1(&raw, infile, outfile\_arg, encoder, &cfg, limit);
244   free(stats.\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf});
245 
246   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
247   fclose(infile);
248 
249   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
250 \}
\end{DoxyCodeInclude}
 \hypertarget{example_scalable_encoder}{}\subsection{scalable\+\_\+encoder}\label{example_scalable_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2018, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Scalable Encoder}
13 \textcolor{comment}{// ==============}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a scalable encoder loop. It takes two input files in}
16 \textcolor{comment}{// YV12 format, passes it through the encoder, and writes the compressed}
17 \textcolor{comment}{// frames to disk in OBU format.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// Getting The Default Configuration}
20 \textcolor{comment}{// ---------------------------------}
21 \textcolor{comment}{// Encoders have the notion of "usage profiles." For example, an encoder}
22 \textcolor{comment}{// may want to publish default configurations for both a video}
23 \textcolor{comment}{// conferencing application and a best quality offline encoder. These}
24 \textcolor{comment}{// obviously have very different default settings. Consult the}
25 \textcolor{comment}{// documentation for your codec to see if it provides any default}
26 \textcolor{comment}{// configurations. All codecs provide a default configuration, number 0,}
27 \textcolor{comment}{// which is valid for material in the vacinity of QCIF/QVGA.}
28 \textcolor{comment}{//}
29 \textcolor{comment}{// Updating The Configuration}
30 \textcolor{comment}{// ---------------------------------}
31 \textcolor{comment}{// Almost all applications will want to update the default configuration}
32 \textcolor{comment}{// with settings specific to their usage. Here we set the width and height}
33 \textcolor{comment}{// of the video file to that specified on the command line. We also scale}
34 \textcolor{comment}{// the default bitrate based on the ratio between the default resolution}
35 \textcolor{comment}{// and the resolution specified on the command line.}
36 \textcolor{comment}{//}
37 \textcolor{comment}{// Encoding A Frame}
38 \textcolor{comment}{// ----------------}
39 \textcolor{comment}{// The frame is read as a continuous block (size = width * height * 3 / 2)}
40 \textcolor{comment}{// from the input file. If a frame was read (the input file has not hit}
41 \textcolor{comment}{// EOF) then the frame is passed to the encoder. Otherwise, a NULL}
42 \textcolor{comment}{// is passed, indicating the End-Of-Stream condition to the encoder. The}
43 \textcolor{comment}{// `frame\_cnt` is reused as the presentation time stamp (PTS) and each}
44 \textcolor{comment}{// frame is shown for one frame-time in duration. The flags parameter is}
45 \textcolor{comment}{// unused in this example.}
46 
47 \textcolor{comment}{// Forced Keyframes}
48 \textcolor{comment}{// ----------------}
49 \textcolor{comment}{// Keyframes can be forced by setting the AOM\_EFLAG\_FORCE\_KF bit of the}
50 \textcolor{comment}{// flags passed to `aom\_codec\_control()`. In this example, we force a}
51 \textcolor{comment}{// keyframe every <keyframe-interval> frames. Note, the output stream can}
52 \textcolor{comment}{// contain additional keyframes beyond those that have been forced using the}
53 \textcolor{comment}{// AOM\_EFLAG\_FORCE\_KF flag because of automatic keyframe placement by the}
54 \textcolor{comment}{// encoder.}
55 \textcolor{comment}{//}
56 \textcolor{comment}{// Processing The Encoded Data}
57 \textcolor{comment}{// ---------------------------}
58 \textcolor{comment}{// Each packet of type `AOM\_CODEC\_CX\_FRAME\_PKT` contains the encoded data}
59 \textcolor{comment}{// for this frame. We write a IVF frame header, followed by the raw data.}
60 \textcolor{comment}{//}
61 \textcolor{comment}{// Cleanup}
62 \textcolor{comment}{// -------}
63 \textcolor{comment}{// The `aom\_codec\_destroy` call frees any memory allocated by the codec.}
64 \textcolor{comment}{//}
65 \textcolor{comment}{// Error Handling}
66 \textcolor{comment}{// --------------}
67 \textcolor{comment}{// This example does not special case any error return codes. If there was}
68 \textcolor{comment}{// an error, a descriptive message is printed and the program exits. With}
69 \textcolor{comment}{// few exeptions, aom\_codec functions return an enumerated error status,}
70 \textcolor{comment}{// with the value `0` indicating success.}
71 
72 \textcolor{preprocessor}{#include <stdio.h>}
73 \textcolor{preprocessor}{#include <stdlib.h>}
74 \textcolor{preprocessor}{#include <string.h>}
75 
76 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
77 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
78 \textcolor{preprocessor}{#include "av1/common/enums.h"}
79 \textcolor{preprocessor}{#include "common/tools\_common.h"}
80 \textcolor{preprocessor}{#include "common/video\_writer.h"}
81 
82 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
83 
84 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
85   fprintf(stderr,
86           \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile0> <infile1> "}
87           \textcolor{stringliteral}{"<outfile> <frames to encode>\(\backslash\)n"}
88           \textcolor{stringliteral}{"See comments in scalable\_encoder.c for more information.\(\backslash\)n"},
89           exec\_name);
90   exit(EXIT\_FAILURE);
91 \}
92 
93 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \hyperlink{structaom__image}{aom\_image\_t} *img,
94                         \textcolor{keywordtype}{int} frame\_index, \textcolor{keywordtype}{int} flags, FILE *outfile) \{
95   \textcolor{keywordtype}{int} got\_pkts = 0;
96   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
97   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
98   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res =
99       \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(codec, img, frame\_index, 1, flags);
100   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(codec, \textcolor{stringliteral}{"Failed to encode frame"});
101 
102   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(codec, &iter)) != NULL) \{
103     got\_pkts = 1;
104 
105     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
106       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
107       \textcolor{keywordflow}{if} (fwrite(pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf, 1, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz, outfile) !=
108           pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz) \{
109         die\_codec(codec, \textcolor{stringliteral}{"Failed to write compressed frame"});
110       \}
111       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
112       printf(\textcolor{stringliteral}{" %6d\(\backslash\)n"}, (\textcolor{keywordtype}{int})pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz);
113       fflush(stdout);
114     \}
115   \}
116 
117   \textcolor{keywordflow}{return} got\_pkts;
118 \}
119 
120 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
121   FILE *infile0 = NULL;
122   FILE *infile1 = NULL;
123   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
124   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
125   \textcolor{keywordtype}{int} frame\_count = 0;
126   \hyperlink{structaom__image}{aom\_image\_t} raw0, raw1;
127   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
128   AvxVideoInfo info;
129   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
130   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
131   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 200;
132   \textcolor{keywordtype}{int} keyframe\_interval = 0;
133   \textcolor{keywordtype}{int} max\_frames = 0;
134   \textcolor{keywordtype}{int} frames\_encoded = 0;
135   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *codec\_arg = NULL;
136   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *width\_arg = NULL;
137   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *height\_arg = NULL;
138   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *infile0\_arg = NULL;
139   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *infile1\_arg = NULL;
140   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_arg = NULL;
141   \textcolor{comment}{//  const char *keyframe\_interval\_arg = NULL;}
142   FILE *outfile = NULL;
143 
144   exec\_name = argv[0];
145 
146   \textcolor{comment}{// Clear explicitly, as simply assigning "\{ 0 \}" generates}
147   \textcolor{comment}{// "missing-field-initializers" warning in some compilers.}
148   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
149 
150   \textcolor{keywordflow}{if} (argc != 8) die(\textcolor{stringliteral}{"Invalid number of arguments"});
151 
152   codec\_arg = argv[1];
153   width\_arg = argv[2];
154   height\_arg = argv[3];
155   infile0\_arg = argv[4];
156   infile1\_arg = argv[5];
157   outfile\_arg = argv[6];
158   max\_frames = (int)strtol(argv[7], NULL, 0);
159 
160   encoder = get\_aom\_encoder\_by\_name(codec\_arg);
161   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
162 
163   info.codec\_fourcc = encoder->fourcc;
164   info.frame\_width = (int)strtol(width\_arg, NULL, 0);
165   info.frame\_height = (int)strtol(height\_arg, NULL, 0);
166   info.time\_base.numerator = 1;
167   info.time\_base.denominator = fps;
168 
169   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0 ||
170       (info.frame\_width % 2) != 0 || (info.frame\_height % 2) != 0) \{
171     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
172   \}
173 
174   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw0, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
175                      info.frame\_height, 1)) \{
176     die(\textcolor{stringliteral}{"Failed to allocate image for layer 0."});
177   \}
178   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw1, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
179                      info.frame\_height, 1)) \{
180     die(\textcolor{stringliteral}{"Failed to allocate image for layer 1."});
181   \}
182 
183   \textcolor{comment}{//  keyframe\_interval = (int)strtol(keyframe\_interval\_arg, NULL, 0);}
184   keyframe\_interval = 100;
185   \textcolor{keywordflow}{if} (keyframe\_interval < 0) die(\textcolor{stringliteral}{"Invalid keyframe interval value."});
186 
187   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
188 
189   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
190   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
191 
192   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
193   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
194   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
195   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
196   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
197   cfg.\hyperlink{structaom__codec__enc__cfg_a8f3763485bb1f6eea6466b2fe0da2304}{g\_error\_resilient} = 0;
198   cfg.\hyperlink{structaom__codec__enc__cfg_a614a49318f2011cc8735d7e51b910fa4}{g\_lag\_in\_frames} = 0;
199   cfg.\hyperlink{structaom__codec__enc__cfg_a3fd74d888658039d09bc4eacf163a495}{rc\_end\_usage} = \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957aff3bbd4fe870b4b946c2093e59eb14e5}{AOM\_Q};
200   cfg.\hyperlink{structaom__codec__enc__cfg_adb3fe41c1ce39579a49b97bc2ca7b2f2}{save\_as\_annexb} = 0;
201 
202   outfile = fopen(outfile\_arg, \textcolor{stringliteral}{"wb"});
203   \textcolor{keywordflow}{if} (!outfile) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, outfile\_arg);
204 
205   \textcolor{keywordflow}{if} (!(infile0 = fopen(infile0\_arg, \textcolor{stringliteral}{"rb"})))
206     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, infile0\_arg);
207   \textcolor{keywordflow}{if} (!(infile1 = fopen(infile1\_arg, \textcolor{stringliteral}{"rb"})))
208     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, infile0\_arg);
209 
210   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), &cfg, 0))
211     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
212   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5adac09e1a8da079b08fca5ccbf981f1a6}{AOME\_SET\_CPUUSED}, 8))
213     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set cpu to 8"});
214 
215   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5acf4ab1ff2fa8d76a78881ad7f1a1294d}{AV1E\_SET\_TILE\_COLUMNS}, 2))
216     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set tile columns to 2"});
217   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a9ac0044ad63e6848a482db04f0858c44}{AV1E\_SET\_NUM\_TG}, 3))
218     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set num of tile groups to 3"});
219 
220   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aef4facbd3745aa7f2a604faaf68316ff}{AOME\_SET\_NUMBER\_SPATIAL\_LAYERS}
      , 2))
221     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set number of spatial layers to 2"});
222 
223   \textcolor{comment}{// Encode frames.}
224   \textcolor{keywordflow}{while} (aom\_img\_read(&raw0, infile0)) \{
225     \textcolor{keywordtype}{int} flags = 0;
226 
227     \textcolor{comment}{// configure and encode base layer}
228 
229     \textcolor{keywordflow}{if} (keyframe\_interval > 0 && frames\_encoded % keyframe\_interval == 0)
230       flags |= \hyperlink{group__encoder_ga86a6a9053205149cccc98481b5460337}{AOM\_EFLAG\_FORCE\_KF};
231     \textcolor{keywordflow}{else}
232       \textcolor{comment}{// use previous base layer (LAST) as sole reference}
233       \textcolor{comment}{// save this frame as LAST to be used as reference by enhanmcent layer}
234       \textcolor{comment}{// and next base layer}
235       flags |= \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
236                \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
237                \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
238                \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} | \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} |
239                \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY};
240     cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
241     cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
242     \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaf4a4c3c3c91dd92c960990f6e534271d}{aom\_codec\_enc\_config\_set}(&codec, &cfg))
243       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set enc cfg for layer 0"});
244     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aac7fbd0de7295387d7821f1889c47790}{AOME\_SET\_SPATIAL\_LAYER\_ID}, 0))
245       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set layer id to 0"});
246     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af67f265bf63bf8f1268b3a14ae26606c}{AOME\_SET\_CQ\_LEVEL}, 62))
247       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set cq level"});
248     encode\_frame(&codec, &raw0, frame\_count++, flags, outfile);
249 
250     \textcolor{comment}{// configure and encode enhancement layer}
251 
252     \textcolor{comment}{//  use LAST (base layer) as sole reference}
253     flags = \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
254             \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} | 
      \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} |
255             \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} | \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} |
256             \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} | \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} |
257             \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY};
258     cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
259     cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
260     aom\_img\_read(&raw1, infile1);
261     \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaf4a4c3c3c91dd92c960990f6e534271d}{aom\_codec\_enc\_config\_set}(&codec, &cfg))
262       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set enc cfg for layer 1"});
263     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aac7fbd0de7295387d7821f1889c47790}{AOME\_SET\_SPATIAL\_LAYER\_ID}, 1))
264       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set layer id to 1"});
265     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af67f265bf63bf8f1268b3a14ae26606c}{AOME\_SET\_CQ\_LEVEL}, 10))
266       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set cq level"});
267     encode\_frame(&codec, &raw1, frame\_count++, flags, outfile);
268 
269     frames\_encoded++;
270 
271     \textcolor{keywordflow}{if} (max\_frames > 0 && frames\_encoded >= max\_frames) \textcolor{keywordflow}{break};
272   \}
273 
274   \textcolor{comment}{// Flush encoder.}
275   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 0, outfile)) \textcolor{keywordflow}{continue};
276 
277   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
278   fclose(infile0);
279   fclose(infile1);
280   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_count / 2);
281 
282   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw0);
283   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw1);
284   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
285 
286   fclose(outfile);
287 
288   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
289 \}
\end{DoxyCodeInclude}
 \hypertarget{example_aom_cx_set_ref}{}\subsection{aom\+\_\+cx\+\_\+set\+\_\+ref}\label{example_aom_cx_set_ref}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// AV1 Set Reference Frame}
13 \textcolor{comment}{// ============================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example demonstrating how to overwrite the AV1 encoder's}
16 \textcolor{comment}{// internal reference frame. In the sample we set the last frame to the}
17 \textcolor{comment}{// current frame. This technique could be used to bounce between two cameras.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// The decoder would also have to set the reference frame to the same value}
20 \textcolor{comment}{// on the same frame, or the video will become corrupt. The 'test\_decode'}
21 \textcolor{comment}{// variable is set to 1 in this example that tests if the encoder and decoder}
22 \textcolor{comment}{// results are matching.}
23 \textcolor{comment}{//}
24 \textcolor{comment}{// Usage}
25 \textcolor{comment}{// -----}
26 \textcolor{comment}{// This example encodes a raw video. And the last argument passed in specifies}
27 \textcolor{comment}{// the frame number to update the reference frame on. For example, run}
28 \textcolor{comment}{// examples/aom\_cx\_set\_ref av1 352 288 in.yuv out.ivf 4 30}
29 \textcolor{comment}{// The parameter is parsed as follows:}
30 \textcolor{comment}{//}
31 \textcolor{comment}{//}
32 \textcolor{comment}{// Extra Variables}
33 \textcolor{comment}{// ---------------}
34 \textcolor{comment}{// This example maintains the frame number passed on the command line}
35 \textcolor{comment}{// in the `update\_frame\_num` variable.}
36 \textcolor{comment}{//}
37 \textcolor{comment}{//}
38 \textcolor{comment}{// Configuration}
39 \textcolor{comment}{// -------------}
40 \textcolor{comment}{//}
41 \textcolor{comment}{// The reference frame is updated on the frame specified on the command}
42 \textcolor{comment}{// line.}
43 \textcolor{comment}{//}
44 \textcolor{comment}{// Observing The Effects}
45 \textcolor{comment}{// ---------------------}
46 \textcolor{comment}{// The encoder and decoder results should be matching when the same reference}
47 \textcolor{comment}{// frame setting operation is done in both encoder and decoder. Otherwise,}
48 \textcolor{comment}{// the encoder/decoder mismatch would be seen.}
49 
50 \textcolor{preprocessor}{#include <stdio.h>}
51 \textcolor{preprocessor}{#include <stdlib.h>}
52 \textcolor{preprocessor}{#include <string.h>}
53 
54 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
55 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
56 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
57 \textcolor{preprocessor}{#include "aom\_scale/yv12config.h"}
58 \textcolor{preprocessor}{#include "common/tools\_common.h"}
59 \textcolor{preprocessor}{#include "common/video\_writer.h"}
60 \textcolor{preprocessor}{#include "examples/encoder\_util.h"}
61 
62 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
63 
64 \textcolor{keywordtype}{void} usage\_exit() \{
65   fprintf(stderr,
66           \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile> <outfile> "}
67           \textcolor{stringliteral}{"<frame> <limit(optional)>\(\backslash\)n"},
68           exec\_name);
69   exit(EXIT\_FAILURE);
70 \}
71 
72 \textcolor{keyword}{static} \textcolor{keywordtype}{void} testing\_decode(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *encoder, 
      \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *decoder,
73                            \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_out, \textcolor{keywordtype}{int} *mismatch\_seen) \{
74   \hyperlink{structaom__image}{aom\_image\_t} enc\_img, dec\_img;
75 
76   \textcolor{keywordflow}{if} (*mismatch\_seen) \textcolor{keywordflow}{return};
77 
78   \textcolor{comment}{/* Get the internal reference frame */}
79   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(encoder, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a410c706a34f5295996658cc5044a700f}{AV1\_GET\_NEW\_FRAME\_IMAGE}, &enc\_img)
      )
80     die\_codec(encoder, \textcolor{stringliteral}{"Failed to get encoder reference frame"});
81   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(decoder, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a410c706a34f5295996658cc5044a700f}{AV1\_GET\_NEW\_FRAME\_IMAGE}, &dec\_img)
      )
82     die\_codec(decoder, \textcolor{stringliteral}{"Failed to get decoder reference frame"});
83 
84   \textcolor{keywordflow}{if} ((enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) !=
85       (dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH})) \{
86     \textcolor{keywordflow}{if} (enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
87       \hyperlink{structaom__image}{aom\_image\_t} enc\_hbd\_img;
88       \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&enc\_hbd\_img, enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} - 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
89                     enc\_img.\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, enc\_img.\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
90       aom\_img\_truncate\_16\_to\_8(&enc\_hbd\_img, &enc\_img);
91       enc\_img = enc\_hbd\_img;
92     \}
93     \textcolor{keywordflow}{if} (dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
94       \hyperlink{structaom__image}{aom\_image\_t} dec\_hbd\_img;
95       \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&dec\_hbd\_img, dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} - 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
96                     dec\_img.\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, dec\_img.\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
97       aom\_img\_truncate\_16\_to\_8(&dec\_hbd\_img, &dec\_img);
98       dec\_img = dec\_hbd\_img;
99     \}
100   \}
101 
102   \textcolor{keywordflow}{if} (!aom\_compare\_img(&enc\_img, &dec\_img)) \{
103     \textcolor{keywordtype}{int} y[4], u[4], v[4];
104     \textcolor{keywordflow}{if} (enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
105       aom\_find\_mismatch\_high(&enc\_img, &dec\_img, y, u, v);
106     \} \textcolor{keywordflow}{else} \{
107       aom\_find\_mismatch(&enc\_img, &dec\_img, y, u, v);
108     \}
109 
110     printf(
111         \textcolor{stringliteral}{"Encode/decode mismatch on frame %d at"}
112         \textcolor{stringliteral}{" Y[%d, %d] \{%d/%d\},"}
113         \textcolor{stringliteral}{" U[%d, %d] \{%d/%d\},"}
114         \textcolor{stringliteral}{" V[%d, %d] \{%d/%d\}"},
115         frame\_out, y[0], y[1], y[2], y[3], u[0], u[1], u[2], u[3], v[0], v[1],
116         v[2], v[3]);
117     *mismatch\_seen = 1;
118   \}
119 
120   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&enc\_img);
121   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&dec\_img);
122 \}
123 
124 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ecodec, \hyperlink{structaom__image}{aom\_image\_t} *img,
125                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_in, AvxVideoWriter *writer,
126                         \textcolor{keywordtype}{int} test\_decode, \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *dcodec,
127                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *frame\_out, \textcolor{keywordtype}{int} *mismatch\_seen,
128                         \hyperlink{structaom__image}{aom\_image\_t} *ext\_ref) \{
129   \textcolor{keywordtype}{int} got\_pkts = 0;
130   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
131   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
132   \textcolor{keywordtype}{int} got\_data;
133   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ecodec, img, frame\_in, 1, 0);
134   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ecodec, \textcolor{stringliteral}{"Failed to encode frame"});
135 
136   got\_data = 0;
137 
138   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ecodec, &iter)) != NULL) \{
139     got\_pkts = 1;
140 
141     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
142       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
143 
144       ++*frame\_out;
145 
146       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
147                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
148                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts)) \{
149         die\_codec(ecodec, \textcolor{stringliteral}{"Failed to write compressed frame"});
150       \}
151       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
152       fflush(stdout);
153       got\_data = 1;
154 
155       \textcolor{comment}{// Decode 1 frame.}
156       \textcolor{keywordflow}{if} (test\_decode) \{
157         \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(dcodec, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
158                              (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz, NULL))
159           die\_codec(dcodec, \textcolor{stringliteral}{"Failed to decode frame."});
160 
161         \textcolor{comment}{// Copy out first decoded frame, and use it as reference later.}
162         \textcolor{keywordflow}{if} (*frame\_out == 1 && ext\_ref != NULL)
163           \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(dcodec, 
      \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659ae41763622ee33cd99e23ca8f78a3f8fa}{AV1\_COPY\_NEW\_FRAME\_IMAGE}, ext\_ref))
164             die\_codec(dcodec, \textcolor{stringliteral}{"Failed to get decoder new frame"});
165       \}
166     \}
167   \}
168 
169   \textcolor{comment}{// Mismatch checking}
170   \textcolor{keywordflow}{if} (got\_data && test\_decode) \{
171     testing\_decode(ecodec, dcodec, *frame\_out, mismatch\_seen);
172   \}
173 
174   \textcolor{keywordflow}{return} got\_pkts;
175 \}
176 
177 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
178   FILE *infile = NULL;
179   \textcolor{comment}{// Encoder}
180   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} ecodec;
181   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
182   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_in = 0;
183   \hyperlink{structaom__image}{aom\_image\_t} raw;
184   \hyperlink{structaom__image}{aom\_image\_t} raw\_shift;
185   \hyperlink{structaom__image}{aom\_image\_t} ext\_ref;
186   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
187   AvxVideoInfo info;
188   AvxVideoWriter *writer = NULL;
189   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
190   \textcolor{keywordtype}{int} flags = 0;
191   \textcolor{keywordtype}{int} allocated\_raw\_shift = 0;
192   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} raw\_fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420};
193   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420};
194 
195   \textcolor{comment}{// Test encoder/decoder mismatch.}
196   \textcolor{keywordtype}{int} test\_decode = 1;
197   \textcolor{comment}{// Decoder}
198   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} dcodec;
199   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_out = 0;
200 
201   \textcolor{comment}{// The frame number to set reference frame on}
202   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} update\_frame\_num = 0;
203   \textcolor{keywordtype}{int} mismatch\_seen = 0;
204 
205   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
206   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 500;
207 
208   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *codec\_arg = NULL;
209   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *width\_arg = NULL;
210   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *height\_arg = NULL;
211   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *infile\_arg = NULL;
212   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_arg = NULL;
213   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *update\_frame\_num\_arg = NULL;
214   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} limit = 0;
215   exec\_name = argv[0];
216 
217   \textcolor{comment}{// Clear explicitly, as simply assigning "\{ 0 \}" generates}
218   \textcolor{comment}{// "missing-field-initializers" warning in some compilers.}
219   memset(&ecodec, 0, \textcolor{keyword}{sizeof}(ecodec));
220   memset(&cfg, 0, \textcolor{keyword}{sizeof}(cfg));
221   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
222 
223   \textcolor{keywordflow}{if} (argc < 7) die(\textcolor{stringliteral}{"Invalid number of arguments"});
224 
225   codec\_arg = argv[1];
226   width\_arg = argv[2];
227   height\_arg = argv[3];
228   infile\_arg = argv[4];
229   outfile\_arg = argv[5];
230   update\_frame\_num\_arg = argv[6];
231 
232   encoder = get\_aom\_encoder\_by\_name(codec\_arg);
233   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
234 
235   update\_frame\_num = (\textcolor{keywordtype}{unsigned} int)strtoul(update\_frame\_num\_arg, NULL, 0);
236   \textcolor{comment}{// In AV1, the reference buffers (cm->buffer\_pool->frame\_bufs[i].buf) are}
237   \textcolor{comment}{// allocated while calling aom\_codec\_encode(), thus, setting reference for}
238   \textcolor{comment}{// 1st frame isn't supported.}
239   \textcolor{keywordflow}{if} (update\_frame\_num <= 1) \{
240     die(\textcolor{stringliteral}{"Couldn't parse frame number '%s'\(\backslash\)n"}, update\_frame\_num\_arg);
241   \}
242 
243   \textcolor{keywordflow}{if} (argc > 7) \{
244     limit = (\textcolor{keywordtype}{unsigned} int)strtoul(argv[7], NULL, 0);
245     \textcolor{keywordflow}{if} (update\_frame\_num > limit)
246       die(\textcolor{stringliteral}{"Update frame number couldn't larger than limit\(\backslash\)n"});
247   \}
248 
249   info.codec\_fourcc = encoder->fourcc;
250   info.frame\_width = (int)strtol(width\_arg, NULL, 0);
251   info.frame\_height = (int)strtol(height\_arg, NULL, 0);
252   info.time\_base.numerator = 1;
253   info.time\_base.denominator = fps;
254 
255   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0) \{
256     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
257   \}
258 
259   \textcolor{comment}{// In this test, the bit depth of input video is 8-bit, and the input format}
260   \textcolor{comment}{// is AOM\_IMG\_FMT\_I420.}
261   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, raw\_fmt, info.frame\_width, info.frame\_height, 32)) \{
262     die(\textcolor{stringliteral}{"Failed to allocate image."});
263   \}
264 
265   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) ref\_fmt |= \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH};
266   \textcolor{comment}{// Allocate memory with the border so that it can be used as a reference.}
267   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_aeb211e5184687f7e10d7c5bed4dcfdcd}{aom\_img\_alloc\_with\_border}(&ext\_ref, ref\_fmt, info.frame\_width,
268                                  info.frame\_height, 32, 8,
269                                  AOM\_BORDER\_IN\_PIXELS)) \{
270     die(\textcolor{stringliteral}{"Failed to allocate image."});
271   \}
272 
273   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
274 
275   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
276   \textcolor{keywordflow}{if} (res) die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to get default codec config."});
277 
278   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
279   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
280   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
281   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
282   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
283   cfg.\hyperlink{structaom__codec__enc__cfg_a614a49318f2011cc8735d7e51b910fa4}{g\_lag\_in\_frames} = 3;
284   cfg.\hyperlink{structaom__codec__enc__cfg_a76a27f44cded1516803a776a0a7e9038}{g\_bit\_depth} = \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8};
285 
286   flags |= (cfg.\hyperlink{structaom__codec__enc__cfg_a76a27f44cded1516803a776a0a7e9038}{g\_bit\_depth} > \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8} || !CONFIG\_LOWBITDEPTH)
287                ? \hyperlink{group__encoder_gae30bbbdef18e9da3631b69c170533e92}{AOM\_CODEC\_USE\_HIGHBITDEPTH}
288                : 0;
289 
290   writer = aom\_video\_writer\_open(outfile\_arg, kContainerIVF, &info);
291   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, outfile\_arg);
292 
293   \textcolor{keywordflow}{if} (!(infile = fopen(infile\_arg, \textcolor{stringliteral}{"rb"})))
294     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, infile\_arg);
295 
296   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&ecodec, encoder->codec\_interface(), &cfg, flags))
297     die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to initialize encoder"});
298 
299   \textcolor{comment}{// Disable alt\_ref.}
300   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&ecodec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF}, 0))
301     die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to set enable auto alt ref"});
302 
303   \textcolor{keywordflow}{if} (test\_decode) \{
304     \textcolor{keyword}{const} AvxInterface *decoder = get\_aom\_decoder\_by\_name(codec\_arg);
305     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&dcodec, decoder->codec\_interface(), NULL, 0))
306       die\_codec(&dcodec, \textcolor{stringliteral}{"Failed to initialize decoder."});
307   \}
308 
309   \textcolor{comment}{// Encode frames.}
310   \textcolor{keywordflow}{while} (aom\_img\_read(&raw, infile)) \{
311     \textcolor{keywordflow}{if} (limit && frame\_in >= limit) \textcolor{keywordflow}{break};
312     \hyperlink{structaom__image}{aom\_image\_t} *frame\_to\_encode;
313 
314     \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) \{
315       \textcolor{comment}{// Need to allocate larger buffer to use hbd internal.}
316       \textcolor{keywordtype}{int} input\_shift = 0;
317       \textcolor{keywordflow}{if} (!allocated\_raw\_shift) \{
318         \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw\_shift, raw\_fmt | 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
319                       info.frame\_width, info.frame\_height, 32);
320         allocated\_raw\_shift = 1;
321       \}
322       aom\_img\_upshift(&raw\_shift, &raw, input\_shift);
323       frame\_to\_encode = &raw\_shift;
324     \} \textcolor{keywordflow}{else} \{
325       frame\_to\_encode = &raw;
326     \}
327 
328     \textcolor{keywordflow}{if} (update\_frame\_num > 1 && frame\_out + 1 == update\_frame\_num) \{
329       \hyperlink{structav1__ref__frame}{av1\_ref\_frame\_t} ref;
330       ref.\hyperlink{structav1__ref__frame_a7c6fcaba58f514985448cb2e2245345c}{idx} = 0;
331       ref.\hyperlink{structav1__ref__frame_a33749c5c20033cc5f7582d0ec1c34ff0}{use\_external\_ref} = 0;
332       ref.\hyperlink{structav1__ref__frame_a55a09db9e1acdd73e656b01fa01283b3}{img} = ext\_ref;
333       \textcolor{comment}{// Set reference frame in encoder.}
334       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&ecodec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a51ad4467b4dc318406cceb257e2daa41}{AV1\_SET\_REFERENCE}, &ref))
335         die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to set encoder reference frame"});
336       printf(\textcolor{stringliteral}{" <SET\_REF>"});
337 
338       \textcolor{comment}{// If set\_reference in decoder is commented out, the enc/dec mismatch}
339       \textcolor{comment}{// would be seen.}
340       \textcolor{keywordflow}{if} (test\_decode) \{
341         ref.\hyperlink{structav1__ref__frame_a33749c5c20033cc5f7582d0ec1c34ff0}{use\_external\_ref} = 1;
342         \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&dcodec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a51ad4467b4dc318406cceb257e2daa41}{AV1\_SET\_REFERENCE}, &ref))
343           die\_codec(&dcodec, \textcolor{stringliteral}{"Failed to set decoder reference frame"});
344       \}
345     \}
346 
347     encode\_frame(&ecodec, frame\_to\_encode, frame\_in, writer, test\_decode,
348                  &dcodec, &frame\_out, &mismatch\_seen, &ext\_ref);
349     frame\_in++;
350     \textcolor{keywordflow}{if} (mismatch\_seen) \textcolor{keywordflow}{break};
351   \}
352 
353   \textcolor{comment}{// Flush encoder.}
354   \textcolor{keywordflow}{if} (!mismatch\_seen)
355     \textcolor{keywordflow}{while} (encode\_frame(&ecodec, NULL, frame\_in, writer, test\_decode, &dcodec,
356                         &frame\_out, &mismatch\_seen, NULL)) \{
357     \}
358 
359   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
360   fclose(infile);
361   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_out);
362 
363   \textcolor{keywordflow}{if} (test\_decode) \{
364     \textcolor{keywordflow}{if} (!mismatch\_seen)
365       printf(\textcolor{stringliteral}{"Encoder/decoder results are matching.\(\backslash\)n"});
366     \textcolor{keywordflow}{else}
367       printf(\textcolor{stringliteral}{"Encoder/decoder results are NOT matching.\(\backslash\)n"});
368   \}
369 
370   \textcolor{keywordflow}{if} (test\_decode)
371     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&dcodec))
372       die\_codec(&dcodec, \textcolor{stringliteral}{"Failed to destroy decoder"});
373 
374   \textcolor{keywordflow}{if} (allocated\_raw\_shift) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw\_shift);
375   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&ext\_ref);
376   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
377   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&ecodec))
378     die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to destroy encoder."});
379 
380   aom\_video\_writer\_close(writer);
381 
382   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
383 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lightfield_encoder}{}\subsection{lightfield\+\_\+encoder}\label{example_lightfield_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2017, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Lightfield Encoder}
13 \textcolor{comment}{// ==================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a simple lightfield encoder.  It builds upon the}
16 \textcolor{comment}{// twopass\_encoder.c example. It takes an input file in YV12 format,}
17 \textcolor{comment}{// treating it as a planar lightfield instead of a video. The img\_width}
18 \textcolor{comment}{// and img\_height arguments are the dimensions of the lightfield images,}
19 \textcolor{comment}{// while the lf\_width and lf\_height arguments are the number of}
20 \textcolor{comment}{// lightfield images in each dimension. The lf\_blocksize determines the}
21 \textcolor{comment}{// number of reference images used for MCP. For example, 5 means that there}
22 \textcolor{comment}{// is a reference image for every 5x5 lightfield image block. All images}
23 \textcolor{comment}{// within a block will use the center image in that block as the reference}
24 \textcolor{comment}{// image for MCP.}
25 \textcolor{comment}{// Run "make test" to download lightfield test data: vase10x10.yuv.}
26 \textcolor{comment}{// Run lightfield encoder to encode whole lightfield:}
27 \textcolor{comment}{// examples/lightfield\_encoder 1024 1024 vase10x10.yuv vase10x10.ivf 10 10 5}
28 
29 \textcolor{comment}{// Note: In bitstream.c and encoder.c, define EXT\_TILE\_DEBUG as 1 will print}
30 \textcolor{comment}{// out the uncompressed header and the frame contexts, which can be used to}
31 \textcolor{comment}{// test the bit exactness of the headers and the frame contexts for large scale}
32 \textcolor{comment}{// tile coded frames.}
33 
34 \textcolor{preprocessor}{#include <stdio.h>}
35 \textcolor{preprocessor}{#include <stdlib.h>}
36 \textcolor{preprocessor}{#include <string.h>}
37 
38 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
39 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
40 \textcolor{preprocessor}{#include "aom\_scale/yv12config.h"}
41 \textcolor{preprocessor}{#include "av1/common/enums.h"}
42 \textcolor{preprocessor}{#include "common/tools\_common.h"}
43 \textcolor{preprocessor}{#include "common/video\_writer.h"}
44 
45 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
46 
47 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
48   fprintf(stderr,
49           \textcolor{stringliteral}{"Usage: %s <img\_width> <img\_height> <infile> <outfile> "}
50           \textcolor{stringliteral}{"<lf\_width> <lf\_height> <lf\_blocksize>\(\backslash\)n"},
51           exec\_name);
52   exit(EXIT\_FAILURE);
53 \}
54 
55 \textcolor{keyword}{static} \textcolor{keywordtype}{int} aom\_img\_size\_bytes(\hyperlink{structaom__image}{aom\_image\_t} *img) \{
56   \textcolor{keywordtype}{int} image\_size\_bytes = 0;
57   \textcolor{keywordtype}{int} plane;
58   \textcolor{keywordflow}{for} (plane = 0; plane < 3; ++plane) \{
59     \textcolor{keyword}{const} \textcolor{keywordtype}{int} w = \hyperlink{aom__image_8h_adfb2ea2e110ee42e38370868b64bf232}{aom\_img\_plane\_width}(img, plane) *
60                   ((img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) ? 2 : 1);
61     \textcolor{keyword}{const} \textcolor{keywordtype}{int} h = \hyperlink{aom__image_8h_ab87684a93e3da97bd6223d1e46876848}{aom\_img\_plane\_height}(img, plane);
62     image\_size\_bytes += w * h;
63   \}
64   \textcolor{keywordflow}{return} image\_size\_bytes;
65 \}
66 
67 \textcolor{keyword}{static} \textcolor{keywordtype}{int} get\_frame\_stats(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} 
      \hyperlink{structaom__image}{aom\_image\_t} *img,
68                            \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} duration,
69                            \hyperlink{group__encoder_gacbef92200b831adb94283f84128f83de}{aom\_enc\_frame\_flags\_t} flags,
70                            \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} *stats) \{
71   \textcolor{keywordtype}{int} got\_pkts = 0;
72   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
73   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
74   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ctx, img, pts, duration, 
      flags);
75   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ctx, \textcolor{stringliteral}{"Failed to get frame stats."});
76 
77   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ctx, &iter)) != NULL) \{
78     got\_pkts = 1;
79 
80     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda7dcdcb6c401cac64ca98b51f52de8d4b}{AOM\_CODEC\_STATS\_PKT}) \{
81       \textcolor{keyword}{const} uint8\_t *\textcolor{keyword}{const} pkt\_buf = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.
      \hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf};
82       \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} pkt\_size = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
83       stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf} = realloc(stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf}, stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz} + pkt\_size);
84       memcpy((uint8\_t *)stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf} + stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz}, pkt\_buf, pkt\_size);
85       stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz} += pkt\_size;
86     \}
87   \}
88 
89   \textcolor{keywordflow}{return} got\_pkts;
90 \}
91 
92 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img,
93                         \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} duration,
94                         \hyperlink{group__encoder_gacbef92200b831adb94283f84128f83de}{aom\_enc\_frame\_flags\_t} flags, AvxVideoWriter *writer) \{
95   \textcolor{keywordtype}{int} got\_pkts = 0;
96   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
97   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
98   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ctx, img, pts, duration, 
      flags);
99   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ctx, \textcolor{stringliteral}{"Failed to encode frame."});
100 
101   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ctx, &iter)) != NULL) \{
102     got\_pkts = 1;
103     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
104       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
105 
106       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
107                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
108                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts))
109         die\_codec(ctx, \textcolor{stringliteral}{"Failed to write compressed frame."});
110       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
111       fflush(stdout);
112     \}
113   \}
114 
115   \textcolor{keywordflow}{return} got\_pkts;
116 \}
117 
118 \textcolor{keyword}{static} \textcolor{keywordtype}{void} get\_raw\_image(\hyperlink{structaom__image}{aom\_image\_t} **frame\_to\_encode, \hyperlink{structaom__image}{aom\_image\_t} *raw,
119                           \hyperlink{structaom__image}{aom\_image\_t} *raw\_shift) \{
120   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) \{
121     \textcolor{comment}{// Need to allocate larger buffer to use hbd internal.}
122     \textcolor{keywordtype}{int} input\_shift = 0;
123     aom\_img\_upshift(raw\_shift, raw, input\_shift);
124     *frame\_to\_encode = raw\_shift;
125   \} \textcolor{keywordflow}{else} \{
126     *frame\_to\_encode = raw;
127   \}
128 \}
129 
130 \textcolor{keyword}{static} \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} pass0(\hyperlink{structaom__image}{aom\_image\_t} *raw, FILE *infile,
131                              \textcolor{keyword}{const} AvxInterface *encoder,
132                              \textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg, \textcolor{keywordtype}{int} lf\_width,
133                              \textcolor{keywordtype}{int} lf\_height, \textcolor{keywordtype}{int} lf\_blocksize, \textcolor{keywordtype}{int} flags,
134                              \hyperlink{structaom__image}{aom\_image\_t} *raw\_shift) \{
135   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
136   \textcolor{keywordtype}{int} frame\_count = 0;
137   \textcolor{keywordtype}{int} image\_size\_bytes = aom\_img\_size\_bytes(raw);
138   \textcolor{keywordtype}{int} u\_blocks, v\_blocks;
139   \textcolor{keywordtype}{int} bu, bv;
140   \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} stats = \{ NULL, 0 \};
141   \hyperlink{structaom__image}{aom\_image\_t} *frame\_to\_encode;
142 
143   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), cfg, flags))
144     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
145   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF}, 0))
146     die\_codec(&codec, \textcolor{stringliteral}{"Failed to turn off auto altref"});
147   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING}, 0))
148     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set frame parallel decoding"});
149 
150   \textcolor{comment}{// How many reference images we need to encode.}
151   u\_blocks = (lf\_width + lf\_blocksize - 1) / lf\_blocksize;
152   v\_blocks = (lf\_height + lf\_blocksize - 1) / lf\_blocksize;
153 
154   printf(\textcolor{stringliteral}{"\(\backslash\)n First pass: "});
155 
156   \textcolor{keywordflow}{for} (bv = 0; bv < v\_blocks; ++bv) \{
157     \textcolor{keywordflow}{for} (bu = 0; bu < u\_blocks; ++bu) \{
158       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_u\_min = bu * lf\_blocksize;
159       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_v\_min = bv * lf\_blocksize;
160       \textcolor{keywordtype}{int} block\_u\_end = (bu + 1) * lf\_blocksize;
161       \textcolor{keywordtype}{int} block\_v\_end = (bv + 1) * lf\_blocksize;
162       \textcolor{keywordtype}{int} u\_block\_size, v\_block\_size;
163       \textcolor{keywordtype}{int} block\_ref\_u, block\_ref\_v;
164 
165       block\_u\_end = block\_u\_end < lf\_width ? block\_u\_end : lf\_width;
166       block\_v\_end = block\_v\_end < lf\_height ? block\_v\_end : lf\_height;
167       u\_block\_size = block\_u\_end - block\_u\_min;
168       v\_block\_size = block\_v\_end - block\_v\_min;
169       block\_ref\_u = block\_u\_min + u\_block\_size / 2;
170       block\_ref\_v = block\_v\_min + v\_block\_size / 2;
171 
172       printf(\textcolor{stringliteral}{"A%d, "}, (block\_ref\_u + block\_ref\_v * lf\_width));
173       fseek(infile, (block\_ref\_u + block\_ref\_v * lf\_width) * image\_size\_bytes,
174             SEEK\_SET);
175       aom\_img\_read(raw, infile);
176       get\_raw\_image(&frame\_to\_encode, raw, raw\_shift);
177 
178       \textcolor{comment}{// Reference frames can be encoded encoded without tiles.}
179       ++frame\_count;
180       get\_frame\_stats(&codec, frame\_to\_encode, frame\_count, 1,
181                       \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
182                           \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
183                           \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | 
      \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
184                           \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} |
185                           \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF},
186                       &stats);
187     \}
188   \}
189 
190   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING}, 1))
191     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set frame parallel decoding"});
192 
193   \textcolor{keywordflow}{for} (bv = 0; bv < v\_blocks; ++bv) \{
194     \textcolor{keywordflow}{for} (bu = 0; bu < u\_blocks; ++bu) \{
195       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_u\_min = bu * lf\_blocksize;
196       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_v\_min = bv * lf\_blocksize;
197       \textcolor{keywordtype}{int} block\_u\_end = (bu + 1) * lf\_blocksize;
198       \textcolor{keywordtype}{int} block\_v\_end = (bv + 1) * lf\_blocksize;
199       \textcolor{keywordtype}{int} u, v;
200       block\_u\_end = block\_u\_end < lf\_width ? block\_u\_end : lf\_width;
201       block\_v\_end = block\_v\_end < lf\_height ? block\_v\_end : lf\_height;
202       \textcolor{keywordflow}{for} (v = block\_v\_min; v < block\_v\_end; ++v) \{
203         \textcolor{keywordflow}{for} (u = block\_u\_min; u < block\_u\_end; ++u) \{
204           printf(\textcolor{stringliteral}{"C%d, "}, (u + v * lf\_width));
205           fseek(infile, (u + v * lf\_width) * image\_size\_bytes, SEEK\_SET);
206           aom\_img\_read(raw, infile);
207           get\_raw\_image(&frame\_to\_encode, raw, raw\_shift);
208 
209           ++frame\_count;
210           get\_frame\_stats(&codec, frame\_to\_encode, frame\_count, 1,
211                           \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
212                               \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
213                               \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | 
      \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
214                               \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} |
215                               \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} | 
      \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY},
216                           &stats);
217         \}
218       \}
219     \}
220   \}
221   \textcolor{comment}{// Flush encoder.}
222   \textcolor{comment}{// No ARF, this should not be needed.}
223   \textcolor{keywordflow}{while} (get\_frame\_stats(&codec, NULL, frame\_count, 1, 0, &stats)) \{
224   \}
225 
226   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
227 
228   printf(\textcolor{stringliteral}{"\(\backslash\)nFirst pass complete. Processed %d frames.\(\backslash\)n"}, frame\_count);
229 
230   \textcolor{keywordflow}{return} stats;
231 \}
232 
233 \textcolor{keyword}{static} \textcolor{keywordtype}{void} pass1(\hyperlink{structaom__image}{aom\_image\_t} *raw, FILE *infile, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_name,
234                   \textcolor{keyword}{const} AvxInterface *encoder, \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg,
235                   \textcolor{keywordtype}{int} lf\_width, \textcolor{keywordtype}{int} lf\_height, \textcolor{keywordtype}{int} lf\_blocksize, \textcolor{keywordtype}{int} flags,
236                   \hyperlink{structaom__image}{aom\_image\_t} *raw\_shift) \{
237   AvxVideoInfo info = \{ encoder->fourcc,
238                         cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w},
239                         cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h},
240                         \{ cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num}, cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.
      \hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} \},
241                         0 \};
242   AvxVideoWriter *writer = NULL;
243   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
244   \textcolor{keywordtype}{int} frame\_count = 0;
245   \textcolor{keywordtype}{int} image\_size\_bytes = aom\_img\_size\_bytes(raw);
246   \textcolor{keywordtype}{int} bu, bv;
247   \textcolor{keywordtype}{int} u\_blocks, v\_blocks;
248   \hyperlink{structaom__image}{aom\_image\_t} *frame\_to\_encode;
249   \hyperlink{structaom__image}{aom\_image\_t} reference\_images[MAX\_EXTERNAL\_REFERENCES];
250   \textcolor{keywordtype}{int} reference\_image\_num = 0;
251   \textcolor{keywordtype}{int} i;
252 
253   writer = aom\_video\_writer\_open(outfile\_name, kContainerIVF, &info);
254   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing"}, outfile\_name);
255 
256   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), cfg, flags))
257     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
258   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF}, 0))
259     die\_codec(&codec, \textcolor{stringliteral}{"Failed to turn off auto altref"});
260   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING}, 0))
261     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set frame parallel decoding"});
262   \textcolor{comment}{// Note: The superblock is a sequence parameter and has to be the same for 1}
263   \textcolor{comment}{// sequence. In lightfield application, must choose the superblock size(either}
264   \textcolor{comment}{// 64x64 or 128x128) before the encoding starts. Otherwise, the default is}
265   \textcolor{comment}{// AOM\_SUPERBLOCK\_SIZE\_DYNAMIC, and the superblock size will be set to 64x64}
266   \textcolor{comment}{// internally.}
267   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a8854a06c62269e866d6bac0f3a2e3dc2}{AV1E\_SET\_SUPERBLOCK\_SIZE},
268                         \hyperlink{group__codec_ggac34a24f7c6c0fef7518aed0da4425f61a5abd24080a18d4f7e33217d93a73e968}{AOM\_SUPERBLOCK\_SIZE\_64X64}))
269     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set SB size"});
270 
271   u\_blocks = (lf\_width + lf\_blocksize - 1) / lf\_blocksize;
272   v\_blocks = (lf\_height + lf\_blocksize - 1) / lf\_blocksize;
273 
274   reference\_image\_num = u\_blocks * v\_blocks;
275   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420};
276   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) ref\_fmt |= \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH};
277   \textcolor{comment}{// Allocate memory with the border so that it can be used as a reference.}
278   \textcolor{keywordflow}{for} (i = 0; i < reference\_image\_num; i++) \{
279     \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_aeb211e5184687f7e10d7c5bed4dcfdcd}{aom\_img\_alloc\_with\_border}(&reference\_images[i], ref\_fmt, cfg->
      \hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w},
280                                    cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h}, 32, 8, AOM\_BORDER\_IN\_PIXELS)) \{
281       die(\textcolor{stringliteral}{"Failed to allocate image."});
282     \}
283   \}
284 
285   printf(\textcolor{stringliteral}{"\(\backslash\)n Second pass: "});
286 
287   \textcolor{comment}{// Encode reference images first.}
288   printf(\textcolor{stringliteral}{"Encoding Reference Images\(\backslash\)n"});
289   \textcolor{keywordflow}{for} (bv = 0; bv < v\_blocks; ++bv) \{
290     \textcolor{keywordflow}{for} (bu = 0; bu < u\_blocks; ++bu) \{
291       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_u\_min = bu * lf\_blocksize;
292       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_v\_min = bv * lf\_blocksize;
293       \textcolor{keywordtype}{int} block\_u\_end = (bu + 1) * lf\_blocksize;
294       \textcolor{keywordtype}{int} block\_v\_end = (bv + 1) * lf\_blocksize;
295       \textcolor{keywordtype}{int} u\_block\_size, v\_block\_size;
296       \textcolor{keywordtype}{int} block\_ref\_u, block\_ref\_v;
297 
298       block\_u\_end = block\_u\_end < lf\_width ? block\_u\_end : lf\_width;
299       block\_v\_end = block\_v\_end < lf\_height ? block\_v\_end : lf\_height;
300       u\_block\_size = block\_u\_end - block\_u\_min;
301       v\_block\_size = block\_v\_end - block\_v\_min;
302       block\_ref\_u = block\_u\_min + u\_block\_size / 2;
303       block\_ref\_v = block\_v\_min + v\_block\_size / 2;
304 
305       printf(\textcolor{stringliteral}{"A%d, "}, (block\_ref\_u + block\_ref\_v * lf\_width));
306       fseek(infile, (block\_ref\_u + block\_ref\_v * lf\_width) * image\_size\_bytes,
307             SEEK\_SET);
308       aom\_img\_read(raw, infile);
309 
310       get\_raw\_image(&frame\_to\_encode, raw, raw\_shift);
311 
312       \textcolor{comment}{// Reference frames may be encoded without tiles.}
313       ++frame\_count;
314       printf(\textcolor{stringliteral}{"Encoding reference image %d of %d\(\backslash\)n"}, bv * u\_blocks + bu,
315              u\_blocks * v\_blocks);
316       encode\_frame(&codec, frame\_to\_encode, frame\_count, 1,
317                    \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
318                        \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
319                        \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | 
      \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
320                        \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} |
321                        \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} | 
      \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY},
322                    writer);
323 
324       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659ae41763622ee33cd99e23ca8f78a3f8fa}{AV1\_COPY\_NEW\_FRAME\_IMAGE},
325                             &reference\_images[frame\_count - 1]))
326         die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy decoder reference frame"});
327     \}
328   \}
329 
330   cfg->\hyperlink{structaom__codec__enc__cfg_af4583da6c145778f822a4a61db28c40a}{large\_scale\_tile} = 1;
331   \textcolor{comment}{// Fixed q encoding for camera frames.}
332   cfg->\hyperlink{structaom__codec__enc__cfg_a3fd74d888658039d09bc4eacf163a495}{rc\_end\_usage} = \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957aff3bbd4fe870b4b946c2093e59eb14e5}{AOM\_Q};
333   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaf4a4c3c3c91dd92c960990f6e534271d}{aom\_codec\_enc\_config\_set}(&codec, cfg))
334     die\_codec(&codec, \textcolor{stringliteral}{"Failed to configure encoder"});
335 
336   \textcolor{comment}{// The fixed q value used in encoding.}
337   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af67f265bf63bf8f1268b3a14ae26606c}{AOME\_SET\_CQ\_LEVEL}, 36))
338     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set cq level"});
339   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING}, 1))
340     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set frame parallel decoding"});
341   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af341538631ffe2ac2b562c8b5336a10a}{AV1E\_SET\_SINGLE\_TILE\_DECODING}
      , 1))
342     die\_codec(&codec, \textcolor{stringliteral}{"Failed to turn on single tile decoding"});
343   \textcolor{comment}{// Set tile\_columns and tile\_rows to MAX values, which guarantees the tile}
344   \textcolor{comment}{// size of 64 x 64 pixels(i.e. 1 SB) for <= 4k resolution.}
345   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5acf4ab1ff2fa8d76a78881ad7f1a1294d}{AV1E\_SET\_TILE\_COLUMNS}, 6))
346     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set tile width"});
347   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a57f2f2a54f593b398a5e97db7982f817}{AV1E\_SET\_TILE\_ROWS}, 6))
348     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set tile height"});
349 
350   \textcolor{keywordflow}{for} (bv = 0; bv < v\_blocks; ++bv) \{
351     \textcolor{keywordflow}{for} (bu = 0; bu < u\_blocks; ++bu) \{
352       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_u\_min = bu * lf\_blocksize;
353       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_v\_min = bv * lf\_blocksize;
354       \textcolor{keywordtype}{int} block\_u\_end = (bu + 1) * lf\_blocksize;
355       \textcolor{keywordtype}{int} block\_v\_end = (bv + 1) * lf\_blocksize;
356       \textcolor{keywordtype}{int} u, v;
357       block\_u\_end = block\_u\_end < lf\_width ? block\_u\_end : lf\_width;
358       block\_v\_end = block\_v\_end < lf\_height ? block\_v\_end : lf\_height;
359       \textcolor{keywordflow}{for} (v = block\_v\_min; v < block\_v\_end; ++v) \{
360         \textcolor{keywordflow}{for} (u = block\_u\_min; u < block\_u\_end; ++u) \{
361           \hyperlink{structav1__ref__frame}{av1\_ref\_frame\_t} ref;
362           ref.\hyperlink{structav1__ref__frame_a7c6fcaba58f514985448cb2e2245345c}{idx} = 0;
363           ref.\hyperlink{structav1__ref__frame_a33749c5c20033cc5f7582d0ec1c34ff0}{use\_external\_ref} = 1;
364           ref.\hyperlink{structav1__ref__frame_a55a09db9e1acdd73e656b01fa01283b3}{img} = reference\_images[bv * u\_blocks + bu];
365           \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a51ad4467b4dc318406cceb257e2daa41}{AV1\_SET\_REFERENCE}, &ref))
366             die\_codec(&codec, \textcolor{stringliteral}{"Failed to set reference frame"});
367 
368           printf(\textcolor{stringliteral}{"C%d, "}, (u + v * lf\_width));
369           fseek(infile, (u + v * lf\_width) * image\_size\_bytes, SEEK\_SET);
370           aom\_img\_read(raw, infile);
371           get\_raw\_image(&frame\_to\_encode, raw, raw\_shift);
372 
373           ++frame\_count;
374           printf(\textcolor{stringliteral}{"Encoding image %d of %d\(\backslash\)n"},
375                  frame\_count - (u\_blocks * v\_blocks), lf\_width * lf\_height);
376           encode\_frame(&codec, frame\_to\_encode, frame\_count, 1,
377                        \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
378                            \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
379                            \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | 
      \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
380                            \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} |
381                            \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} | 
      \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY},
382                        writer);
383         \}
384       \}
385     \}
386   \}
387 
388   \textcolor{comment}{// Flush encoder.}
389   \textcolor{comment}{// No ARF, this should not be needed.}
390   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 1, 0, writer)) \{
391   \}
392 
393   \textcolor{keywordflow}{for} (i = 0; i < reference\_image\_num; i++) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&reference\_images[i]);
394 
395   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
396   aom\_video\_writer\_close(writer);
397 
398   printf(\textcolor{stringliteral}{"\(\backslash\)nSecond pass complete. Processed %d frames.\(\backslash\)n"}, frame\_count);
399 \}
400 
401 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
402   FILE *infile = NULL;
403   \textcolor{keywordtype}{int} w, h;
404   \textcolor{comment}{// The number of lightfield images in the u and v dimensions.}
405   \textcolor{keywordtype}{int} lf\_width, lf\_height;
406   \textcolor{comment}{// Defines how many images refer to the same reference image for MCP.}
407   \textcolor{comment}{// lf\_blocksize X lf\_blocksize images will all use the reference image}
408   \textcolor{comment}{// in the middle of the block of images.}
409   \textcolor{keywordtype}{int} lf\_blocksize;
410   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
411   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
412   \hyperlink{structaom__image}{aom\_image\_t} raw;
413   \hyperlink{structaom__image}{aom\_image\_t} raw\_shift;
414   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
415   \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} stats;
416   \textcolor{keywordtype}{int} flags = 0;
417 
418   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
419   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
420   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 200;  \textcolor{comment}{// kbit/s}
421   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} width\_arg = argv[1];
422   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} height\_arg = argv[2];
423   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} infile\_arg = argv[3];
424   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} outfile\_arg = argv[4];
425   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} lf\_width\_arg = argv[5];
426   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} lf\_height\_arg = argv[6];
427   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *lf\_blocksize\_arg = argv[7];
428   exec\_name = argv[0];
429 
430   \textcolor{keywordflow}{if} (argc < 8) die(\textcolor{stringliteral}{"Invalid number of arguments"});
431 
432   encoder = get\_aom\_encoder\_by\_name(\textcolor{stringliteral}{"av1"});
433   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
434 
435   w = (int)strtol(width\_arg, NULL, 0);
436   h = (int)strtol(height\_arg, NULL, 0);
437   lf\_width = (int)strtol(lf\_width\_arg, NULL, 0);
438   lf\_height = (int)strtol(lf\_height\_arg, NULL, 0);
439   lf\_blocksize = (int)strtol(lf\_blocksize\_arg, NULL, 0);
440   lf\_blocksize = lf\_blocksize < lf\_width ? lf\_blocksize : lf\_width;
441   lf\_blocksize = lf\_blocksize < lf\_height ? lf\_blocksize : lf\_height;
442 
443   \textcolor{keywordflow}{if} (w <= 0 || h <= 0 || (w % 2) != 0 || (h % 2) != 0)
444     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, w, h);
445   \textcolor{keywordflow}{if} (lf\_width <= 0 || lf\_height <= 0)
446     die(\textcolor{stringliteral}{"Invalid lf\_width and/or lf\_height: %dx%d"}, lf\_width, lf\_height);
447   \textcolor{keywordflow}{if} (lf\_blocksize <= 0) die(\textcolor{stringliteral}{"Invalid lf\_blocksize: %d"}, lf\_blocksize);
448 
449   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, w, h, 32)) \{
450     die(\textcolor{stringliteral}{"Failed to allocate image."});
451   \}
452   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) \{
453     \textcolor{comment}{// Need to allocate larger buffer to use hbd internal.}
454     \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw\_shift, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} | 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}, w, h,
455                   32);
456   \}
457 
458   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
459 
460   \textcolor{comment}{// Configuration}
461   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
462   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
463 
464   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = w;
465   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = h;
466   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = 1;
467   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = fps;
468   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
469   cfg.\hyperlink{structaom__codec__enc__cfg_a8f3763485bb1f6eea6466b2fe0da2304}{g\_error\_resilient} = 0;  \textcolor{comment}{// This is required.}
470   cfg.\hyperlink{structaom__codec__enc__cfg_a614a49318f2011cc8735d7e51b910fa4}{g\_lag\_in\_frames} = 0;    \textcolor{comment}{// need to set this since default is 19.}
471   cfg.\hyperlink{structaom__codec__enc__cfg_a3c1ea7f3ea90b9b8eab4c3f266ffacdc}{kf\_mode} = \hyperlink{group__encoder_ggac0498fc02cd368e6d9675cdb0bab5a84af81473ffe0169271763f9c9d05393405}{AOM\_KF\_DISABLED};
472   cfg.\hyperlink{structaom__codec__enc__cfg_af4583da6c145778f822a4a61db28c40a}{large\_scale\_tile} = 0;  \textcolor{comment}{// Only set it to 1 for camera frame encoding.}
473   cfg.\hyperlink{structaom__codec__enc__cfg_a76a27f44cded1516803a776a0a7e9038}{g\_bit\_depth} = \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8};
474   flags |= (cfg.\hyperlink{structaom__codec__enc__cfg_a76a27f44cded1516803a776a0a7e9038}{g\_bit\_depth} > \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8} || !CONFIG\_LOWBITDEPTH)
475                ? \hyperlink{group__encoder_gae30bbbdef18e9da3631b69c170533e92}{AOM\_CODEC\_USE\_HIGHBITDEPTH}
476                : 0;
477 
478   \textcolor{keywordflow}{if} (!(infile = fopen(infile\_arg, \textcolor{stringliteral}{"rb"})))
479     die(\textcolor{stringliteral}{"Failed to open %s for reading"}, infile\_arg);
480 
481   \textcolor{comment}{// Pass 0}
482   cfg.\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} = \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS};
483   stats = pass0(&raw, infile, encoder, &cfg, lf\_width, lf\_height, lf\_blocksize,
484                 flags, &raw\_shift);
485 
486   \textcolor{comment}{// Pass 1}
487   rewind(infile);
488   cfg.\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} = \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1a621c3f07937527618dc06e962425f6cc}{AOM\_RC\_LAST\_PASS};
489   cfg.\hyperlink{structaom__codec__enc__cfg_ad5c6f5c96ec54cabc71edb01045a1f04}{rc\_twopass\_stats\_in} = stats;
490   pass1(&raw, infile, outfile\_arg, encoder, &cfg, lf\_width, lf\_height,
491         lf\_blocksize, flags, &raw\_shift);
492   free(stats.\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf});
493 
494   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw\_shift);
495   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
496   fclose(infile);
497 
498   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
499 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lightfield_tile_list_decoder}{}\subsection{lightfield\+\_\+tile\+\_\+list\+\_\+decoder}\label{example_lightfield_tile_list_decoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2018, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Lightfield Tile List Decoder}
13 \textcolor{comment}{// ============================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is a lightfield tile list decoder example. It takes an input file that}
16 \textcolor{comment}{// contains the anchor frames that are references of the coded tiles, the camera}
17 \textcolor{comment}{// frame header, and tile list OBUs that include the tile information and the}
18 \textcolor{comment}{// compressed tile data. This input file is reconstructed from the encoded}
19 \textcolor{comment}{// lightfield ivf file, and is decodable by AV1 decoder. num\_references is}
20 \textcolor{comment}{// the number of anchor frames coded at the beginning of the light field file.}
21 \textcolor{comment}{// num\_tile\_lists is the number of tile lists need to be decoded.}
22 \textcolor{comment}{// Run lightfield tile list decoder to decode an AV1 tile list file:}
23 \textcolor{comment}{// examples/lightfield\_tile\_list\_decoder vase\_tile\_list.ivf vase\_tile\_list.yuv}
24 \textcolor{comment}{// 4 2}
25 
26 \textcolor{preprocessor}{#include <stdio.h>}
27 \textcolor{preprocessor}{#include <stdlib.h>}
28 \textcolor{preprocessor}{#include <string.h>}
29 \textcolor{preprocessor}{#include <assert.h>}
30 
31 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
32 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
33 \textcolor{preprocessor}{#include "aom\_scale/yv12config.h"}
34 \textcolor{preprocessor}{#include "av1/common/enums.h"}
35 \textcolor{preprocessor}{#include "common/tools\_common.h"}
36 \textcolor{preprocessor}{#include "common/video\_reader.h"}
37 
38 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
39 
40 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
41   fprintf(stderr,
42           \textcolor{stringliteral}{"Usage: %s <infile> <outfile> <num\_references> <num\_tile\_lists>\(\backslash\)n"},
43           exec\_name);
44   exit(EXIT\_FAILURE);
45 \}
46 
47 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
48   FILE *outfile = NULL;
49   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
50   AvxVideoReader *reader = NULL;
51   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
52   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
53   \textcolor{keywordtype}{int} num\_references;
54   \textcolor{keywordtype}{int} num\_tile\_lists;
55   \hyperlink{structaom__image}{aom\_image\_t} reference\_images[MAX\_EXTERNAL\_REFERENCES];
56   \textcolor{keywordtype}{size\_t} frame\_size = 0;
57   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame = NULL;
58   \textcolor{keywordtype}{int} i, j, n;
59 
60   exec\_name = argv[0];
61 
62   \textcolor{keywordflow}{if} (argc != 5) die(\textcolor{stringliteral}{"Invalid number of arguments."});
63 
64   reader = aom\_video\_reader\_open(argv[1]);
65   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
66 
67   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
68     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
69 
70   num\_references = (int)strtol(argv[3], NULL, 0);
71   num\_tile\_lists = (int)strtol(argv[4], NULL, 0);
72 
73   info = aom\_video\_reader\_get\_info(reader);
74 
75   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
76   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
77   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
78 
79   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
80     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
81 
82   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba1fb269c5c5913d9995b6c35d28e2a788}{AV1D\_SET\_IS\_ANNEXB}, info->is\_annexb)) \{
83     die(\textcolor{stringliteral}{"Failed to set annex b status"});
84   \}
85 
86   \textcolor{comment}{// Decode anchor frames.}
87   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 0);
88   \textcolor{keywordflow}{for} (i = 0; i < num\_references; ++i) \{
89     aom\_video\_reader\_read\_frame(reader);
90     frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
91     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
92       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
93 
94     \textcolor{keywordflow}{if} (i == 0) \{
95       \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = 0;
96       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bacd7229e5fb766670fe995739931c2ee3}{AV1D\_GET\_IMG\_FORMAT}, &ref\_fmt))
97         die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image format"});
98 
99       \textcolor{keywordtype}{int} frame\_res[2];
100       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba175c454a7adf2d3927a0e979b4a2b07b}{AV1D\_GET\_FRAME\_SIZE}, frame\_res))
101         die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image frame size"});
102 
103       \textcolor{comment}{// Allocate memory to store decoded references. Allocate memory with the}
104       \textcolor{comment}{// border so that it can be used as a reference.}
105       \textcolor{keywordflow}{for} (j = 0; j < num\_references; j++) \{
106         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} border = AOM\_BORDER\_IN\_PIXELS;
107         \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_aeb211e5184687f7e10d7c5bed4dcfdcd}{aom\_img\_alloc\_with\_border}(&reference\_images[j], ref\_fmt,
108                                        frame\_res[0], frame\_res[1], 32, 8,
109                                        border)) \{
110           die(\textcolor{stringliteral}{"Failed to allocate references."});
111         \}
112       \}
113     \}
114 
115     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659ae41763622ee33cd99e23ca8f78a3f8fa}{AV1\_COPY\_NEW\_FRAME\_IMAGE},
116                           &reference\_images[i]))
117       die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy decoded reference frame"});
118 
119     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
120     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
121     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL) \{
122       \textcolor{keywordtype}{char} name[1024];
123       snprintf(name, \textcolor{keyword}{sizeof}(name), \textcolor{stringliteral}{"ref\_%d.yuv"}, i);
124       printf(\textcolor{stringliteral}{"writing ref image to %s, %d, %d\(\backslash\)n"}, name, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h});
125       FILE *ref\_file = fopen(name, \textcolor{stringliteral}{"wb"});
126       aom\_img\_write(img, ref\_file);
127       fclose(ref\_file);
128     \}
129   \}
130 
131   \textcolor{comment}{// Decode the lightfield.}
132   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 1);
133 
134   \textcolor{comment}{// Set external references.}
135   \hyperlink{structav1__ext__ref__frame}{av1\_ext\_ref\_frame\_t} set\_ext\_ref = \{ &reference\_images[0], num\_references \};
136   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97badfbe6c1ebe4039bfef4d2cfd98755add}{AV1D\_SET\_EXT\_REF\_PTR}, &set\_ext\_ref);
137   \textcolor{comment}{// Must decode the camera frame header first.}
138   aom\_video\_reader\_read\_frame(reader);
139   frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
140   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
141     die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode the frame."});
142   \textcolor{comment}{// Decode tile lists one by one.}
143   \textcolor{keywordflow}{for} (n = 0; n < num\_tile\_lists; n++) \{
144     aom\_video\_reader\_read\_frame(reader);
145     frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
146 
147     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
148       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode the tile list."});
149     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
150     \hyperlink{structaom__image}{aom\_image\_t} *img;
151     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)))
152       fwrite(img->\hyperlink{structaom__image_a7c367f3227d5876ce9e5c198a01c2028}{img\_data}, 1, img->\hyperlink{structaom__image_af0f6c220bf000d1c488075c19d889290}{sz}, outfile);
153   \}
154 
155   \textcolor{keywordflow}{for} (i = 0; i < num\_references; i++) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&reference\_images[i]);
156   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
157   aom\_video\_reader\_close(reader);
158   fclose(outfile);
159 
160   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
161 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lightfield_decoder}{}\subsection{lightfield\+\_\+decoder}\label{example_lightfield_decoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2017, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Lightfield Decoder}
13 \textcolor{comment}{// ==================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a simple lightfield decoder. It builds upon the}
16 \textcolor{comment}{// simple\_decoder.c example.  It takes an input file containing the compressed}
17 \textcolor{comment}{// data (in ivf format), treating it as a lightfield instead of a video; and a}
18 \textcolor{comment}{// text file with a list of tiles to decode.}
19 \textcolor{comment}{// After running the lightfield encoder, run lightfield decoder to decode a}
20 \textcolor{comment}{// batch of tiles:}
21 \textcolor{comment}{// examples/lightfield\_decoder vase10x10.ivf vase\_reference.yuv 4 tile\_list.txt}
22 \textcolor{comment}{//}
23 \textcolor{comment}{// The tile\_list.txt is expected to be of the form:}
24 \textcolor{comment}{// Frame <frame\_index0>}
25 \textcolor{comment}{// <image\_index0> <anchor\_index0> <tile\_col0> <tile\_row0>}
26 \textcolor{comment}{// <image\_index1> <anchor\_index1> <tile\_col1> <tile\_row1>}
27 \textcolor{comment}{// ...}
28 \textcolor{comment}{// Frame <frame\_index1)}
29 \textcolor{comment}{// ...}
30 \textcolor{comment}{//}
31 \textcolor{comment}{// The "Frame" markers indicate a new render frame and thus a new tile list}
32 \textcolor{comment}{// will be started and the old one flushed.  The image\_indexN, anchor\_indexN,}
33 \textcolor{comment}{// tile\_colN, and tile\_rowN identify an individual tile to be decoded and}
34 \textcolor{comment}{// to use anchor\_indexN anchor image for MCP.}
35 
36 \textcolor{preprocessor}{#include <stdio.h>}
37 \textcolor{preprocessor}{#include <stdlib.h>}
38 \textcolor{preprocessor}{#include <string.h>}
39 
40 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
41 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
42 \textcolor{preprocessor}{#include "aom\_scale/yv12config.h"}
43 \textcolor{preprocessor}{#include "av1/common/enums.h"}
44 \textcolor{preprocessor}{#include "common/tools\_common.h"}
45 \textcolor{preprocessor}{#include "common/video\_reader.h"}
46 
47 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
48 
49 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
50   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile> <num\_references> <tile\_list>\(\backslash\)n"},
51           exec\_name);
52   exit(EXIT\_FAILURE);
53 \}
54 
55 \textcolor{keywordtype}{void} decode\_tile(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame,
56                  \textcolor{keywordtype}{size\_t} frame\_size, \textcolor{keywordtype}{int} tr, \textcolor{keywordtype}{int} tc, \textcolor{keywordtype}{int} ref\_idx,
57                  \hyperlink{structaom__image}{aom\_image\_t} *reference\_images, FILE *outfile) \{
58   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 1);
59   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baffdaca91296725bd16142a33f3cc6522}{AV1D\_EXT\_TILE\_DEBUG}, 1);
60   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bac056b4cf80427fd05e3c4c9fc46edb78}{AV1\_SET\_DECODE\_TILE\_ROW}, tr);
61   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, AV1\_SET\_DECODE\_TILE\_COL, tc);
62 
63   \hyperlink{structav1__ref__frame}{av1\_ref\_frame\_t} ref;
64   ref.\hyperlink{structav1__ref__frame_a7c6fcaba58f514985448cb2e2245345c}{idx} = 0;
65   ref.\hyperlink{structav1__ref__frame_a33749c5c20033cc5f7582d0ec1c34ff0}{use\_external\_ref} = 1;
66   ref.\hyperlink{structav1__ref__frame_a55a09db9e1acdd73e656b01fa01283b3}{img} = reference\_images[ref\_idx];
67   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a51ad4467b4dc318406cceb257e2daa41}{AV1\_SET\_REFERENCE}, &ref)) \{
68     die\_codec(codec, \textcolor{stringliteral}{"Failed to set reference frame."});
69   \}
70 
71   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} aom\_status = \hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(codec, frame, frame\_size, 
      NULL);
72   \textcolor{keywordflow}{if} (aom\_status) die\_codec(codec, \textcolor{stringliteral}{"Failed to decode tile."});
73 
74   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
75   \hyperlink{structaom__image}{aom\_image\_t} *img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(codec, &iter);
76   aom\_img\_write(img, outfile);
77 \}
78 
79 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
80   FILE *outfile = NULL;
81   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
82   AvxVideoReader *reader = NULL;
83   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
84   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
85   \textcolor{keywordtype}{int} num\_references;
86   \hyperlink{structaom__image}{aom\_image\_t} reference\_images[MAX\_EXTERNAL\_REFERENCES];
87   \textcolor{keywordtype}{size\_t} frame\_size = 0;
88   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame = NULL;
89   \textcolor{keywordtype}{int} i, j;
90   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *tile\_list\_file = NULL;
91   exec\_name = argv[0];
92 
93   \textcolor{keywordflow}{if} (argc != 5) die(\textcolor{stringliteral}{"Invalid number of arguments."});
94 
95   reader = aom\_video\_reader\_open(argv[1]);
96   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
97 
98   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
99     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
100 
101   num\_references = (int)strtol(argv[3], NULL, 0);
102   tile\_list\_file = argv[4];
103 
104   info = aom\_video\_reader\_get\_info(reader);
105 
106   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
107   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
108   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
109 
110   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
111     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
112 
113   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba1fb269c5c5913d9995b6c35d28e2a788}{AV1D\_SET\_IS\_ANNEXB}, info->is\_annexb)) \{
114     die(\textcolor{stringliteral}{"Failed to set annex b status"});
115   \}
116 
117   \textcolor{comment}{// Decode anchor frames.}
118   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 0);
119   \textcolor{keywordflow}{for} (i = 0; i < num\_references; ++i) \{
120     aom\_video\_reader\_read\_frame(reader);
121     frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
122     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
123       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
124 
125     \textcolor{keywordflow}{if} (i == 0) \{
126       \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = 0;
127       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bacd7229e5fb766670fe995739931c2ee3}{AV1D\_GET\_IMG\_FORMAT}, &ref\_fmt))
128         die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image format"});
129 
130       \textcolor{keywordtype}{int} frame\_res[2];
131       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba175c454a7adf2d3927a0e979b4a2b07b}{AV1D\_GET\_FRAME\_SIZE}, frame\_res))
132         die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image frame size"});
133 
134       \textcolor{comment}{// Allocate memory to store decoded references. Allocate memory with the}
135       \textcolor{comment}{// border so that it can be used as a reference.}
136       \textcolor{keywordflow}{for} (j = 0; j < num\_references; j++) \{
137         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} border = AOM\_BORDER\_IN\_PIXELS;
138         \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_aeb211e5184687f7e10d7c5bed4dcfdcd}{aom\_img\_alloc\_with\_border}(&reference\_images[j], ref\_fmt,
139                                        frame\_res[0], frame\_res[1], 32, 8,
140                                        border)) \{
141           die(\textcolor{stringliteral}{"Failed to allocate references."});
142         \}
143       \}
144     \}
145 
146     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659ae41763622ee33cd99e23ca8f78a3f8fa}{AV1\_COPY\_NEW\_FRAME\_IMAGE},
147                           &reference\_images[i]))
148       die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy decoded reference frame"});
149 
150     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
151     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
152     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL) \{
153       \textcolor{keywordtype}{char} name[1024];
154       snprintf(name, \textcolor{keyword}{sizeof}(name), \textcolor{stringliteral}{"ref\_%d.yuv"}, i);
155       printf(\textcolor{stringliteral}{"writing ref image to %s, %d, %d\(\backslash\)n"}, name, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h});
156       FILE *ref\_file = fopen(name, \textcolor{stringliteral}{"wb"});
157       aom\_img\_write(img, ref\_file);
158       fclose(ref\_file);
159     \}
160   \}
161 
162   FILE *infile = aom\_video\_reader\_get\_file(reader);
163   \textcolor{comment}{// Record the offset of the first camera image.}
164   \textcolor{keyword}{const} FileOffset camera\_frame\_pos = ftello(infile);
165 
166   printf(\textcolor{stringliteral}{"Loading compressed frames into memory.\(\backslash\)n"});
167 
168   \textcolor{comment}{// Count the frames in the lightfield.}
169   \textcolor{keywordtype}{int} num\_frames = 0;
170   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
171     ++num\_frames;
172   \}
173   \textcolor{keywordflow}{if} (num\_frames < 1) die(\textcolor{stringliteral}{"Input light field has no frames."});
174 
175   \textcolor{comment}{// Read all of the lightfield frames into memory.}
176   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **frames =
177       (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **)malloc(num\_frames * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *));
178   \textcolor{keywordtype}{size\_t} *frame\_sizes = (\textcolor{keywordtype}{size\_t} *)malloc(num\_frames * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{size\_t}));
179   \textcolor{comment}{// Seek to the first camera image.}
180   fseeko(infile, camera\_frame\_pos, SEEK\_SET);
181   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} f = 0; f < num\_frames; ++f) \{
182     aom\_video\_reader\_read\_frame(reader);
183     frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
184     frames[f] = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(frame\_size * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}));
185     memcpy(frames[f], frame, frame\_size);
186     frame\_sizes[f] = frame\_size;
187   \}
188   printf(\textcolor{stringliteral}{"Read %d frames.\(\backslash\)n"}, num\_frames);
189 
190   printf(\textcolor{stringliteral}{"Decoding tile list from file.\(\backslash\)n"});
191   \textcolor{keywordtype}{char} line[1024];
192   FILE *tile\_list\_fptr = fopen(tile\_list\_file, \textcolor{stringliteral}{"r"});
193   \textcolor{keywordflow}{while} ((fgets(line, 1024, tile\_list\_fptr)) != NULL) \{
194     \textcolor{keywordflow}{if} (line[0] == \textcolor{charliteral}{'F'}) \{
195       \textcolor{keywordflow}{continue};
196     \}
197 
198     \textcolor{keywordtype}{int} image\_idx;
199     \textcolor{keywordtype}{int} ref\_idx;
200     \textcolor{keywordtype}{int} tc;
201     \textcolor{keywordtype}{int} tr;
202 
203     sscanf(line, \textcolor{stringliteral}{"%d %d %d %d"}, &image\_idx, &ref\_idx, &tc, &tr);
204     \textcolor{keywordflow}{if} (image\_idx >= num\_frames) \{
205       die(\textcolor{stringliteral}{"Tile list image\_idx out of bounds: %d >= %d."}, image\_idx,
206           num\_frames);
207     \}
208     \textcolor{keywordflow}{if} (ref\_idx >= num\_references) \{
209       die(\textcolor{stringliteral}{"Tile list ref\_idx out of bounds: %d >= %d."}, ref\_idx,
210           num\_references);
211     \}
212     frame = frames[image\_idx];
213     frame\_size = frame\_sizes[image\_idx];
214     decode\_tile(&codec, frame, frame\_size, tr, tc, ref\_idx, reference\_images,
215                 outfile);
216   \}
217 
218   \textcolor{keywordflow}{for} (i = 0; i < num\_references; i++) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&reference\_images[i]);
219   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} f = 0; f < num\_frames; ++f) \{
220     free(frames[f]);
221   \}
222   free(frame\_sizes);
223   free(frames);
224   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
225   aom\_video\_reader\_close(reader);
226   fclose(outfile);
227 
228   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
229 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lightfield_bitstream_parsing}{}\subsection{lightfield\+\_\+bitstream\+\_\+parsing}\label{example_lightfield_bitstream_parsing}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2018, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Lightfield Bitstream Parsing}
13 \textcolor{comment}{// ============================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is a lightfield bitstream parsing example. It takes an input file}
16 \textcolor{comment}{// containing the whole compressed lightfield bitstream(ivf file) and a text}
17 \textcolor{comment}{// file containing a stream of tiles to decode and then constructs and outputs}
18 \textcolor{comment}{// a new bitstream that can be decoded by an AV1 decoder. The output bitstream}
19 \textcolor{comment}{// contains reference frames(i.e. anchor frames), camera frame header, and}
20 \textcolor{comment}{// tile list OBUs. num\_references is the number of anchor frames coded at the}
21 \textcolor{comment}{// beginning of the light field file.  After running the lightfield encoder,}
22 \textcolor{comment}{// run lightfield bitstream parsing:}
23 \textcolor{comment}{// examples/lightfield\_bitstream\_parsing vase10x10.ivf vase\_tile\_list.ivf 4}
24 \textcolor{comment}{//   tile\_list.txt}
25 \textcolor{comment}{//}
26 \textcolor{comment}{// The tile\_list.txt is expected to be of the form:}
27 \textcolor{comment}{// Frame <frame\_index0>}
28 \textcolor{comment}{// <image\_index0> <anchor\_index0> <tile\_col0> <tile\_row0>}
29 \textcolor{comment}{// <image\_index1> <anchor\_index1> <tile\_col1> <tile\_row1>}
30 \textcolor{comment}{// ...}
31 \textcolor{comment}{// Frame <frame\_index1)}
32 \textcolor{comment}{// ...}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// The "Frame" markers indicate a new render frame and thus a new tile list}
35 \textcolor{comment}{// will be started and the old one flushed.  The image\_indexN, anchor\_indexN,}
36 \textcolor{comment}{// tile\_colN, and tile\_rowN identify an individual tile to be decoded and}
37 \textcolor{comment}{// to use anchor\_indexN anchor image for MCP.}
38 
39 \textcolor{preprocessor}{#include <stdio.h>}
40 \textcolor{preprocessor}{#include <stdlib.h>}
41 \textcolor{preprocessor}{#include <string.h>}
42 
43 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
44 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
45 \textcolor{preprocessor}{#include "aom/aom\_integer.h"}
46 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
47 \textcolor{preprocessor}{#include "aom\_dsp/bitwriter\_buffer.h"}
48 \textcolor{preprocessor}{#include "common/tools\_common.h"}
49 \textcolor{preprocessor}{#include "common/video\_reader.h"}
50 \textcolor{preprocessor}{#include "common/video\_writer.h"}
51 
52 \textcolor{preprocessor}{#define MAX\_TILES 512}
53 
54 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
55 
56 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
57   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile> <num\_references> <tile\_list>\(\backslash\)n"},
58           exec\_name);
59   exit(EXIT\_FAILURE);
60 \}
61 
62 \textcolor{preprocessor}{#define ALIGN\_POWER\_OF\_TWO(value, n) \(\backslash\)}
63 \textcolor{preprocessor}{  (((value) + ((1 << (n)) - 1)) & ~((1 << (n)) - 1))}
64 
65 \textcolor{comment}{// SB size: 64x64}
66 \textcolor{keyword}{const} uint8\_t output\_frame\_width\_in\_tiles\_minus\_1 = 512 / 64 - 1;
67 \textcolor{keyword}{const} uint8\_t output\_frame\_height\_in\_tiles\_minus\_1 = 512 / 64 - 1;
68 
69 \textcolor{comment}{// Spec:}
70 \textcolor{comment}{// typedef struct \{}
71 \textcolor{comment}{//   uint8\_t anchor\_frame\_idx;}
72 \textcolor{comment}{//   uint8\_t tile\_row;}
73 \textcolor{comment}{//   uint8\_t tile\_col;}
74 \textcolor{comment}{//   uint16\_t coded\_tile\_data\_size\_minus\_1;}
75 \textcolor{comment}{//   uint8\_t *coded\_tile\_data;}
76 \textcolor{comment}{// \} TILE\_LIST\_ENTRY;}
77 
78 \textcolor{comment}{// Tile list entry provided by the application}
79 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{
80   \textcolor{keywordtype}{int} image\_idx;
81   \textcolor{keywordtype}{int} reference\_idx;
82   \textcolor{keywordtype}{int} tile\_col;
83   \textcolor{keywordtype}{int} tile\_row;
84 \} TILE\_LIST\_INFO;
85 
86 \textcolor{keyword}{static} \textcolor{keywordtype}{int} get\_image\_bps(\hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} fmt) \{
87   \textcolor{keywordflow}{switch} (fmt) \{
88     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}: \textcolor{keywordflow}{return} 12;
89     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422}: \textcolor{keywordflow}{return} 16;
90     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444}: \textcolor{keywordflow}{return} 24;
91     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}: \textcolor{keywordflow}{return} 24;
92     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca064683ed4260fc6244af6cfc9d261c22}{AOM\_IMG\_FMT\_I42216}: \textcolor{keywordflow}{return} 32;
93     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab9b93d397dedbdd6bfafec84d1f8f0f5}{AOM\_IMG\_FMT\_I44416}: \textcolor{keywordflow}{return} 48;
94     \textcolor{keywordflow}{default}: die(\textcolor{stringliteral}{"Invalid image format"});
95   \}
96   \textcolor{keywordflow}{return} 0;
97 \}
98 
99 \textcolor{keywordtype}{void} process\_tile\_list(\textcolor{keyword}{const} TILE\_LIST\_INFO *tiles, \textcolor{keywordtype}{int} num\_tiles,
100                        \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} tl\_pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **frames,
101                        \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} *frame\_sizes, \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec,
102                        \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *tl\_buf, AvxVideoWriter *writer) \{
103   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *tl = tl\_buf;
104   \textcolor{keyword}{struct }aom\_write\_bit\_buffer wb = \{ tl, 0 \};
105   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *saved\_obu\_size\_loc = NULL;
106   uint32\_t tile\_list\_obu\_header\_size = 0;
107   uint32\_t tile\_list\_obu\_size = 0;
108   \textcolor{keywordtype}{int} num\_tiles\_minus\_1 = num\_tiles - 1;
109   \textcolor{keywordtype}{int} i;
110 
111   \textcolor{comment}{// Write the tile list OBU header that is 1 byte long.}
112   aom\_wb\_write\_literal(&wb, 0, 1);  \textcolor{comment}{// forbidden bit.}
113   aom\_wb\_write\_literal(&wb, 8, 4);  \textcolor{comment}{// tile list OBU: "1000"}
114   aom\_wb\_write\_literal(&wb, 0, 1);  \textcolor{comment}{// obu\_extension = 0}
115   aom\_wb\_write\_literal(&wb, 1, 1);  \textcolor{comment}{// obu\_has\_size\_field}
116   aom\_wb\_write\_literal(&wb, 0, 1);  \textcolor{comment}{// reserved}
117   tl++;
118   tile\_list\_obu\_header\_size++;
119 
120   \textcolor{comment}{// Write the OBU size using a fixed length\_field\_size of 4 bytes.}
121   saved\_obu\_size\_loc = tl;
122   \textcolor{comment}{// aom\_wb\_write\_unsigned\_literal(&wb, data, bits) requires that bits <= 32.}
123   aom\_wb\_write\_unsigned\_literal(&wb, 0, 32);
124   tl += 4;
125   tile\_list\_obu\_header\_size += 4;
126 
127   \textcolor{comment}{// write\_tile\_list\_obu()}
128   aom\_wb\_write\_literal(&wb, output\_frame\_width\_in\_tiles\_minus\_1, 8);
129   aom\_wb\_write\_literal(&wb, output\_frame\_height\_in\_tiles\_minus\_1, 8);
130   aom\_wb\_write\_literal(&wb, num\_tiles\_minus\_1, 16);
131   tl += 4;
132   tile\_list\_obu\_size += 4;
133 
134   \textcolor{comment}{// Write each tile's data}
135   \textcolor{keywordflow}{for} (i = 0; i <= num\_tiles\_minus\_1; i++) \{
136     \hyperlink{structaom__tile__data}{aom\_tile\_data} tile\_data = \{ 0, NULL, 0 \};
137 
138     \textcolor{keywordtype}{int} image\_idx = tiles[i].image\_idx;
139     \textcolor{keywordtype}{int} ref\_idx = tiles[i].reference\_idx;
140     \textcolor{keywordtype}{int} tc = tiles[i].tile\_col;
141     \textcolor{keywordtype}{int} tr = tiles[i].tile\_row;
142 
143     \textcolor{comment}{// Reset bit writer to the right location.}
144     wb.bit\_buffer = tl;
145     wb.bit\_offset = 0;
146 
147     \textcolor{keywordtype}{size\_t} frame\_size = frame\_sizes[image\_idx];
148     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame = frames[image\_idx];
149 
150     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bac056b4cf80427fd05e3c4c9fc46edb78}{AV1\_SET\_DECODE\_TILE\_ROW}, tr);
151     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, AV1\_SET\_DECODE\_TILE\_COL, tc);
152 
153     \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} aom\_status =
154         \hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(codec, frame, frame\_size, NULL);
155     \textcolor{keywordflow}{if} (aom\_status) die\_codec(codec, \textcolor{stringliteral}{"Failed to decode tile."});
156 
157     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97badf1e96275f692bc97ddb4ce2fbdb456e}{AV1D\_GET\_TILE\_DATA}, &tile\_data);
158 
159     \textcolor{comment}{// Copy over tile info.}
160     \textcolor{comment}{//  uint8\_t anchor\_frame\_idx;}
161     \textcolor{comment}{//  uint8\_t tile\_row;}
162     \textcolor{comment}{//  uint8\_t tile\_col;}
163     \textcolor{comment}{//  uint16\_t coded\_tile\_data\_size\_minus\_1;}
164     \textcolor{comment}{//  uint8\_t *coded\_tile\_data;}
165     uint32\_t tile\_info\_bytes = 5;
166     aom\_wb\_write\_literal(&wb, ref\_idx, 8);
167     aom\_wb\_write\_literal(&wb, tr, 8);
168     aom\_wb\_write\_literal(&wb, tc, 8);
169     aom\_wb\_write\_literal(&wb, (\textcolor{keywordtype}{int})tile\_data.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size} - 1, 16);
170     tl += tile\_info\_bytes;
171 
172     memcpy(tl, (uint8\_t *)tile\_data.\hyperlink{structaom__tile__data_a05898249ddaf5ba799dd471113b0e51e}{coded\_tile\_data},
173            tile\_data.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size});
174     tl += tile\_data.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size};
175 
176     tile\_list\_obu\_size +=
177         tile\_info\_bytes + (uint32\_t)tile\_data.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size};
178   \}
179 
180   \textcolor{comment}{// Write tile list OBU size.}
181   \textcolor{keywordtype}{size\_t} bytes\_written = 0;
182   \textcolor{keywordflow}{if} (aom\_uleb\_encode\_fixed\_size(tile\_list\_obu\_size, 4, 4, saved\_obu\_size\_loc,
183                                  &bytes\_written))
184     die\_codec(codec, \textcolor{stringliteral}{"Failed to encode the tile list obu size."});
185 
186   \textcolor{comment}{// Copy the tile list.}
187   \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(
188           writer, tl\_buf, tile\_list\_obu\_header\_size + tile\_list\_obu\_size,
189           tl\_pts))
190     die\_codec(codec, \textcolor{stringliteral}{"Failed to copy compressed tile list."});
191 \}
192 
193 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
194   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
195   AvxVideoReader *reader = NULL;
196   AvxVideoWriter *writer = NULL;
197   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
198   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
199   \textcolor{keywordtype}{int} num\_references;
200   \textcolor{keywordtype}{int} i;
201   \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts;
202   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *tile\_list\_file = NULL;
203 
204   exec\_name = argv[0];
205   \textcolor{keywordflow}{if} (argc != 5) die(\textcolor{stringliteral}{"Invalid number of arguments."});
206 
207   reader = aom\_video\_reader\_open(argv[1]);
208   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
209 
210   num\_references = (int)strtol(argv[3], NULL, 0);
211   info = aom\_video\_reader\_get\_info(reader);
212 
213   \textcolor{comment}{// The writer to write out ivf file in tile list OBU, which can be decoded by}
214   \textcolor{comment}{// AV1 decoder.}
215   writer = aom\_video\_writer\_open(argv[2], kContainerIVF, info);
216   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing"}, argv[2]);
217 
218   tile\_list\_file = argv[4];
219 
220   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
221   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
222   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
223 
224   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
225     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
226 
227   \textcolor{comment}{// Decode anchor frames.}
228   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 0);
229 
230   printf(\textcolor{stringliteral}{"Reading %d reference images.\(\backslash\)n"}, num\_references);
231   \textcolor{keywordflow}{for} (i = 0; i < num\_references; ++i) \{
232     aom\_video\_reader\_read\_frame(reader);
233 
234     \textcolor{keywordtype}{size\_t} frame\_size = 0;
235     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
236         aom\_video\_reader\_get\_frame(reader, &frame\_size);
237     pts = (\hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t})aom\_video\_reader\_get\_frame\_pts(reader);
238 
239     \textcolor{comment}{// Copy references bitstream directly.}
240     \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, frame, frame\_size, pts))
241       die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy compressed anchor frame."});
242 
243     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
244       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
245   \}
246 
247   \textcolor{comment}{// Decode camera frames.}
248   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 1);
249   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baffdaca91296725bd16142a33f3cc6522}{AV1D\_EXT\_TILE\_DEBUG}, 1);
250 
251   FILE *infile = aom\_video\_reader\_get\_file(reader);
252   \textcolor{comment}{// Record the offset of the first camera image.}
253   \textcolor{keyword}{const} FileOffset camera\_frame\_pos = ftello(infile);
254 
255   printf(\textcolor{stringliteral}{"Loading compressed frames into memory.\(\backslash\)n"});
256 
257   \textcolor{comment}{// Count the frames in the lightfield.}
258   \textcolor{keywordtype}{int} num\_frames = 0;
259   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
260     ++num\_frames;
261   \}
262   \textcolor{keywordflow}{if} (num\_frames < 1) die(\textcolor{stringliteral}{"Input light field has no frames."});
263 
264   \textcolor{comment}{// Read all of the lightfield frames into memory.}
265   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **frames =
266       (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **)malloc(num\_frames * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *));
267   \textcolor{keywordtype}{size\_t} *frame\_sizes = (\textcolor{keywordtype}{size\_t} *)malloc(num\_frames * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{size\_t}));
268   \textcolor{comment}{// Seek to the first camera image.}
269   fseeko(infile, camera\_frame\_pos, SEEK\_SET);
270   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} f = 0; f < num\_frames; ++f) \{
271     aom\_video\_reader\_read\_frame(reader);
272     \textcolor{keywordtype}{size\_t} frame\_size = 0;
273     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
274         aom\_video\_reader\_get\_frame(reader, &frame\_size);
275     frames[f] = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(frame\_size * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}));
276     memcpy(frames[f], frame, frame\_size);
277     frame\_sizes[f] = frame\_size;
278   \}
279   printf(\textcolor{stringliteral}{"Read %d frames.\(\backslash\)n"}, num\_frames);
280 
281   \textcolor{comment}{// Copy first camera frame for getting camera frame header. This is done}
282   \textcolor{comment}{// only once.}
283   \{
284     \textcolor{keywordtype}{size\_t} frame\_size = frame\_sizes[0];
285     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame = frames[0];
286     pts = num\_references;
287     \hyperlink{structaom__tile__data}{aom\_tile\_data} frame\_header\_info = \{ 0, NULL, 0 \};
288 
289     \textcolor{comment}{// Need to decode frame header to get camera frame header info. So, here}
290     \textcolor{comment}{// decoding 1 tile is enough.}
291     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bac056b4cf80427fd05e3c4c9fc46edb78}{AV1\_SET\_DECODE\_TILE\_ROW}, 0);
292     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, AV1\_SET\_DECODE\_TILE\_COL, 0);
293 
294     \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} aom\_status =
295         \hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL);
296     \textcolor{keywordflow}{if} (aom\_status) die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode tile."});
297 
298     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baed16ed4514ea1bd2847e607ca880b246}{AV1D\_GET\_FRAME\_HEADER\_INFO}, &
      frame\_header\_info);
299 
300     \textcolor{keywordtype}{size\_t} obu\_size\_offset =
301         (uint8\_t *)frame\_header\_info.\hyperlink{structaom__tile__data_a05898249ddaf5ba799dd471113b0e51e}{coded\_tile\_data} - frame;
302     \textcolor{keywordtype}{size\_t} length\_field\_size = frame\_header\_info.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size};
303     \textcolor{comment}{// Remove ext-tile tile info.}
304     uint32\_t frame\_header\_size = (uint32\_t)frame\_header\_info.\hyperlink{structaom__tile__data_a936851e515bcea0af38d2d091f5adf65}{extra\_size} - 1;
305     \textcolor{keywordtype}{size\_t} bytes\_to\_copy =
306         obu\_size\_offset + length\_field\_size + frame\_header\_size;
307 
308     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame\_hdr\_buf = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(bytes\_to\_copy);
309     \textcolor{keywordflow}{if} (frame\_hdr\_buf == NULL)
310       die\_codec(&codec, \textcolor{stringliteral}{"Failed to allocate frame header buffer."});
311 
312     memcpy(frame\_hdr\_buf, frame, bytes\_to\_copy);
313 
314     \textcolor{comment}{// Update frame header OBU size.}
315     \textcolor{keywordtype}{size\_t} bytes\_written = 0;
316     \textcolor{keywordflow}{if} (aom\_uleb\_encode\_fixed\_size(
317             frame\_header\_size, length\_field\_size, length\_field\_size,
318             frame\_hdr\_buf + obu\_size\_offset, &bytes\_written))
319       die\_codec(&codec, \textcolor{stringliteral}{"Failed to encode the tile list obu size."});
320 
321     \textcolor{comment}{// Copy camera frame header bitstream.}
322     \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, frame\_hdr\_buf, bytes\_to\_copy,
323                                       pts))
324       die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy compressed camera frame header."});
325     free(frame\_hdr\_buf);
326   \}
327 
328   \textcolor{comment}{// Read out the image format.}
329   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = 0;
330   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bacd7229e5fb766670fe995739931c2ee3}{AV1D\_GET\_IMG\_FORMAT}, &ref\_fmt))
331     die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image format"});
332   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bps = get\_image\_bps(ref\_fmt);
333   \textcolor{keywordflow}{if} (!bps) die\_codec(&codec, \textcolor{stringliteral}{"Invalid image format."});
334   \textcolor{comment}{// read out the tile size.}
335   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_size = 0;
336   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba4d9799d9e520785870b8d1f73a19c3c4}{AV1D\_GET\_TILE\_SIZE}, &tile\_size))
337     die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the tile size"});
338   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_width = tile\_size >> 16;
339   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_height = tile\_size & 65535;
340   \textcolor{comment}{// Allocate a buffer to store tile list bitstream.}
341   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} data\_sz = MAX\_TILES * ALIGN\_POWER\_OF\_TWO(tile\_width, 5) *
342                          ALIGN\_POWER\_OF\_TWO(tile\_height, 5) * bps / 8;
343 
344   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *tl\_buf = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(data\_sz);
345   \textcolor{keywordflow}{if} (tl\_buf == NULL) die\_codec(&codec, \textcolor{stringliteral}{"Failed to allocate tile list buffer."});
346 
347   \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} tl\_pts = num\_references;
348 
349   printf(\textcolor{stringliteral}{"Reading tile list from file.\(\backslash\)n"});
350   \textcolor{keywordtype}{char} line[1024];
351   FILE *tile\_list\_fptr = fopen(tile\_list\_file, \textcolor{stringliteral}{"r"});
352   \textcolor{keywordtype}{int} num\_tiles = 0;
353   TILE\_LIST\_INFO tiles[MAX\_TILES];
354   \textcolor{keywordflow}{while} ((fgets(line, 1024, tile\_list\_fptr)) != NULL) \{
355     \textcolor{keywordflow}{if} (line[0] == \textcolor{charliteral}{'F'} || num\_tiles >= MAX\_TILES) \{
356       \textcolor{comment}{// Flush existing tile list and start another, either because we hit a}
357       \textcolor{comment}{// new render frame or because we've hit our max number of tiles per list.}
358       \textcolor{keywordflow}{if} (num\_tiles > 0) \{
359         process\_tile\_list(tiles, num\_tiles, tl\_pts, frames, frame\_sizes, &codec,
360                           tl\_buf, writer);
361         ++tl\_pts;
362       \}
363       num\_tiles = 0;
364     \}
365     \textcolor{keywordflow}{if} (line[0] == \textcolor{charliteral}{'F'}) \{
366       \textcolor{keywordflow}{continue};
367     \}
368     \textcolor{keywordflow}{if} (sscanf(line, \textcolor{stringliteral}{"%d %d %d %d"}, &tiles[num\_tiles].image\_idx,
369                &tiles[num\_tiles].reference\_idx, &tiles[num\_tiles].tile\_col,
370                &tiles[num\_tiles].tile\_row) == 4) \{
371       \textcolor{keywordflow}{if} (tiles[num\_tiles].image\_idx >= num\_frames) \{
372         die(\textcolor{stringliteral}{"Tile list image\_idx out of bounds: %d >= %d."},
373             tiles[num\_tiles].image\_idx, num\_frames);
374       \}
375       \textcolor{keywordflow}{if} (tiles[num\_tiles].reference\_idx >= num\_references) \{
376         die(\textcolor{stringliteral}{"Tile list reference\_idx out of bounds: %d >= %d."},
377             tiles[num\_tiles].reference\_idx, num\_references);
378       \}
379       ++num\_tiles;
380     \}
381   \}
382   \textcolor{keywordflow}{if} (num\_tiles > 0) \{
383     \textcolor{comment}{// Flush out the last tile list.}
384     process\_tile\_list(tiles, num\_tiles, tl\_pts, frames, frame\_sizes, &codec,
385                       tl\_buf, writer);
386     ++tl\_pts;
387   \}
388 
389   \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_tile\_lists = (int)(tl\_pts - pts);
390   printf(\textcolor{stringliteral}{"Finished processing tile lists.  Num tile lists: %d.\(\backslash\)n"},
391          num\_tile\_lists);
392   free(tl\_buf);
393   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} f = 0; f < num\_frames; ++f) \{
394     free(frames[f]);
395   \}
396   free(frame\_sizes);
397   free(frames);
398   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
399   aom\_video\_writer\_close(writer);
400   aom\_video\_reader\_close(reader);
401 
402   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
403 \}
\end{DoxyCodeInclude}
 \hypertarget{example_aomdec}{}\subsection{aomdec}\label{example_aomdec}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{preprocessor}{#include <assert.h>}
13 \textcolor{preprocessor}{#include <stdio.h>}
14 \textcolor{preprocessor}{#include <stdlib.h>}
15 \textcolor{preprocessor}{#include <stdarg.h>}
16 \textcolor{preprocessor}{#include <string.h>}
17 \textcolor{preprocessor}{#include <limits.h>}
18 
19 \textcolor{preprocessor}{#include "config/aom\_config.h"}
20 
21 \textcolor{preprocessor}{#if CONFIG\_OS\_SUPPORT}
22 \textcolor{preprocessor}{#if HAVE\_UNISTD\_H}
23 \textcolor{preprocessor}{#include <unistd.h>}  \textcolor{comment}{// NOLINT}
24 \textcolor{preprocessor}{#elif !defined(STDOUT\_FILENO)}
25 \textcolor{preprocessor}{#define STDOUT\_FILENO 1}
26 \textcolor{preprocessor}{#endif}
27 \textcolor{preprocessor}{#endif}
28 
29 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
30 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
31 \textcolor{preprocessor}{#include "aom\_ports/aom\_timer.h"}
32 \textcolor{preprocessor}{#include "aom\_ports/mem\_ops.h"}
33 \textcolor{preprocessor}{#include "common/args.h"}
34 \textcolor{preprocessor}{#include "common/ivfdec.h"}
35 \textcolor{preprocessor}{#include "common/md5\_utils.h"}
36 \textcolor{preprocessor}{#include "common/obudec.h"}
37 \textcolor{preprocessor}{#include "common/tools\_common.h"}
38 
39 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
40 \textcolor{preprocessor}{#include "common/webmdec.h"}
41 \textcolor{preprocessor}{#endif}
42 
43 \textcolor{preprocessor}{#include "common/rawenc.h"}
44 \textcolor{preprocessor}{#include "common/y4menc.h"}
45 
46 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
47 \textcolor{preprocessor}{#include "third\_party/libyuv/include/libyuv/scale.h"}
48 \textcolor{preprocessor}{#endif}
49 
50 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
51 
52 \textcolor{keyword}{struct }AvxDecInputContext \{
53   \textcolor{keyword}{struct }AvxInputContext *aom\_input\_ctx;
54   \textcolor{keyword}{struct }ObuDecInputContext *obu\_ctx;
55   \textcolor{keyword}{struct }WebmInputContext *webm\_ctx;
56 \};
57 
58 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t help =
59     ARG\_DEF(NULL, \textcolor{stringliteral}{"help"}, 0, \textcolor{stringliteral}{"Show usage options and exit"});
60 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t looparg =
61     ARG\_DEF(NULL, \textcolor{stringliteral}{"loops"}, 1, \textcolor{stringliteral}{"Number of times to decode the file"});
62 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t codecarg = ARG\_DEF(NULL, \textcolor{stringliteral}{"codec"}, 1, \textcolor{stringliteral}{"Codec to use"});
63 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_yv12 =
64     ARG\_DEF(NULL, \textcolor{stringliteral}{"yv12"}, 0, \textcolor{stringliteral}{"Output raw YV12 frames"});
65 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i420 =
66     ARG\_DEF(NULL, \textcolor{stringliteral}{"i420"}, 0, \textcolor{stringliteral}{"Output raw I420 frames"});
67 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t flipuvarg =
68     ARG\_DEF(NULL, \textcolor{stringliteral}{"flipuv"}, 0, \textcolor{stringliteral}{"Flip the chroma planes in the output"});
69 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t rawvideo =
70     ARG\_DEF(NULL, \textcolor{stringliteral}{"rawvideo"}, 0, \textcolor{stringliteral}{"Output raw YUV frames"});
71 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t noblitarg =
72     ARG\_DEF(NULL, \textcolor{stringliteral}{"noblit"}, 0, \textcolor{stringliteral}{"Don't process the decoded frames"});
73 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t progressarg =
74     ARG\_DEF(NULL, \textcolor{stringliteral}{"progress"}, 0, \textcolor{stringliteral}{"Show progress after each frame decodes"});
75 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t limitarg =
76     ARG\_DEF(NULL, \textcolor{stringliteral}{"limit"}, 1, \textcolor{stringliteral}{"Stop decoding after n frames"});
77 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t skiparg =
78     ARG\_DEF(NULL, \textcolor{stringliteral}{"skip"}, 1, \textcolor{stringliteral}{"Skip the first n input frames"});
79 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t postprocarg =
80     ARG\_DEF(NULL, \textcolor{stringliteral}{"postproc"}, 0, \textcolor{stringliteral}{"Postprocess decoded frames"});
81 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t summaryarg =
82     ARG\_DEF(NULL, \textcolor{stringliteral}{"summary"}, 0, \textcolor{stringliteral}{"Show timing summary"});
83 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outputfile =
84     ARG\_DEF(\textcolor{stringliteral}{"o"}, \textcolor{stringliteral}{"output"}, 1, \textcolor{stringliteral}{"Output file name pattern (see below)"});
85 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t threadsarg =
86     ARG\_DEF(\textcolor{stringliteral}{"t"}, \textcolor{stringliteral}{"threads"}, 1, \textcolor{stringliteral}{"Max threads to use"});
87 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t verbosearg =
88     ARG\_DEF(\textcolor{stringliteral}{"v"}, \textcolor{stringliteral}{"verbose"}, 0, \textcolor{stringliteral}{"Show version string"});
89 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t scalearg =
90     ARG\_DEF(\textcolor{stringliteral}{"S"}, \textcolor{stringliteral}{"scale"}, 0, \textcolor{stringliteral}{"Scale output frames uniformly"});
91 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t continuearg =
92     ARG\_DEF(\textcolor{stringliteral}{"k"}, \textcolor{stringliteral}{"keep-going"}, 0, \textcolor{stringliteral}{"(debug) Continue decoding after error"});
93 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t fb\_arg =
94     ARG\_DEF(NULL, \textcolor{stringliteral}{"frame-buffers"}, 1, \textcolor{stringliteral}{"Number of frame buffers to use"});
95 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t md5arg =
96     ARG\_DEF(NULL, \textcolor{stringliteral}{"md5"}, 0, \textcolor{stringliteral}{"Compute the MD5 sum of the decoded frame"});
97 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t framestatsarg =
98     ARG\_DEF(NULL, \textcolor{stringliteral}{"framestats"}, 1, \textcolor{stringliteral}{"Output per-frame stats (.csv format)"});
99 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outbitdeptharg =
100     ARG\_DEF(NULL, \textcolor{stringliteral}{"output-bit-depth"}, 1, \textcolor{stringliteral}{"Output bit-depth for decoded frames"});
101 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t isannexb =
102     ARG\_DEF(NULL, \textcolor{stringliteral}{"annexb"}, 0, \textcolor{stringliteral}{"Bitstream is in Annex-B format"});
103 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t oppointarg = ARG\_DEF(
104     NULL, \textcolor{stringliteral}{"oppoint"}, 1, \textcolor{stringliteral}{"Select an operating point of a scalable bitstream"});
105 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outallarg = ARG\_DEF(
106     NULL, \textcolor{stringliteral}{"all-layers"}, 0, \textcolor{stringliteral}{"Output all decoded frames of a scalable bitstream"});
107 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t skipfilmgrain =
108     ARG\_DEF(NULL, \textcolor{stringliteral}{"skip-film-grain"}, 0, \textcolor{stringliteral}{"Skip film grain application"});
109 
110 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *all\_args[] = \{
111   &help,           &codecarg,   &use\_yv12,      &use\_i420,
112   &flipuvarg,      &rawvideo,   &noblitarg,     &progressarg,
113   &limitarg,       &skiparg,    &postprocarg,   &summaryarg,
114   &outputfile,     &threadsarg, &verbosearg,    &scalearg,
115   &fb\_arg,         &md5arg,     &framestatsarg, &continuearg,
116   &outbitdeptharg, &isannexb,   &oppointarg,    &outallarg,
117   &skipfilmgrain,  NULL
118 \};
119 
120 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
121 \textcolor{keyword}{static} INLINE \textcolor{keywordtype}{int} libyuv\_scale(\hyperlink{structaom__image}{aom\_image\_t} *src, \hyperlink{structaom__image}{aom\_image\_t} *dst,
122                                FilterModeEnum mode) \{
123   \textcolor{keywordflow}{if} (src->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}) \{
124     assert(dst->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016});
125     \textcolor{keywordflow}{return} I420Scale\_16(
126         (uint16\_t *)src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_Y] / 2,
127         (uint16\_t *)src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U] / 2,
128         (uint16\_t *)src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V] / 2,
129         src->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, src->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, (uint16\_t *)dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_Y],
130         dst->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_Y] / 2, (uint16\_t *)dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U],
131         dst->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U] / 2, (uint16\_t *)dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V],
132         dst->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V] / 2, dst->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, dst->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, mode);
133   \}
134   assert(src->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420});
135   assert(dst->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420});
136   \textcolor{keywordflow}{return} I420Scale(src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[
      \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
137                    src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U],
138                    src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V], src->
      \hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w},
139                    src->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], dst->
      \hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
140                    dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U], dst->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U],
141                    dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V], dst->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V], dst->
      \hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w},
142                    dst->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, mode);
143 \}
144 \textcolor{preprocessor}{#endif}
145 
146 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_help(FILE *fout, \textcolor{keywordtype}{int} shorthelp) \{
147   fprintf(fout, \textcolor{stringliteral}{"Usage: %s <options> filename\(\backslash\)n\(\backslash\)n"}, exec\_name);
148 
149   \textcolor{keywordflow}{if} (shorthelp) \{
150     fprintf(fout, \textcolor{stringliteral}{"Use --help to see the full list of options.\(\backslash\)n"});
151     \textcolor{keywordflow}{return};
152   \}
153 
154   fprintf(fout, \textcolor{stringliteral}{"Options:\(\backslash\)n"});
155   arg\_show\_usage(fout, all\_args);
156   fprintf(fout,
157           \textcolor{stringliteral}{"\(\backslash\)nOutput File Patterns:\(\backslash\)n\(\backslash\)n"}
158           \textcolor{stringliteral}{"  The -o argument specifies the name of the file(s) to "}
159           \textcolor{stringliteral}{"write to. If the\(\backslash\)n  argument does not include any escape "}
160           \textcolor{stringliteral}{"characters, the output will be\(\backslash\)n  written to a single file. "}
161           \textcolor{stringliteral}{"Otherwise, the filename will be calculated by\(\backslash\)n  expanding "}
162           \textcolor{stringliteral}{"the following escape characters:\(\backslash\)n"});
163   fprintf(fout,
164           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t%%w   - Frame width"}
165           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t%%h   - Frame height"}
166           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t%%<n> - Frame number, zero padded to <n> places (1..9)"}
167           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n  Pattern arguments are only supported in conjunction "}
168           \textcolor{stringliteral}{"with the --yv12 and\(\backslash\)n  --i420 options. If the -o option is "}
169           \textcolor{stringliteral}{"not specified, the output will be\(\backslash\)n  directed to stdout.\(\backslash\)n"});
170   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nIncluded decoders:\(\backslash\)n\(\backslash\)n"});
171 
172   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < get\_aom\_decoder\_count(); ++i) \{
173     \textcolor{keyword}{const} AvxInterface *\textcolor{keyword}{const} decoder = get\_aom\_decoder\_by\_index(i);
174     fprintf(fout, \textcolor{stringliteral}{"    %-6s - %s\(\backslash\)n"}, decoder->name,
175             \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
176   \}
177 \}
178 
179 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
180   show\_help(stderr, 1);
181   exit(EXIT\_FAILURE);
182 \}
183 
184 \textcolor{keyword}{static} \textcolor{keywordtype}{int} raw\_read\_frame(FILE *infile, uint8\_t **buffer, \textcolor{keywordtype}{size\_t} *bytes\_read,
185                           \textcolor{keywordtype}{size\_t} *buffer\_size) \{
186   \textcolor{keywordtype}{char} raw\_hdr[RAW\_FRAME\_HDR\_SZ];
187   \textcolor{keywordtype}{size\_t} frame\_size = 0;
188 
189   \textcolor{keywordflow}{if} (fread(raw\_hdr, RAW\_FRAME\_HDR\_SZ, 1, infile) != 1) \{
190     \textcolor{keywordflow}{if} (!feof(infile)) warn(\textcolor{stringliteral}{"Failed to read RAW frame size\(\backslash\)n"});
191   \} \textcolor{keywordflow}{else} \{
192     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} kCorruptFrameThreshold = 256 * 1024 * 1024;
193     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} kFrameTooSmallThreshold = 256 * 1024;
194     frame\_size = mem\_get\_le32(raw\_hdr);
195 
196     \textcolor{keywordflow}{if} (frame\_size > kCorruptFrameThreshold) \{
197       warn(\textcolor{stringliteral}{"Read invalid frame size (%u)\(\backslash\)n"}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})frame\_size);
198       frame\_size = 0;
199     \}
200 
201     \textcolor{keywordflow}{if} (frame\_size < kFrameTooSmallThreshold) \{
202       warn(\textcolor{stringliteral}{"Warning: Read invalid frame size (%u) - not a raw file?\(\backslash\)n"},
203            (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})frame\_size);
204     \}
205 
206     \textcolor{keywordflow}{if} (frame\_size > *buffer\_size) \{
207       uint8\_t *new\_buf = realloc(*buffer, 2 * frame\_size);
208       \textcolor{keywordflow}{if} (new\_buf) \{
209         *buffer = new\_buf;
210         *buffer\_size = 2 * frame\_size;
211       \} \textcolor{keywordflow}{else} \{
212         warn(\textcolor{stringliteral}{"Failed to allocate compressed data buffer\(\backslash\)n"});
213         frame\_size = 0;
214       \}
215     \}
216   \}
217 
218   \textcolor{keywordflow}{if} (!feof(infile)) \{
219     \textcolor{keywordflow}{if} (fread(*buffer, 1, frame\_size, infile) != frame\_size) \{
220       warn(\textcolor{stringliteral}{"Failed to read full frame\(\backslash\)n"});
221       \textcolor{keywordflow}{return} 1;
222     \}
223     *bytes\_read = frame\_size;
224   \}
225 
226   \textcolor{keywordflow}{return} 0;
227 \}
228 
229 \textcolor{keyword}{static} \textcolor{keywordtype}{int} read\_frame(\textcolor{keyword}{struct} AvxDecInputContext *input, uint8\_t **buf,
230                       \textcolor{keywordtype}{size\_t} *bytes\_in\_buffer, \textcolor{keywordtype}{size\_t} *buffer\_size) \{
231   \textcolor{keywordflow}{switch} (input->aom\_input\_ctx->file\_type) \{
232 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
233     \textcolor{keywordflow}{case} FILE\_TYPE\_WEBM:
234       \textcolor{keywordflow}{return} webm\_read\_frame(input->webm\_ctx, buf, bytes\_in\_buffer,
235                              buffer\_size);
236 \textcolor{preprocessor}{#endif}
237     \textcolor{keywordflow}{case} FILE\_TYPE\_RAW:
238       \textcolor{keywordflow}{return} raw\_read\_frame(input->aom\_input\_ctx->file, buf, bytes\_in\_buffer,
239                             buffer\_size);
240     \textcolor{keywordflow}{case} FILE\_TYPE\_IVF:
241       \textcolor{keywordflow}{return} ivf\_read\_frame(input->aom\_input\_ctx->file, buf, bytes\_in\_buffer,
242                             buffer\_size, NULL);
243     \textcolor{keywordflow}{case} FILE\_TYPE\_OBU:
244       \textcolor{keywordflow}{return} obudec\_read\_temporal\_unit(input->obu\_ctx, buf, bytes\_in\_buffer,
245                                        buffer\_size);
246     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} 1;
247   \}
248 \}
249 
250 \textcolor{keyword}{static} \textcolor{keywordtype}{int} file\_is\_raw(\textcolor{keyword}{struct} AvxInputContext *input) \{
251   uint8\_t buf[32];
252   \textcolor{keywordtype}{int} is\_raw = 0;
253   \hyperlink{structaom__codec__stream__info}{aom\_codec\_stream\_info\_t} si;
254   memset(&si, 0, \textcolor{keyword}{sizeof}(si));
255 
256   \textcolor{keywordflow}{if} (fread(buf, 1, 32, input->file) == 32) \{
257     \textcolor{keywordtype}{int} i;
258 
259     \textcolor{keywordflow}{if} (mem\_get\_le32(buf) < 256 * 1024 * 1024) \{
260       \textcolor{keywordflow}{for} (i = 0; i < get\_aom\_decoder\_count(); ++i) \{
261         \textcolor{keyword}{const} AvxInterface *\textcolor{keyword}{const} decoder = get\_aom\_decoder\_by\_index(i);
262         \textcolor{keywordflow}{if} (!\hyperlink{group__decoder_ga2544bac9fdc439f0effd6b1b14df54be}{aom\_codec\_peek\_stream\_info}(decoder->codec\_interface(), buf + 4,
263                                         32 - 4, &si)) \{
264           is\_raw = 1;
265           input->fourcc = decoder->fourcc;
266           input->width = si.\hyperlink{structaom__codec__stream__info_add84a2752fefd706f893fbc41ba6b9f2}{w};
267           input->height = si.\hyperlink{structaom__codec__stream__info_a2f1c33e3b980b274176545340b474e34}{h};
268           input->framerate.numerator = 30;
269           input->framerate.denominator = 1;
270           \textcolor{keywordflow}{break};
271         \}
272       \}
273     \}
274   \}
275 
276   rewind(input->file);
277   \textcolor{keywordflow}{return} is\_raw;
278 \}
279 
280 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_progress(\textcolor{keywordtype}{int} frame\_in, \textcolor{keywordtype}{int} frame\_out, uint64\_t dx\_time) \{
281   fprintf(stderr,
282           \textcolor{stringliteral}{"%d decoded frames/%d showed frames in %"} PRId64 \textcolor{stringliteral}{" us (%.2f fps)\(\backslash\)r"},
283           frame\_in, frame\_out, dx\_time,
284           (\textcolor{keywordtype}{double})frame\_out * 1000000.0 / (\textcolor{keywordtype}{double})dx\_time);
285 \}
286 
287 \textcolor{keyword}{struct }ExternalFrameBuffer \{
288   uint8\_t *data;
289   \textcolor{keywordtype}{size\_t} size;
290   \textcolor{keywordtype}{int} in\_use;
291 \};
292 
293 \textcolor{keyword}{struct }ExternalFrameBufferList \{
294   \textcolor{keywordtype}{int} num\_external\_frame\_buffers;
295   \textcolor{keyword}{struct }ExternalFrameBuffer *ext\_fb;
296 \};
297 
298 \textcolor{comment}{// Callback used by libaom to request an external frame buffer. |cb\_priv|}
299 \textcolor{comment}{// Application private data passed into the set function. |min\_size| is the}
300 \textcolor{comment}{// minimum size in bytes needed to decode the next frame. |fb| pointer to the}
301 \textcolor{comment}{// frame buffer.}
302 \textcolor{keyword}{static} \textcolor{keywordtype}{int} get\_av1\_frame\_buffer(\textcolor{keywordtype}{void} *cb\_priv, \textcolor{keywordtype}{size\_t} min\_size,
303                                 \hyperlink{structaom__codec__frame__buffer}{aom\_codec\_frame\_buffer\_t} *fb) \{
304   \textcolor{keywordtype}{int} i;
305   \textcolor{keyword}{struct }ExternalFrameBufferList *\textcolor{keyword}{const} ext\_fb\_list =
306       (\textcolor{keyword}{struct }ExternalFrameBufferList *)cb\_priv;
307   \textcolor{keywordflow}{if} (ext\_fb\_list == NULL) \textcolor{keywordflow}{return} -1;
308 
309   \textcolor{comment}{// Find a free frame buffer.}
310   \textcolor{keywordflow}{for} (i = 0; i < ext\_fb\_list->num\_external\_frame\_buffers; ++i) \{
311     \textcolor{keywordflow}{if} (!ext\_fb\_list->ext\_fb[i].in\_use) \textcolor{keywordflow}{break};
312   \}
313 
314   \textcolor{keywordflow}{if} (i == ext\_fb\_list->num\_external\_frame\_buffers) \textcolor{keywordflow}{return} -1;
315 
316   \textcolor{keywordflow}{if} (ext\_fb\_list->ext\_fb[i].size < min\_size) \{
317     free(ext\_fb\_list->ext\_fb[i].data);
318     ext\_fb\_list->ext\_fb[i].data = (uint8\_t *)calloc(min\_size, \textcolor{keyword}{sizeof}(uint8\_t));
319     \textcolor{keywordflow}{if} (!ext\_fb\_list->ext\_fb[i].data) \textcolor{keywordflow}{return} -1;
320 
321     ext\_fb\_list->ext\_fb[i].size = min\_size;
322   \}
323 
324   fb->\hyperlink{structaom__codec__frame__buffer_a4b73719e1d6756516de8cbceb68822d2}{data} = ext\_fb\_list->ext\_fb[i].data;
325   fb->\hyperlink{structaom__codec__frame__buffer_a6fc24049c4e1706ce3a462825009f3d4}{size} = ext\_fb\_list->ext\_fb[i].size;
326   ext\_fb\_list->ext\_fb[i].in\_use = 1;
327 
328   \textcolor{comment}{// Set the frame buffer's private data to point at the external frame buffer.}
329   fb->\hyperlink{structaom__codec__frame__buffer_aa689f8e27421eebc9e1c70b607e415ef}{priv} = &ext\_fb\_list->ext\_fb[i];
330   \textcolor{keywordflow}{return} 0;
331 \}
332 
333 \textcolor{comment}{// Callback used by libaom when there are no references to the frame buffer.}
334 \textcolor{comment}{// |cb\_priv| user private data passed into the set function. |fb| pointer}
335 \textcolor{comment}{// to the frame buffer.}
336 \textcolor{keyword}{static} \textcolor{keywordtype}{int} release\_av1\_frame\_buffer(\textcolor{keywordtype}{void} *cb\_priv,
337                                     \hyperlink{structaom__codec__frame__buffer}{aom\_codec\_frame\_buffer\_t} *fb) \{
338   \textcolor{keyword}{struct }ExternalFrameBuffer *\textcolor{keyword}{const} ext\_fb =
339       (\textcolor{keyword}{struct }ExternalFrameBuffer *)fb->\hyperlink{structaom__codec__frame__buffer_aa689f8e27421eebc9e1c70b607e415ef}{priv};
340   (\textcolor{keywordtype}{void})cb\_priv;
341   ext\_fb->in\_use = 0;
342   \textcolor{keywordflow}{return} 0;
343 \}
344 
345 \textcolor{keyword}{static} \textcolor{keywordtype}{void} generate\_filename(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *pattern, \textcolor{keywordtype}{char} *out, \textcolor{keywordtype}{size\_t} q\_len,
346                               \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} d\_w, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} d\_h,
347                               \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_in) \{
348   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *p = pattern;
349   \textcolor{keywordtype}{char} *q = out;
350 
351   \textcolor{keywordflow}{do} \{
352     \textcolor{keywordtype}{char} *next\_pat = strchr(p, \textcolor{charliteral}{'%'});
353 
354     \textcolor{keywordflow}{if} (p == next\_pat) \{
355       \textcolor{keywordtype}{size\_t} pat\_len;
356 
357       \textcolor{comment}{/* parse the pattern */}
358       q[q\_len - 1] = \textcolor{charliteral}{'\(\backslash\)0'};
359       \textcolor{keywordflow}{switch} (p[1]) \{
360         \textcolor{keywordflow}{case} \textcolor{charliteral}{'w'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%d"}, d\_w); \textcolor{keywordflow}{break};
361         \textcolor{keywordflow}{case} \textcolor{charliteral}{'h'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%d"}, d\_h); \textcolor{keywordflow}{break};
362         \textcolor{keywordflow}{case} \textcolor{charliteral}{'1'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%d"}, frame\_in); \textcolor{keywordflow}{break};
363         \textcolor{keywordflow}{case} \textcolor{charliteral}{'2'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%02d"}, frame\_in); \textcolor{keywordflow}{break};
364         \textcolor{keywordflow}{case} \textcolor{charliteral}{'3'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%03d"}, frame\_in); \textcolor{keywordflow}{break};
365         \textcolor{keywordflow}{case} \textcolor{charliteral}{'4'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%04d"}, frame\_in); \textcolor{keywordflow}{break};
366         \textcolor{keywordflow}{case} \textcolor{charliteral}{'5'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%05d"}, frame\_in); \textcolor{keywordflow}{break};
367         \textcolor{keywordflow}{case} \textcolor{charliteral}{'6'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%06d"}, frame\_in); \textcolor{keywordflow}{break};
368         \textcolor{keywordflow}{case} \textcolor{charliteral}{'7'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%07d"}, frame\_in); \textcolor{keywordflow}{break};
369         \textcolor{keywordflow}{case} \textcolor{charliteral}{'8'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%08d"}, frame\_in); \textcolor{keywordflow}{break};
370         \textcolor{keywordflow}{case} \textcolor{charliteral}{'9'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%09d"}, frame\_in); \textcolor{keywordflow}{break};
371         \textcolor{keywordflow}{default}: die(\textcolor{stringliteral}{"Unrecognized pattern %%%c\(\backslash\)n"}, p[1]); \textcolor{keywordflow}{break};
372       \}
373 
374       pat\_len = strlen(q);
375       \textcolor{keywordflow}{if} (pat\_len >= q\_len - 1) die(\textcolor{stringliteral}{"Output filename too long.\(\backslash\)n"});
376       q += pat\_len;
377       p += 2;
378       q\_len -= pat\_len;
379     \} \textcolor{keywordflow}{else} \{
380       \textcolor{keywordtype}{size\_t} copy\_len;
381 
382       \textcolor{comment}{/* copy the next segment */}
383       \textcolor{keywordflow}{if} (!next\_pat)
384         copy\_len = strlen(p);
385       \textcolor{keywordflow}{else}
386         copy\_len = next\_pat - p;
387 
388       \textcolor{keywordflow}{if} (copy\_len >= q\_len - 1) die(\textcolor{stringliteral}{"Output filename too long.\(\backslash\)n"});
389 
390       memcpy(q, p, copy\_len);
391       q[copy\_len] = \textcolor{charliteral}{'\(\backslash\)0'};
392       q += copy\_len;
393       p += copy\_len;
394       q\_len -= copy\_len;
395     \}
396   \} \textcolor{keywordflow}{while} (*p);
397 \}
398 
399 \textcolor{keyword}{static} \textcolor{keywordtype}{int} is\_single\_file(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_pattern) \{
400   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *p = outfile\_pattern;
401 
402   \textcolor{keywordflow}{do} \{
403     p = strchr(p, \textcolor{charliteral}{'%'});
404     \textcolor{keywordflow}{if} (p && p[1] >= \textcolor{charliteral}{'1'} && p[1] <= \textcolor{charliteral}{'9'})
405       \textcolor{keywordflow}{return} 0;  \textcolor{comment}{// pattern contains sequence number, so it's not unique}
406     \textcolor{keywordflow}{if} (p) p++;
407   \} \textcolor{keywordflow}{while} (p);
408 
409   \textcolor{keywordflow}{return} 1;
410 \}
411 
412 \textcolor{keyword}{static} \textcolor{keywordtype}{void} print\_md5(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} digest[16], \textcolor{keyword}{const} \textcolor{keywordtype}{char} *filename) \{
413   \textcolor{keywordtype}{int} i;
414 
415   \textcolor{keywordflow}{for} (i = 0; i < 16; ++i) printf(\textcolor{stringliteral}{"%02x"}, digest[i]);
416   printf(\textcolor{stringliteral}{"  %s\(\backslash\)n"}, filename);
417 \}
418 
419 \textcolor{keyword}{static} FILE *open\_outfile(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *name) \{
420   \textcolor{keywordflow}{if} (strcmp(\textcolor{stringliteral}{"-"}, name) == 0) \{
421     set\_binary\_mode(stdout);
422     \textcolor{keywordflow}{return} stdout;
423   \} \textcolor{keywordflow}{else} \{
424     FILE *file = fopen(name, \textcolor{stringliteral}{"wb"});
425     \textcolor{keywordflow}{if} (!file) fatal(\textcolor{stringliteral}{"Failed to open output file '%s'"}, name);
426     \textcolor{keywordflow}{return} file;
427   \}
428 \}
429 
430 \textcolor{keyword}{static} \textcolor{keywordtype}{int} img\_shifted\_realloc\_required(\textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img,
431                                         \textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *shifted,
432                                         \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} required\_fmt) \{
433   \textcolor{keywordflow}{return} img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} != shifted->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} || img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} != shifted->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} ||
434          required\_fmt != shifted->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt};
435 \}
436 
437 \textcolor{keyword}{static} \textcolor{keywordtype}{int} main\_loop(\textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **argv\_) \{
438   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} decoder;
439   \textcolor{keywordtype}{char} *fn = NULL;
440   \textcolor{keywordtype}{int} i;
441   \textcolor{keywordtype}{int} ret = EXIT\_FAILURE;
442   uint8\_t *buf = NULL;
443   \textcolor{keywordtype}{size\_t} bytes\_in\_buffer = 0, buffer\_size = 0;
444   FILE *infile;
445   \textcolor{keywordtype}{int} frame\_in = 0, frame\_out = 0, flipuv = 0, noblit = 0;
446   \textcolor{keywordtype}{int} do\_md5 = 0, progress = 0;
447   \textcolor{keywordtype}{int} stop\_after = 0, postproc = 0, summary = 0, quiet = 1;
448   \textcolor{keywordtype}{int} arg\_skip = 0;
449   \textcolor{keywordtype}{int} keep\_going = 0;
450   \textcolor{keyword}{const} AvxInterface *\textcolor{keyword}{interface }= NULL;
451   \textcolor{keyword}{const} AvxInterface *fourcc\_interface = NULL;
452   uint64\_t dx\_time = 0;
453   \textcolor{keyword}{struct }arg arg;
454   \textcolor{keywordtype}{char} **argv, **argi, **argj;
455 
456   \textcolor{keywordtype}{int} single\_file;
457   \textcolor{keywordtype}{int} use\_y4m = 1;
458   \textcolor{keywordtype}{int} opt\_yv12 = 0;
459   \textcolor{keywordtype}{int} opt\_i420 = 0;
460   \textcolor{keywordtype}{int} opt\_raw = 0;
461   \hyperlink{structaom__codec__dec__cfg}{aom\_codec\_dec\_cfg\_t} cfg = \{ 0, 0, 0, CONFIG\_LOWBITDEPTH, \{ 1 \} \};
462   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} output\_bit\_depth = 0;
463   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} is\_annexb = 0;
464   \textcolor{keywordtype}{int} frames\_corrupted = 0;
465   \textcolor{keywordtype}{int} dec\_flags = 0;
466   \textcolor{keywordtype}{int} do\_scale = 0;
467   \textcolor{keywordtype}{int} operating\_point = 0;
468   \textcolor{keywordtype}{int} output\_all\_layers = 0;
469   \textcolor{keywordtype}{int} skip\_film\_grain = 0;
470   \hyperlink{structaom__image}{aom\_image\_t} *scaled\_img = NULL;
471   \hyperlink{structaom__image}{aom\_image\_t} *img\_shifted = NULL;
472   \textcolor{keywordtype}{int} frame\_avail, got\_data, flush\_decoder = 0;
473   \textcolor{keywordtype}{int} num\_external\_frame\_buffers = 0;
474   \textcolor{keyword}{struct }ExternalFrameBufferList ext\_fb\_list = \{ 0, NULL \};
475 
476   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_pattern = NULL;
477   \textcolor{keywordtype}{char} outfile\_name[PATH\_MAX] = \{ 0 \};
478   FILE *outfile = NULL;
479 
480   FILE *framestats\_file = NULL;
481 
482   MD5Context md5\_ctx;
483   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} md5\_digest[16];
484 
485   \textcolor{keyword}{struct }AvxDecInputContext input = \{ NULL, NULL, NULL \};
486   \textcolor{keyword}{struct }AvxInputContext aom\_input\_ctx;
487   memset(&aom\_input\_ctx, 0, \textcolor{keyword}{sizeof}(aom\_input\_ctx));
488 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
489   \textcolor{keyword}{struct }WebmInputContext webm\_ctx;
490   memset(&webm\_ctx, 0, \textcolor{keyword}{sizeof}(webm\_ctx));
491   input.webm\_ctx = &webm\_ctx;
492 \textcolor{preprocessor}{#endif}
493   \textcolor{keyword}{struct }ObuDecInputContext obu\_ctx = \{ NULL, NULL, 0, 0, 0 \};
494 
495   obu\_ctx.avx\_ctx = &aom\_input\_ctx;
496   input.obu\_ctx = &obu\_ctx;
497   input.aom\_input\_ctx = &aom\_input\_ctx;
498 
499   \textcolor{comment}{/* Parse command line */}
500   exec\_name = argv\_[0];
501   argv = argv\_dup(argc - 1, argv\_ + 1);
502 
503   \textcolor{keywordflow}{for} (argi = argj = argv; (*argj = *argi); argi += arg.argv\_step) \{
504     memset(&arg, 0, \textcolor{keyword}{sizeof}(arg));
505     arg.argv\_step = 1;
506 
507     \textcolor{keywordflow}{if} (arg\_match(&arg, &help, argi)) \{
508       show\_help(stdout, 0);
509       exit(EXIT\_SUCCESS);
510     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &codecarg, argi)) \{
511       \textcolor{keyword}{interface }= get\_aom\_decoder\_by\_name(arg.val);
512       \textcolor{keywordflow}{if} (!interface)
513         die(\textcolor{stringliteral}{"Error: Unrecognized argument (%s) to --codec\(\backslash\)n"}, arg.val);
514     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &looparg, argi)) \{
515       \textcolor{comment}{// no-op}
516     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &outputfile, argi)) \{
517       outfile\_pattern = arg.val;
518     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_yv12, argi)) \{
519       use\_y4m = 0;
520       flipuv = 1;
521       opt\_yv12 = 1;
522       opt\_i420 = 0;
523       opt\_raw = 0;
524     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i420, argi)) \{
525       use\_y4m = 0;
526       flipuv = 0;
527       opt\_yv12 = 0;
528       opt\_i420 = 1;
529       opt\_raw = 0;
530     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &rawvideo, argi)) \{
531       use\_y4m = 0;
532       opt\_yv12 = 0;
533       opt\_i420 = 0;
534       opt\_raw = 1;
535     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &flipuvarg, argi)) \{
536       flipuv = 1;
537     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &noblitarg, argi)) \{
538       noblit = 1;
539     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &progressarg, argi)) \{
540       progress = 1;
541     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &limitarg, argi)) \{
542       stop\_after = arg\_parse\_uint(&arg);
543     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &skiparg, argi)) \{
544       arg\_skip = arg\_parse\_uint(&arg);
545     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &postprocarg, argi)) \{
546       postproc = 1;
547     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &md5arg, argi)) \{
548       do\_md5 = 1;
549     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &framestatsarg, argi)) \{
550       framestats\_file = fopen(arg.val, \textcolor{stringliteral}{"w"});
551       \textcolor{keywordflow}{if} (!framestats\_file) \{
552         die(\textcolor{stringliteral}{"Error: Could not open --framestats file (%s) for writing.\(\backslash\)n"},
553             arg.val);
554       \}
555     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &summaryarg, argi)) \{
556       summary = 1;
557     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &threadsarg, argi)) \{
558       cfg.\hyperlink{structaom__codec__dec__cfg_a48c68337e1071e2aee36c649e579f189}{threads} = arg\_parse\_uint(&arg);
559 \textcolor{preprocessor}{#if !CONFIG\_MULTITHREAD}
560       \textcolor{keywordflow}{if} (cfg.\hyperlink{structaom__codec__dec__cfg_a48c68337e1071e2aee36c649e579f189}{threads} > 1) \{
561         die(\textcolor{stringliteral}{"Error: --threads=%d is not supported when CONFIG\_MULTITHREAD = "}
562             \textcolor{stringliteral}{"0.\(\backslash\)n"},
563             cfg.\hyperlink{structaom__codec__dec__cfg_a48c68337e1071e2aee36c649e579f189}{threads});
564       \}
565 \textcolor{preprocessor}{#endif}
566     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &verbosearg, argi)) \{
567       quiet = 0;
568     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &scalearg, argi)) \{
569       do\_scale = 1;
570     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &fb\_arg, argi)) \{
571       num\_external\_frame\_buffers = arg\_parse\_uint(&arg);
572     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &continuearg, argi)) \{
573       keep\_going = 1;
574     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &outbitdeptharg, argi)) \{
575       output\_bit\_depth = arg\_parse\_uint(&arg);
576     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &isannexb, argi)) \{
577       is\_annexb = 1;
578       input.obu\_ctx->is\_annexb = 1;
579     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &oppointarg, argi)) \{
580       operating\_point = arg\_parse\_int(&arg);
581     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &outallarg, argi)) \{
582       output\_all\_layers = 1;
583     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &skipfilmgrain, argi)) \{
584       skip\_film\_grain = 1;
585     \} \textcolor{keywordflow}{else} \{
586       argj++;
587     \}
588   \}
589 
590   \textcolor{comment}{/* Check for unrecognized options */}
591   \textcolor{keywordflow}{for} (argi = argv; *argi; argi++)
592     \textcolor{keywordflow}{if} (argi[0][0] == \textcolor{charliteral}{'-'} && strlen(argi[0]) > 1)
593       die(\textcolor{stringliteral}{"Error: Unrecognized option %s\(\backslash\)n"}, *argi);
594 
595   \textcolor{comment}{/* Handle non-option arguments */}
596   fn = argv[0];
597 
598   \textcolor{keywordflow}{if} (!fn) \{
599     free(argv);
600     fprintf(stderr, \textcolor{stringliteral}{"No input file specified!\(\backslash\)n"});
601     usage\_exit();
602   \}
603   \textcolor{comment}{/* Open file */}
604   infile = strcmp(fn, \textcolor{stringliteral}{"-"}) ? fopen(fn, \textcolor{stringliteral}{"rb"}) : set\_binary\_mode(stdin);
605 
606   \textcolor{keywordflow}{if} (!infile) \{
607     fatal(\textcolor{stringliteral}{"Failed to open input file '%s'"}, strcmp(fn, \textcolor{stringliteral}{"-"}) ? fn : \textcolor{stringliteral}{"stdin"});
608   \}
609 \textcolor{preprocessor}{#if CONFIG\_OS\_SUPPORT}
610   \textcolor{comment}{/* Make sure we don't dump to the terminal, unless forced to with -o - */}
611   \textcolor{keywordflow}{if} (!outfile\_pattern && isatty(STDOUT\_FILENO) && !do\_md5 && !noblit) \{
612     fprintf(stderr,
613             \textcolor{stringliteral}{"Not dumping raw video to your terminal. Use '-o -' to "}
614             \textcolor{stringliteral}{"override.\(\backslash\)n"});
615     \textcolor{keywordflow}{return} EXIT\_FAILURE;
616   \}
617 \textcolor{preprocessor}{#endif}
618   input.aom\_input\_ctx->filename = fn;
619   input.aom\_input\_ctx->file = infile;
620   \textcolor{keywordflow}{if} (file\_is\_ivf(input.aom\_input\_ctx))
621     input.aom\_input\_ctx->file\_type = FILE\_TYPE\_IVF;
622 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
623   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (file\_is\_webm(input.webm\_ctx, input.aom\_input\_ctx))
624     input.aom\_input\_ctx->file\_type = FILE\_TYPE\_WEBM;
625 \textcolor{preprocessor}{#endif}
626   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (file\_is\_obu(&obu\_ctx))
627     input.aom\_input\_ctx->file\_type = FILE\_TYPE\_OBU;
628   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (file\_is\_raw(input.aom\_input\_ctx))
629     input.aom\_input\_ctx->file\_type = FILE\_TYPE\_RAW;
630   \textcolor{keywordflow}{else} \{
631     fprintf(stderr, \textcolor{stringliteral}{"Unrecognized input file type.\(\backslash\)n"});
632 \textcolor{preprocessor}{#if !CONFIG\_WEBM\_IO}
633     fprintf(stderr, \textcolor{stringliteral}{"aomdec was built without WebM container support.\(\backslash\)n"});
634 \textcolor{preprocessor}{#endif}
635     \textcolor{keywordflow}{return} EXIT\_FAILURE;
636   \}
637 
638   outfile\_pattern = outfile\_pattern ? outfile\_pattern : \textcolor{stringliteral}{"-"};
639   single\_file = is\_single\_file(outfile\_pattern);
640 
641   \textcolor{keywordflow}{if} (!noblit && single\_file) \{
642     generate\_filename(outfile\_pattern, outfile\_name, PATH\_MAX,
643                       aom\_input\_ctx.width, aom\_input\_ctx.height, 0);
644     \textcolor{keywordflow}{if} (do\_md5)
645       MD5Init(&md5\_ctx);
646     \textcolor{keywordflow}{else}
647       outfile = open\_outfile(outfile\_name);
648   \}
649 
650   \textcolor{keywordflow}{if} (use\_y4m && !noblit) \{
651     \textcolor{keywordflow}{if} (!single\_file) \{
652       fprintf(stderr,
653               \textcolor{stringliteral}{"YUV4MPEG2 not supported with output patterns,"}
654               \textcolor{stringliteral}{" try --i420 or --yv12 or --rawvideo.\(\backslash\)n"});
655       \textcolor{keywordflow}{return} EXIT\_FAILURE;
656     \}
657 
658 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
659     \textcolor{keywordflow}{if} (aom\_input\_ctx.file\_type == FILE\_TYPE\_WEBM) \{
660       \textcolor{keywordflow}{if} (webm\_guess\_framerate(input.webm\_ctx, input.aom\_input\_ctx)) \{
661         fprintf(stderr,
662                 \textcolor{stringliteral}{"Failed to guess framerate -- error parsing "}
663                 \textcolor{stringliteral}{"webm file?\(\backslash\)n"});
664         \textcolor{keywordflow}{return} EXIT\_FAILURE;
665       \}
666     \}
667 \textcolor{preprocessor}{#endif}
668   \}
669 
670   fourcc\_interface = get\_aom\_decoder\_by\_fourcc(aom\_input\_ctx.fourcc);
671   \textcolor{keywordflow}{if} (interface && fourcc\_interface && interface != fourcc\_interface)
672     warn(\textcolor{stringliteral}{"Header indicates codec: %s\(\backslash\)n"}, fourcc\_interface->name);
673   \textcolor{keywordflow}{else}
674     \textcolor{keyword}{interface }= fourcc\_interface;
675 
676   \textcolor{keywordflow}{if} (!interface) \textcolor{keyword}{interface }= get\_aom\_decoder\_by\_index(0);
677 
678   dec\_flags = (postproc ? \hyperlink{group__decoder_ga7b6c145833964c9edd3ff78be017f7ec}{AOM\_CODEC\_USE\_POSTPROC} : 0);
679   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&decoder, interface->codec\_interface(), &cfg,
680                          dec\_flags)) \{
681     fprintf(stderr, \textcolor{stringliteral}{"Failed to initialize decoder: %s\(\backslash\)n"},
682             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
683     \textcolor{keywordflow}{goto} fail2;
684   \}
685 
686   \textcolor{keywordflow}{if} (!quiet) fprintf(stderr, \textcolor{stringliteral}{"%s\(\backslash\)n"}, decoder.\hyperlink{structaom__codec__ctx_a3aa8abff3e05d2fbbf4f5a9fa0575f2b}{name});
687 
688   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba1fb269c5c5913d9995b6c35d28e2a788}{AV1D\_SET\_IS\_ANNEXB}, is\_annexb)) \{
689     fprintf(stderr, \textcolor{stringliteral}{"Failed to set is\_annexb: %s\(\backslash\)n"}, \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
690     \textcolor{keywordflow}{goto} fail;
691   \}
692 
693   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baa8b955fc5a2f6e33c6dad858d7c15f67}{AV1D\_SET\_OPERATING\_POINT}, 
      operating\_point)) \{
694     fprintf(stderr, \textcolor{stringliteral}{"Failed to set operating\_point: %s\(\backslash\)n"},
695             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
696     \textcolor{keywordflow}{goto} fail;
697   \}
698 
699   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba8d51f96b8877b665225f5cfaa73ded8e}{AV1D\_SET\_OUTPUT\_ALL\_LAYERS},
700                         output\_all\_layers)) \{
701     fprintf(stderr, \textcolor{stringliteral}{"Failed to set output\_all\_layers: %s\(\backslash\)n"},
702             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
703     \textcolor{keywordflow}{goto} fail;
704   \}
705 
706   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba17fa09c9ce1ae4a68eae21efd219418b}{AV1D\_SET\_SKIP\_FILM\_GRAIN}, 
      skip\_film\_grain)) \{
707     fprintf(stderr, \textcolor{stringliteral}{"Failed to set skip\_film\_grain: %s\(\backslash\)n"},
708             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
709     \textcolor{keywordflow}{goto} fail;
710   \}
711 
712   \textcolor{keywordflow}{if} (arg\_skip) fprintf(stderr, \textcolor{stringliteral}{"Skipping first %d frames.\(\backslash\)n"}, arg\_skip);
713   \textcolor{keywordflow}{while} (arg\_skip) \{
714     \textcolor{keywordflow}{if} (read\_frame(&input, &buf, &bytes\_in\_buffer, &buffer\_size)) \textcolor{keywordflow}{break};
715     arg\_skip--;
716   \}
717 
718   \textcolor{keywordflow}{if} (num\_external\_frame\_buffers > 0) \{
719     ext\_fb\_list.num\_external\_frame\_buffers = num\_external\_frame\_buffers;
720     ext\_fb\_list.ext\_fb = (\textcolor{keyword}{struct }ExternalFrameBuffer *)calloc(
721         num\_external\_frame\_buffers, \textcolor{keyword}{sizeof}(*ext\_fb\_list.ext\_fb));
722     \textcolor{keywordflow}{if} (\hyperlink{group__cap__external__frame__buffer_ga1818a812e4d1e70eeafbe5b0ee538d6e}{aom\_codec\_set\_frame\_buffer\_functions}(&decoder, 
      get\_av1\_frame\_buffer,
723                                              release\_av1\_frame\_buffer,
724                                              &ext\_fb\_list)) \{
725       fprintf(stderr, \textcolor{stringliteral}{"Failed to configure external frame buffers: %s\(\backslash\)n"},
726               \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
727       \textcolor{keywordflow}{goto} fail;
728     \}
729   \}
730 
731   frame\_avail = 1;
732   got\_data = 0;
733 
734   \textcolor{keywordflow}{if} (framestats\_file) fprintf(framestats\_file, \textcolor{stringliteral}{"bytes,qp\(\backslash\)r\(\backslash\)n"});
735 
736   \textcolor{comment}{/* Decode file */}
737   \textcolor{keywordflow}{while} (frame\_avail || got\_data) \{
738     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
739     \hyperlink{structaom__image}{aom\_image\_t} *img;
740     \textcolor{keyword}{struct }aom\_usec\_timer timer;
741     \textcolor{keywordtype}{int} corrupted = 0;
742 
743     frame\_avail = 0;
744     \textcolor{keywordflow}{if} (!stop\_after || frame\_in < stop\_after) \{
745       \textcolor{keywordflow}{if} (!read\_frame(&input, &buf, &bytes\_in\_buffer, &buffer\_size)) \{
746         frame\_avail = 1;
747         frame\_in++;
748 
749         aom\_usec\_timer\_start(&timer);
750 
751         \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&decoder, buf, bytes\_in\_buffer, NULL)) \{
752           \textcolor{keyword}{const} \textcolor{keywordtype}{char} *detail = \hyperlink{group__codec_ga43a70562598b485685794a4e9d9d53f7}{aom\_codec\_error\_detail}(&decoder);
753           warn(\textcolor{stringliteral}{"Failed to decode frame %d: %s"}, frame\_in,
754                \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
755 
756           \textcolor{keywordflow}{if} (detail) warn(\textcolor{stringliteral}{"Additional information: %s"}, detail);
757           \textcolor{keywordflow}{if} (!keep\_going) \textcolor{keywordflow}{goto} fail;
758         \}
759 
760         \textcolor{keywordflow}{if} (framestats\_file) \{
761           \textcolor{keywordtype}{int} qp;
762           \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, 
      \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baa984acc8b42df9c7d18fc3556a14fd29}{AOMD\_GET\_LAST\_QUANTIZER}, &qp)) \{
763             warn(\textcolor{stringliteral}{"Failed AOMD\_GET\_LAST\_QUANTIZER: %s"},
764                  \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
765             \textcolor{keywordflow}{if} (!keep\_going) \textcolor{keywordflow}{goto} fail;
766           \}
767           fprintf(framestats\_file, \textcolor{stringliteral}{"%d,%d\(\backslash\)r\(\backslash\)n"}, (\textcolor{keywordtype}{int})bytes\_in\_buffer, qp);
768         \}
769 
770         aom\_usec\_timer\_mark(&timer);
771         dx\_time += aom\_usec\_timer\_elapsed(&timer);
772       \} \textcolor{keywordflow}{else} \{
773         flush\_decoder = 1;
774       \}
775     \} \textcolor{keywordflow}{else} \{
776       flush\_decoder = 1;
777     \}
778 
779     aom\_usec\_timer\_start(&timer);
780 
781     \textcolor{keywordflow}{if} (flush\_decoder) \{
782       \textcolor{comment}{// Flush the decoder.}
783       \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&decoder, NULL, 0, NULL)) \{
784         warn(\textcolor{stringliteral}{"Failed to flush decoder: %s"}, \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
785       \}
786     \}
787 
788     aom\_usec\_timer\_mark(&timer);
789     dx\_time += aom\_usec\_timer\_elapsed(&timer);
790 
791     got\_data = 0;
792     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&decoder, &iter))) \{
793       ++frame\_out;
794       got\_data = 1;
795 
796       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba159ddb748cb69956226b7c13e3890ff6}{AOMD\_GET\_FRAME\_CORRUPTED}, &
      corrupted)) \{
797         warn(\textcolor{stringliteral}{"Failed AOM\_GET\_FRAME\_CORRUPTED: %s"}, \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
798         \textcolor{keywordflow}{if} (!keep\_going) \textcolor{keywordflow}{goto} fail;
799       \}
800       frames\_corrupted += corrupted;
801 
802       \textcolor{keywordflow}{if} (progress) show\_progress(frame\_in, frame\_out, dx\_time);
803 
804       \textcolor{keywordflow}{if} (!noblit) \{
805         \textcolor{keyword}{const} \textcolor{keywordtype}{int} PLANES\_YUV[] = \{ \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}, \hyperlink{aom__image_8h_a0845e9194541329c0f77b4bd6a38cc7c}{AOM\_PLANE\_U}, AOM\_PLANE\_V \};
806         \textcolor{keyword}{const} \textcolor{keywordtype}{int} PLANES\_YVU[] = \{ \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}, \hyperlink{aom__image_8h_a32a43f20adb01d846af1925189c37495}{AOM\_PLANE\_V}, AOM\_PLANE\_U \};
807         \textcolor{keyword}{const} \textcolor{keywordtype}{int} *planes = flipuv ? PLANES\_YVU : PLANES\_YUV;
808 
809         \textcolor{keywordflow}{if} (do\_scale) \{
810           \textcolor{keywordflow}{if} (frame\_out == 1) \{
811             \textcolor{comment}{// If the output frames are to be scaled to a fixed display size}
812             \textcolor{comment}{// then use the width and height specified in the container. If}
813             \textcolor{comment}{// either of these is set to 0, use the display size set in the}
814             \textcolor{comment}{// first frame header. If that is unavailable, use the raw decoded}
815             \textcolor{comment}{// size of the first decoded frame.}
816             \textcolor{keywordtype}{int} render\_width = aom\_input\_ctx.width;
817             \textcolor{keywordtype}{int} render\_height = aom\_input\_ctx.height;
818             \textcolor{keywordflow}{if} (!render\_width || !render\_height) \{
819               \textcolor{keywordtype}{int} render\_size[2];
820               \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, 
      \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba592a5d1390204d743ddfe7bfe8ef177c}{AV1D\_GET\_DISPLAY\_SIZE},
821                                     render\_size)) \{
822                 \textcolor{comment}{// As last resort use size of first frame as display size.}
823                 render\_width = img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w};
824                 render\_height = img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h};
825               \} \textcolor{keywordflow}{else} \{
826                 render\_width = render\_size[0];
827                 render\_height = render\_size[1];
828               \}
829             \}
830             scaled\_img =
831                 \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(NULL, img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt}, render\_width, render\_height, 16);
832             scaled\_img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth} = img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth};
833             scaled\_img->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome} = img->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome};
834             scaled\_img->\hyperlink{structaom__image_a4f235c521bc95a061e9e0b2a3d5d457e}{csp} = img->\hyperlink{structaom__image_a4f235c521bc95a061e9e0b2a3d5d457e}{csp};
835           \}
836 
837           \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} != scaled\_img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} || img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} != scaled\_img->
      \hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}) \{
838 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
839             libyuv\_scale(img, scaled\_img, kFilterBox);
840             img = scaled\_img;
841 \textcolor{preprocessor}{#else}
842             fprintf(
843                 stderr,
844                 \textcolor{stringliteral}{"Failed to scale output frame: %s.\(\backslash\)n"}
845                 \textcolor{stringliteral}{"libyuv is required for scaling but is currently disabled.\(\backslash\)n"}
846                 \textcolor{stringliteral}{"Be sure to specify -DCONFIG\_LIBYUV=1 when running cmake.\(\backslash\)n"},
847                 \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
848             \textcolor{keywordflow}{goto} fail;
849 \textcolor{preprocessor}{#endif}
850           \}
851         \}
852         \textcolor{comment}{// Default to codec bit depth if output bit depth not set}
853         \textcolor{keywordflow}{if} (!output\_bit\_depth && single\_file && !do\_md5) \{
854           output\_bit\_depth = img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth};
855         \}
856         \textcolor{comment}{// Shift up or down if necessary}
857         \textcolor{keywordflow}{if} (output\_bit\_depth != 0) \{
858           \textcolor{keyword}{const} \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} shifted\_fmt =
859               output\_bit\_depth == 8 ? img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & ~\hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}
860                                     : img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} | \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH};
861 
862           \textcolor{keywordflow}{if} (shifted\_fmt != img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} || output\_bit\_depth != img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth}) \{
863             \textcolor{keywordflow}{if} (img\_shifted &&
864                 img\_shifted\_realloc\_required(img, img\_shifted, shifted\_fmt)) \{
865               \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(img\_shifted);
866               img\_shifted = NULL;
867             \}
868             \textcolor{keywordflow}{if} (img\_shifted) \{
869               img\_shifted->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome} = img->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome};
870             \}
871             \textcolor{keywordflow}{if} (!img\_shifted) \{
872               img\_shifted =
873                   \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(NULL, shifted\_fmt, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->
      \hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
874               img\_shifted->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth} = output\_bit\_depth;
875               img\_shifted->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome} = img->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome};
876               img\_shifted->\hyperlink{structaom__image_a4f235c521bc95a061e9e0b2a3d5d457e}{csp} = img->\hyperlink{structaom__image_a4f235c521bc95a061e9e0b2a3d5d457e}{csp};
877             \}
878             \textcolor{keywordflow}{if} (output\_bit\_depth > img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth}) \{
879               aom\_img\_upshift(img\_shifted, img,
880                               output\_bit\_depth - img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth});
881             \} \textcolor{keywordflow}{else} \{
882               aom\_img\_downshift(img\_shifted, img,
883                                 img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth} - output\_bit\_depth);
884             \}
885             img = img\_shifted;
886           \}
887         \}
888 
889         aom\_input\_ctx.width = img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w};
890         aom\_input\_ctx.height = img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h};
891 
892         \textcolor{keywordtype}{int} num\_planes = (opt\_raw && img->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome}) ? 1 : 3;
893         \textcolor{keywordflow}{if} (single\_file) \{
894           \textcolor{keywordflow}{if} (use\_y4m) \{
895             \textcolor{keywordtype}{char} y4m\_buf[Y4M\_BUFFER\_SIZE] = \{ 0 \};
896             \textcolor{keywordtype}{size\_t} len = 0;
897             \textcolor{keywordflow}{if} (frame\_out == 1) \{
898               \textcolor{comment}{// Y4M file header}
899               len = y4m\_write\_file\_header(
900                   y4m\_buf, \textcolor{keyword}{sizeof}(y4m\_buf), aom\_input\_ctx.width,
901                   aom\_input\_ctx.height, &aom\_input\_ctx.framerate,
902                   img->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome}, img->\hyperlink{structaom__image_a4f235c521bc95a061e9e0b2a3d5d457e}{csp}, img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt}, img->
      \hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth});
903               \textcolor{keywordflow}{if} (do\_md5) \{
904                 MD5Update(&md5\_ctx, (md5byte *)y4m\_buf, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})len);
905               \} \textcolor{keywordflow}{else} \{
906                 fputs(y4m\_buf, outfile);
907               \}
908             \}
909 
910             \textcolor{comment}{// Y4M frame header}
911             len = y4m\_write\_frame\_header(y4m\_buf, \textcolor{keyword}{sizeof}(y4m\_buf));
912             \textcolor{keywordflow}{if} (do\_md5) \{
913               MD5Update(&md5\_ctx, (md5byte *)y4m\_buf, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})len);
914               y4m\_update\_image\_md5(img, planes, &md5\_ctx);
915             \} \textcolor{keywordflow}{else} \{
916               fputs(y4m\_buf, outfile);
917               y4m\_write\_image\_file(img, planes, outfile);
918             \}
919           \} \textcolor{keywordflow}{else} \{
920             \textcolor{keywordflow}{if} (frame\_out == 1) \{
921               \textcolor{comment}{// Check if --yv12 or --i420 options are consistent with the}
922               \textcolor{comment}{// bit-stream decoded}
923               \textcolor{keywordflow}{if} (opt\_i420) \{
924                 \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} &&
925                     img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}) \{
926                   fprintf(stderr,
927                           \textcolor{stringliteral}{"Cannot produce i420 output for bit-stream.\(\backslash\)n"});
928                   \textcolor{keywordflow}{goto} fail;
929                 \}
930               \}
931               \textcolor{keywordflow}{if} (opt\_yv12) \{
932                 \textcolor{keywordflow}{if} ((img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} &&
933                      img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cad28244100a2754409f285b77a3db90a0}{AOM\_IMG\_FMT\_YV12}) ||
934                     img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth} != 8) \{
935                   fprintf(stderr,
936                           \textcolor{stringliteral}{"Cannot produce yv12 output for bit-stream.\(\backslash\)n"});
937                   \textcolor{keywordflow}{goto} fail;
938                 \}
939               \}
940             \}
941             \textcolor{keywordflow}{if} (do\_md5) \{
942               raw\_update\_image\_md5(img, planes, num\_planes, &md5\_ctx);
943             \} \textcolor{keywordflow}{else} \{
944               raw\_write\_image\_file(img, planes, num\_planes, outfile);
945             \}
946           \}
947         \} \textcolor{keywordflow}{else} \{
948           generate\_filename(outfile\_pattern, outfile\_name, PATH\_MAX, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w},
949                             img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, frame\_in);
950           \textcolor{keywordflow}{if} (do\_md5) \{
951             MD5Init(&md5\_ctx);
952             \textcolor{keywordflow}{if} (use\_y4m) \{
953               y4m\_update\_image\_md5(img, planes, &md5\_ctx);
954             \} \textcolor{keywordflow}{else} \{
955               raw\_update\_image\_md5(img, planes, num\_planes, &md5\_ctx);
956             \}
957             MD5Final(md5\_digest, &md5\_ctx);
958             print\_md5(md5\_digest, outfile\_name);
959           \} \textcolor{keywordflow}{else} \{
960             outfile = open\_outfile(outfile\_name);
961             \textcolor{keywordflow}{if} (use\_y4m) \{
962               y4m\_write\_image\_file(img, planes, outfile);
963             \} \textcolor{keywordflow}{else} \{
964               raw\_write\_image\_file(img, planes, num\_planes, outfile);
965             \}
966             fclose(outfile);
967           \}
968         \}
969       \}
970     \}
971   \}
972 
973   \textcolor{keywordflow}{if} (summary || progress) \{
974     show\_progress(frame\_in, frame\_out, dx\_time);
975     fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)n"});
976   \}
977 
978   \textcolor{keywordflow}{if} (frames\_corrupted) \{
979     fprintf(stderr, \textcolor{stringliteral}{"WARNING: %d frames corrupted.\(\backslash\)n"}, frames\_corrupted);
980   \} \textcolor{keywordflow}{else} \{
981     ret = EXIT\_SUCCESS;
982   \}
983 
984 fail:
985 
986   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&decoder)) \{
987     fprintf(stderr, \textcolor{stringliteral}{"Failed to destroy decoder: %s\(\backslash\)n"},
988             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
989   \}
990 
991 fail2:
992 
993   \textcolor{keywordflow}{if} (!noblit && single\_file) \{
994     \textcolor{keywordflow}{if} (do\_md5) \{
995       MD5Final(md5\_digest, &md5\_ctx);
996       print\_md5(md5\_digest, outfile\_name);
997     \} \textcolor{keywordflow}{else} \{
998       fclose(outfile);
999     \}
1000   \}
1001 
1002 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1003   \textcolor{keywordflow}{if} (input.aom\_input\_ctx->file\_type == FILE\_TYPE\_WEBM)
1004     webm\_free(input.webm\_ctx);
1005 \textcolor{preprocessor}{#endif}
1006   \textcolor{keywordflow}{if} (input.aom\_input\_ctx->file\_type == FILE\_TYPE\_OBU)
1007     obudec\_free(input.obu\_ctx);
1008 
1009   \textcolor{keywordflow}{if} (input.aom\_input\_ctx->file\_type != FILE\_TYPE\_WEBM) free(buf);
1010 
1011   \textcolor{keywordflow}{if} (scaled\_img) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(scaled\_img);
1012   \textcolor{keywordflow}{if} (img\_shifted) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(img\_shifted);
1013 
1014   \textcolor{keywordflow}{for} (i = 0; i < ext\_fb\_list.num\_external\_frame\_buffers; ++i) \{
1015     free(ext\_fb\_list.ext\_fb[i].data);
1016   \}
1017   free(ext\_fb\_list.ext\_fb);
1018 
1019   fclose(infile);
1020   \textcolor{keywordflow}{if} (framestats\_file) fclose(framestats\_file);
1021 
1022   free(argv);
1023 
1024   \textcolor{keywordflow}{return} ret;
1025 \}
1026 
1027 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **argv\_) \{
1028   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} loops = 1, i;
1029   \textcolor{keywordtype}{char} **argv, **argi, **argj;
1030   \textcolor{keyword}{struct }arg arg;
1031   \textcolor{keywordtype}{int} error = 0;
1032 
1033   argv = argv\_dup(argc - 1, argv\_ + 1);
1034   \textcolor{keywordflow}{for} (argi = argj = argv; (*argj = *argi); argi += arg.argv\_step) \{
1035     memset(&arg, 0, \textcolor{keyword}{sizeof}(arg));
1036     arg.argv\_step = 1;
1037 
1038     \textcolor{keywordflow}{if} (arg\_match(&arg, &looparg, argi)) \{
1039       loops = arg\_parse\_uint(&arg);
1040       \textcolor{keywordflow}{break};
1041     \}
1042   \}
1043   free(argv);
1044   \textcolor{keywordflow}{for} (i = 0; !error && i < loops; i++) error = main\_loop(argc, argv\_);
1045   \textcolor{keywordflow}{return} error;
1046 \}
\end{DoxyCodeInclude}
 \hypertarget{example_aomenc}{}\subsection{aomenc}\label{example_aomenc}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{preprocessor}{#include "apps/aomenc.h"}
13 
14 \textcolor{preprocessor}{#include "config/aom\_config.h"}
15 
16 \textcolor{preprocessor}{#include <assert.h>}
17 \textcolor{preprocessor}{#include <limits.h>}
18 \textcolor{preprocessor}{#include <math.h>}
19 \textcolor{preprocessor}{#include <stdarg.h>}
20 \textcolor{preprocessor}{#include <stdio.h>}
21 \textcolor{preprocessor}{#include <stdlib.h>}
22 \textcolor{preprocessor}{#include <string.h>}
23 
24 \textcolor{preprocessor}{#if CONFIG\_AV1\_DECODER}
25 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
26 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
27 \textcolor{preprocessor}{#endif}
28 
29 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
30 \textcolor{preprocessor}{#include "aom/aom\_integer.h"}
31 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
32 \textcolor{preprocessor}{#include "aom\_dsp/aom\_dsp\_common.h"}
33 \textcolor{preprocessor}{#include "aom\_ports/aom\_timer.h"}
34 \textcolor{preprocessor}{#include "aom\_ports/mem\_ops.h"}
35 \textcolor{preprocessor}{#include "common/args.h"}
36 \textcolor{preprocessor}{#include "common/ivfenc.h"}
37 \textcolor{preprocessor}{#include "common/tools\_common.h"}
38 \textcolor{preprocessor}{#include "common/warnings.h"}
39 
40 \textcolor{preprocessor}{#include "sparse\_utils/image\_handler.h"}
41 \textcolor{preprocessor}{#include "sparse\_utils/dictionary\_learning.h"}
42 
43 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
44 \textcolor{preprocessor}{#include "common/webmenc.h"}
45 \textcolor{preprocessor}{#endif}
46 
47 \textcolor{preprocessor}{#include "common/y4minput.h"}
48 \textcolor{preprocessor}{#include "examples/encoder\_util.h"}
49 \textcolor{preprocessor}{#include "stats/aomstats.h"}
50 \textcolor{preprocessor}{#include "stats/rate\_hist.h"}
51 
52 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
53 \textcolor{preprocessor}{#include "third\_party/libyuv/include/libyuv/scale.h"}
54 \textcolor{preprocessor}{#endif}
55 
56 \textcolor{comment}{/* Swallow warnings about unused results of fread/fwrite */}
57 \textcolor{keyword}{static} \textcolor{keywordtype}{size\_t} wrap\_fread(\textcolor{keywordtype}{void} *ptr, \textcolor{keywordtype}{size\_t} size, \textcolor{keywordtype}{size\_t} nmemb, FILE *stream) \{
58   \textcolor{keywordflow}{return} fread(ptr, size, nmemb, stream);
59 \}
60 \textcolor{preprocessor}{#define fread wrap\_fread}
61 
62 \textcolor{keyword}{static} \textcolor{keywordtype}{size\_t} wrap\_fwrite(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *ptr, \textcolor{keywordtype}{size\_t} size, \textcolor{keywordtype}{size\_t} nmemb,
63     FILE *stream) \{
64   \textcolor{keywordflow}{return} fwrite(ptr, size, nmemb, stream);
65 \}
66 \textcolor{preprocessor}{#define fwrite wrap\_fwrite}
67 
68 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
69 
70 \textcolor{keyword}{static} \textcolor{keywordtype}{void} warn\_or\_exit\_on\_errorv(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keywordtype}{int} fatal,
71     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, va\_list ap) \{
72   \textcolor{keywordflow}{if} (ctx->\hyperlink{structaom__codec__ctx_a4cf9c265a7c34e92bb02d04aa3cab718}{err}) \{
73     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *detail = \hyperlink{group__codec_ga43a70562598b485685794a4e9d9d53f7}{aom\_codec\_error\_detail}(ctx);
74 
75     vfprintf(stderr, s, ap);
76     fprintf(stderr, \textcolor{stringliteral}{": %s\(\backslash\)n"}, \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(ctx));
77 
78     \textcolor{keywordflow}{if} (detail) fprintf(stderr, \textcolor{stringliteral}{"    %s\(\backslash\)n"}, detail);
79 
80     \textcolor{keywordflow}{if} (fatal) exit(EXIT\_FAILURE);
81   \}
82 \}
83 
84 \textcolor{keyword}{static} \textcolor{keywordtype}{void} ctx\_exit\_on\_error(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, ...) \{
85   va\_list ap;
86 
87   va\_start(ap, s);
88   warn\_or\_exit\_on\_errorv(ctx, 1, s, ap);
89   va\_end(ap);
90 \}
91 
92 \textcolor{keyword}{static} \textcolor{keywordtype}{void} warn\_or\_exit\_on\_error(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keywordtype}{int} fatal,
93     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, ...) \{
94   va\_list ap;
95 
96   va\_start(ap, s);
97   warn\_or\_exit\_on\_errorv(ctx, fatal, s, ap);
98   va\_end(ap);
99 \}
100 
101 \textcolor{keyword}{static} \textcolor{keywordtype}{int} read\_frame(\textcolor{keyword}{struct} AvxInputContext *input\_ctx, \hyperlink{structaom__image}{aom\_image\_t} *img) \{
102   FILE *f = input\_ctx->file;
103   y4m\_input *y4m = &input\_ctx->y4m;
104   \textcolor{keywordtype}{int} shortread = 0;
105 
106   \textcolor{keywordflow}{if} (input\_ctx->file\_type == FILE\_TYPE\_Y4M) \{
107     \textcolor{keywordflow}{if} (y4m\_input\_fetch\_frame(y4m, f, img) < 1) \textcolor{keywordflow}{return} 0;
108   \} \textcolor{keywordflow}{else} \{
109     shortread = read\_yuv\_frame(input\_ctx, img);
110   \}
111 
112   \textcolor{keywordflow}{return} !shortread;
113 \}
114 
115 \textcolor{keyword}{static} \textcolor{keywordtype}{int} file\_is\_y4m(\textcolor{keyword}{const} \textcolor{keywordtype}{char} detect[4]) \{
116   \textcolor{keywordflow}{if} (memcmp(detect, \textcolor{stringliteral}{"YUV4"}, 4) == 0) \{
117     \textcolor{keywordflow}{return} 1;
118   \}
119   \textcolor{keywordflow}{return} 0;
120 \}
121 
122 \textcolor{keyword}{static} \textcolor{keywordtype}{int} fourcc\_is\_ivf(\textcolor{keyword}{const} \textcolor{keywordtype}{char} detect[4]) \{
123   \textcolor{keywordflow}{if} (memcmp(detect, \textcolor{stringliteral}{"DKIF"}, 4) == 0) \{
124     \textcolor{keywordflow}{return} 1;
125   \}
126   \textcolor{keywordflow}{return} 0;
127 \}
128 
129 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t help =
130     ARG\_DEF(NULL, \textcolor{stringliteral}{"help"}, 0, \textcolor{stringliteral}{"Show usage options and exit"});
131 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t debugmode =
132     ARG\_DEF(\textcolor{stringliteral}{"D"}, \textcolor{stringliteral}{"debug"}, 0, \textcolor{stringliteral}{"Debug mode (makes output deterministic)"});
133 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outputfile =
134     ARG\_DEF(\textcolor{stringliteral}{"o"}, \textcolor{stringliteral}{"output"}, 1, \textcolor{stringliteral}{"Output filename"});
135 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_yv12 =
136     ARG\_DEF(NULL, \textcolor{stringliteral}{"yv12"}, 0, \textcolor{stringliteral}{"Input file is YV12 "});
137 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i420 =
138     ARG\_DEF(NULL, \textcolor{stringliteral}{"i420"}, 0, \textcolor{stringliteral}{"Input file is I420 (default)"});
139 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i422 =
140     ARG\_DEF(NULL, \textcolor{stringliteral}{"i422"}, 0, \textcolor{stringliteral}{"Input file is I422"});
141 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i444 =
142     ARG\_DEF(NULL, \textcolor{stringliteral}{"i444"}, 0, \textcolor{stringliteral}{"Input file is I444"});
143 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t codecarg = ARG\_DEF(NULL, \textcolor{stringliteral}{"codec"}, 1, \textcolor{stringliteral}{"Codec to use"});
144 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t passes =
145     ARG\_DEF(\textcolor{stringliteral}{"p"}, \textcolor{stringliteral}{"passes"}, 1, \textcolor{stringliteral}{"Number of passes (1/2)"});
146 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t pass\_arg =
147     ARG\_DEF(NULL, \textcolor{stringliteral}{"pass"}, 1, \textcolor{stringliteral}{"Pass to execute (1/2)"});
148 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t fpf\_name =
149     ARG\_DEF(NULL, \textcolor{stringliteral}{"fpf"}, 1, \textcolor{stringliteral}{"First pass statistics file name"});
150 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
151 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t fpmbf\_name =
152     ARG\_DEF(NULL, \textcolor{stringliteral}{"fpmbf"}, 1, \textcolor{stringliteral}{"First pass block statistics file name"});
153 \textcolor{preprocessor}{#endif}
154 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t limit =
155     ARG\_DEF(NULL, \textcolor{stringliteral}{"limit"}, 1, \textcolor{stringliteral}{"Stop encoding after n input frames"});
156 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t skip =
157     ARG\_DEF(NULL, \textcolor{stringliteral}{"skip"}, 1, \textcolor{stringliteral}{"Skip the first n input frames"});
158 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t good\_dl =
159     ARG\_DEF(NULL, \textcolor{stringliteral}{"good"}, 0, \textcolor{stringliteral}{"Use Good Quality Deadline"});
160 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t quietarg =
161     ARG\_DEF(\textcolor{stringliteral}{"q"}, \textcolor{stringliteral}{"quiet"}, 0, \textcolor{stringliteral}{"Do not print encode progress"});
162 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t verbosearg =
163     ARG\_DEF(\textcolor{stringliteral}{"v"}, \textcolor{stringliteral}{"verbose"}, 0, \textcolor{stringliteral}{"Show encoder parameters"});
164 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t psnrarg =
165     ARG\_DEF(NULL, \textcolor{stringliteral}{"psnr"}, 0, \textcolor{stringliteral}{"Show PSNR in status line"});
166 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
167 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_cfg = ARG\_DEF(\textcolor{stringliteral}{"c"}, \textcolor{stringliteral}{"cfg"}, 1, \textcolor{stringliteral}{"Config file to use"});
168 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t ext\_partition =
169     ARG\_DEF(NULL, \textcolor{stringliteral}{"ext-partition"}, 1, \textcolor{stringliteral}{"corresponds to extended partitions"});
170 \textcolor{preprocessor}{#endif}
171 
172 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list test\_decode\_enum[] = \{
173     \{ \textcolor{stringliteral}{"off"}, TEST\_DECODE\_OFF \},
174     \{ \textcolor{stringliteral}{"fatal"}, TEST\_DECODE\_FATAL \},
175     \{ \textcolor{stringliteral}{"warn"}, TEST\_DECODE\_WARN \},
176     \{ NULL, 0 \}
177 \};
178 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t recontest = ARG\_DEF\_ENUM(
179     NULL, \textcolor{stringliteral}{"test-decode"}, 1, \textcolor{stringliteral}{"Test encode/decode mismatch"}, test\_decode\_enum);
180 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t framerate =
181     ARG\_DEF(NULL, \textcolor{stringliteral}{"fps"}, 1, \textcolor{stringliteral}{"Stream frame rate (rate/scale)"});
182 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_webm =
183     ARG\_DEF(NULL, \textcolor{stringliteral}{"webm"}, 0, \textcolor{stringliteral}{"Output WebM (default when WebM IO is enabled)"});
184 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_ivf = ARG\_DEF(NULL, \textcolor{stringliteral}{"ivf"}, 0, \textcolor{stringliteral}{"Output IVF"});
185 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_obu = ARG\_DEF(NULL, \textcolor{stringliteral}{"obu"}, 0, \textcolor{stringliteral}{"Output OBU"});
186 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t q\_hist\_n =
187     ARG\_DEF(NULL, \textcolor{stringliteral}{"q-hist"}, 1, \textcolor{stringliteral}{"Show quantizer histogram (n-buckets)"});
188 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t rate\_hist\_n =
189     ARG\_DEF(NULL, \textcolor{stringliteral}{"rate-hist"}, 1, \textcolor{stringliteral}{"Show rate histogram (n-buckets)"});
190 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t disable\_warnings =
191     ARG\_DEF(NULL, \textcolor{stringliteral}{"disable-warnings"}, 0,
192         \textcolor{stringliteral}{"Disable warnings about potentially incorrect encode settings."});
193 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t disable\_warning\_prompt =
194     ARG\_DEF(\textcolor{stringliteral}{"y"}, \textcolor{stringliteral}{"disable-warning-prompt"}, 0,
195         \textcolor{stringliteral}{"Display warnings, but do not prompt user to continue."});
196 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list bitdepth\_enum[] = \{
197     \{ \textcolor{stringliteral}{"8"}, \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8} \}, \{ \textcolor{stringliteral}{"10"}, \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a91734384f432233c3d681052122ab8e7}{AOM\_BITS\_10} \}, \{ \textcolor{stringliteral}{"12"}, 
      \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a15836a87f9e9940885d5ef59a52bf728}{AOM\_BITS\_12} \}, \{ NULL, 0 \}
198 \};
199 
200 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t bitdeptharg = ARG\_DEF\_ENUM(
201     \textcolor{stringliteral}{"b"}, \textcolor{stringliteral}{"bit-depth"}, 1,
202     \textcolor{stringliteral}{"Bit depth for codec (8 for version <=1, 10 or 12 for version 2)"},
203     bitdepth\_enum);
204 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t inbitdeptharg =
205     ARG\_DEF(NULL, \textcolor{stringliteral}{"input-bit-depth"}, 1, \textcolor{stringliteral}{"Bit depth of input"});
206 
207 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_chroma\_subsampling\_x = ARG\_DEF(
208     NULL, \textcolor{stringliteral}{"input-chroma-subsampling-x"}, 1, \textcolor{stringliteral}{"chroma subsampling x value."});
209 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_chroma\_subsampling\_y = ARG\_DEF(
210     NULL, \textcolor{stringliteral}{"input-chroma-subsampling-y"}, 1, \textcolor{stringliteral}{"chroma subsampling y value."});
211 
212 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *main\_args[] = \{ &help,
213 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
214     &use\_cfg,
215 \textcolor{preprocessor}{#endif}
216     &debugmode,
217     &outputfile,
218     &codecarg,
219     &passes,
220     &pass\_arg,
221     &fpf\_name,
222     &limit,
223     &skip,
224     &good\_dl,
225     &quietarg,
226     &verbosearg,
227     &psnrarg,
228     &use\_webm,
229     &use\_ivf,
230     &use\_obu,
231     &q\_hist\_n,
232     &rate\_hist\_n,
233     &disable\_warnings,
234     &disable\_warning\_prompt,
235     &recontest,
236     NULL \};
237 
238 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t usage =
239     ARG\_DEF(\textcolor{stringliteral}{"u"}, \textcolor{stringliteral}{"usage"}, 1, \textcolor{stringliteral}{"Usage profile number to use"});
240 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t threads =
241     ARG\_DEF(\textcolor{stringliteral}{"t"}, \textcolor{stringliteral}{"threads"}, 1, \textcolor{stringliteral}{"Max number of threads to use"});
242 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t profile =
243     ARG\_DEF(NULL, \textcolor{stringliteral}{"profile"}, 1, \textcolor{stringliteral}{"Bitstream profile number to use"});
244 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t width = ARG\_DEF(\textcolor{stringliteral}{"w"}, \textcolor{stringliteral}{"width"}, 1, \textcolor{stringliteral}{"Frame width"});
245 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t height = ARG\_DEF(\textcolor{stringliteral}{"h"}, \textcolor{stringliteral}{"height"}, 1, \textcolor{stringliteral}{"Frame height"});
246 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t forced\_max\_frame\_width = ARG\_DEF(
247     NULL, \textcolor{stringliteral}{"forced\_max\_frame\_width"}, 0, \textcolor{stringliteral}{"Maximum frame width value to force"});
248 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t forced\_max\_frame\_height = ARG\_DEF(
249     NULL, \textcolor{stringliteral}{"forced\_max\_frame\_height"}, 0, \textcolor{stringliteral}{"Maximum frame height value to force"});
250 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
251 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list stereo\_mode\_enum[] = \{
252     \{ \textcolor{stringliteral}{"mono"}, STEREO\_FORMAT\_MONO \},
253     \{ \textcolor{stringliteral}{"left-right"}, STEREO\_FORMAT\_LEFT\_RIGHT \},
254     \{ \textcolor{stringliteral}{"bottom-top"}, STEREO\_FORMAT\_BOTTOM\_TOP \},
255     \{ \textcolor{stringliteral}{"top-bottom"}, STEREO\_FORMAT\_TOP\_BOTTOM \},
256     \{ \textcolor{stringliteral}{"right-left"}, STEREO\_FORMAT\_RIGHT\_LEFT \},
257     \{ NULL, 0 \}
258 \};
259 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t stereo\_mode = ARG\_DEF\_ENUM(
260     NULL, \textcolor{stringliteral}{"stereo-mode"}, 1, \textcolor{stringliteral}{"Stereo 3D video format"}, stereo\_mode\_enum);
261 \textcolor{preprocessor}{#endif}
262 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t timebase = ARG\_DEF(
263     NULL, \textcolor{stringliteral}{"timebase"}, 1, \textcolor{stringliteral}{"Output timestamp precision (fractional seconds)"});
264 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t global\_error\_resilient =
265     ARG\_DEF(NULL, \textcolor{stringliteral}{"global-error-resilient"}, 1,
266         \textcolor{stringliteral}{"Enable global error resiliency features"});
267 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t lag\_in\_frames =
268     ARG\_DEF(NULL, \textcolor{stringliteral}{"lag-in-frames"}, 1, \textcolor{stringliteral}{"Max number of frames to lag"});
269 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t large\_scale\_tile =
270     ARG\_DEF(NULL, \textcolor{stringliteral}{"large-scale-tile"}, 1,
271         \textcolor{stringliteral}{"Large scale tile coding (0: off (default), 1: on)"});
272 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t monochrome =
273     ARG\_DEF(NULL, \textcolor{stringliteral}{"monochrome"}, 0, \textcolor{stringliteral}{"Monochrome video (no chroma planes)"});
274 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t full\_still\_picture\_hdr = ARG\_DEF(
275     NULL, \textcolor{stringliteral}{"full-still-picture-hdr"}, 0, \textcolor{stringliteral}{"Use full header for still picture"});
276 
277 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *global\_args[] = \{ &use\_yv12,
278     &use\_i420,
279     &use\_i422,
280     &use\_i444,
281     &usage,
282     &threads,
283     &profile,
284     &width,
285     &height,
286     &forced\_max\_frame\_width,
287     &forced\_max\_frame\_height,
288 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
289     &stereo\_mode,
290 \textcolor{preprocessor}{#endif}
291     &timebase,
292     &framerate,
293     &global\_error\_resilient,
294     &bitdeptharg,
295     &lag\_in\_frames,
296     &large\_scale\_tile,
297     &monochrome,
298     &full\_still\_picture\_hdr,
299     NULL \};
300 
301 
302 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t sparse\_coding = ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-sparse"}, 0,
303     \textcolor{stringliteral}{"Enable sparse coding(0: false (default), 1: true)"});
304 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t k\_codewords = ARG\_DEF(
305     NULL, \textcolor{stringliteral}{"k-codewords"}, 1, \textcolor{stringliteral}{"Number of K-Codewords for sparse Coding, default is 512"});
306 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t train\_dict = ARG\_DEF(
307     NULL, \textcolor{stringliteral}{"train-dict"}, 1, \textcolor{stringliteral}{"Training Dictionary each n frames"});
308 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t iterations = ARG\_DEF(
309     NULL, \textcolor{stringliteral}{"iterations"}, 1, \textcolor{stringliteral}{"Number of iterations for batch OMP"});
310 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t sparse\_depth = ARG\_DEF(
311     NULL, \textcolor{stringliteral}{"sparse-depth"}, 1, \textcolor{stringliteral}{"Block partition depth for sparse (0=8x8, 1=16x16, 2=32x32, 3=64x64)"});
312 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list dictionary\_enum[] = \{
313     \{ \textcolor{stringliteral}{"random"}, RANDOM \},
314     \{ \textcolor{stringliteral}{"k-svd"}, K\_SVD \},
315     \{ NULL, 0 \}
316 \};
317 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t  dict\_alg = ARG\_DEF\_ENUM(
318     NULL, \textcolor{stringliteral}{"dict-alg"}, 1, \textcolor{stringliteral}{"Dictionary Learning algorithm (default random)"}, dictionary\_enum);
319 
320 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *sparse\_args[] = \{ &sparse\_coding,
321     &k\_codewords,
322     &train\_dict,
323     &dict\_alg,
324     &iterations,
325     &sparse\_depth,
326     NULL \};
327 
328 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t dropframe\_thresh =
329     ARG\_DEF(NULL, \textcolor{stringliteral}{"drop-frame"}, 1, \textcolor{stringliteral}{"Temporal resampling threshold (buf %)"});
330 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t resize\_mode =
331     ARG\_DEF(NULL, \textcolor{stringliteral}{"resize-mode"}, 1, \textcolor{stringliteral}{"Frame resize mode"});
332 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t resize\_denominator =
333     ARG\_DEF(NULL, \textcolor{stringliteral}{"resize-denominator"}, 1, \textcolor{stringliteral}{"Frame resize denominator"});
334 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t resize\_kf\_denominator = ARG\_DEF(
335     NULL, \textcolor{stringliteral}{"resize-kf-denominator"}, 1, \textcolor{stringliteral}{"Frame resize keyframe denominator"});
336 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_mode =
337     ARG\_DEF(NULL, \textcolor{stringliteral}{"superres-mode"}, 1, \textcolor{stringliteral}{"Frame super-resolution mode"});
338 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_denominator = ARG\_DEF(
339     NULL, \textcolor{stringliteral}{"superres-denominator"}, 1, \textcolor{stringliteral}{"Frame super-resolution denominator"});
340 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_kf\_denominator =
341     ARG\_DEF(NULL, \textcolor{stringliteral}{"superres-kf-denominator"}, 1,
342         \textcolor{stringliteral}{"Frame super-resolution keyframe denominator"});
343 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_qthresh = ARG\_DEF(
344     NULL, \textcolor{stringliteral}{"superres-qthresh"}, 1, \textcolor{stringliteral}{"Frame super-resolution qindex threshold"});
345 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_kf\_qthresh =
346     ARG\_DEF(NULL, \textcolor{stringliteral}{"superres-kf-qthresh"}, 1,
347         \textcolor{stringliteral}{"Frame super-resolution keyframe qindex threshold"});
348 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list end\_usage\_enum[] = \{ \{ \textcolor{stringliteral}{"vbr"}, \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957a7d3a2574737ea63d0f160ffdbd7f0110}{AOM\_VBR} \},
349     \{ \textcolor{stringliteral}{"cbr"}, \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957a14b6057d61c61e6117f5af16dcf89b0c}{AOM\_CBR} \},
350     \{ \textcolor{stringliteral}{"cq"}, \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957a70aa1f15e91f6576ba3e63879947be64}{AOM\_CQ} \},
351     \{ \textcolor{stringliteral}{"q"}, \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957aff3bbd4fe870b4b946c2093e59eb14e5}{AOM\_Q} \},
352     \{ NULL, 0 \} \};
353 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t end\_usage =
354     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"end-usage"}, 1, \textcolor{stringliteral}{"Rate control mode"}, end\_usage\_enum);
355 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t target\_bitrate =
356     ARG\_DEF(NULL, \textcolor{stringliteral}{"target-bitrate"}, 1, \textcolor{stringliteral}{"Bitrate (kbps)"});
357 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t min\_quantizer =
358     ARG\_DEF(NULL, \textcolor{stringliteral}{"min-q"}, 1, \textcolor{stringliteral}{"Minimum (best) quantizer"});
359 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_quantizer =
360     ARG\_DEF(NULL, \textcolor{stringliteral}{"max-q"}, 1, \textcolor{stringliteral}{"Maximum (worst) quantizer"});
361 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t undershoot\_pct =
362     ARG\_DEF(NULL, \textcolor{stringliteral}{"undershoot-pct"}, 1, \textcolor{stringliteral}{"Datarate undershoot (min) target (%)"});
363 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t overshoot\_pct =
364     ARG\_DEF(NULL, \textcolor{stringliteral}{"overshoot-pct"}, 1, \textcolor{stringliteral}{"Datarate overshoot (max) target (%)"});
365 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t buf\_sz =
366     ARG\_DEF(NULL, \textcolor{stringliteral}{"buf-sz"}, 1, \textcolor{stringliteral}{"Client buffer size (ms)"});
367 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t buf\_initial\_sz =
368     ARG\_DEF(NULL, \textcolor{stringliteral}{"buf-initial-sz"}, 1, \textcolor{stringliteral}{"Client initial buffer size (ms)"});
369 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t buf\_optimal\_sz =
370     ARG\_DEF(NULL, \textcolor{stringliteral}{"buf-optimal-sz"}, 1, \textcolor{stringliteral}{"Client optimal buffer size (ms)"});
371 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *rc\_args[] = \{ &dropframe\_thresh,
372     &resize\_mode,
373     &resize\_denominator,
374     &resize\_kf\_denominator,
375     &superres\_mode,
376     &superres\_denominator,
377     &superres\_kf\_denominator,
378     &superres\_qthresh,
379     &superres\_kf\_qthresh,
380     &end\_usage,
381     &target\_bitrate,
382     &min\_quantizer,
383     &max\_quantizer,
384     &undershoot\_pct,
385     &overshoot\_pct,
386     &buf\_sz,
387     &buf\_initial\_sz,
388     &buf\_optimal\_sz,
389     NULL \};
390 
391 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t bias\_pct =
392     ARG\_DEF(NULL, \textcolor{stringliteral}{"bias-pct"}, 1, \textcolor{stringliteral}{"CBR/VBR bias (0=CBR, 100=VBR)"});
393 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t minsection\_pct =
394     ARG\_DEF(NULL, \textcolor{stringliteral}{"minsection-pct"}, 1, \textcolor{stringliteral}{"GOP min bitrate (% of target)"});
395 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t maxsection\_pct =
396     ARG\_DEF(NULL, \textcolor{stringliteral}{"maxsection-pct"}, 1, \textcolor{stringliteral}{"GOP max bitrate (% of target)"});
397 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *rc\_twopass\_args[] = \{ &bias\_pct, &minsection\_pct,
398     &maxsection\_pct, NULL \};
399 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t fwd\_kf\_enabled =
400     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-fwd-kf"}, 1, \textcolor{stringliteral}{"Enable forward reference keyframes"});
401 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t kf\_min\_dist =
402     ARG\_DEF(NULL, \textcolor{stringliteral}{"kf-min-dist"}, 1, \textcolor{stringliteral}{"Minimum keyframe interval (frames)"});
403 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t kf\_max\_dist =
404     ARG\_DEF(NULL, \textcolor{stringliteral}{"kf-max-dist"}, 1, \textcolor{stringliteral}{"Maximum keyframe interval (frames)"});
405 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t kf\_disabled =
406     ARG\_DEF(NULL, \textcolor{stringliteral}{"disable-kf"}, 0, \textcolor{stringliteral}{"Disable keyframe placement"});
407 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *kf\_args[] = \{ &fwd\_kf\_enabled, &kf\_min\_dist,
408     &kf\_max\_dist, &kf\_disabled, NULL \};
409 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t sframe\_dist =
410     ARG\_DEF(NULL, \textcolor{stringliteral}{"sframe-dist"}, 1, \textcolor{stringliteral}{"S-Frame interval (frames)"});
411 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t sframe\_mode =
412     ARG\_DEF(NULL, \textcolor{stringliteral}{"sframe-mode"}, 1, \textcolor{stringliteral}{"S-Frame insertion mode (1..2)"});
413 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t save\_as\_annexb =
414     ARG\_DEF(NULL, \textcolor{stringliteral}{"annexb"}, 1, \textcolor{stringliteral}{"Save as Annex-B"});
415 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t noise\_sens =
416     ARG\_DEF(NULL, \textcolor{stringliteral}{"noise-sensitivity"}, 1, \textcolor{stringliteral}{"Noise sensitivity (frames to blur)"});
417 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t sharpness =
418     ARG\_DEF(NULL, \textcolor{stringliteral}{"sharpness"}, 1, \textcolor{stringliteral}{"Loop filter sharpness (0..7)"});
419 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t static\_thresh =
420     ARG\_DEF(NULL, \textcolor{stringliteral}{"static-thresh"}, 1, \textcolor{stringliteral}{"Motion detection threshold"});
421 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t auto\_altref =
422     ARG\_DEF(NULL, \textcolor{stringliteral}{"auto-alt-ref"}, 1, \textcolor{stringliteral}{"Enable automatic alt reference frames"});
423 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t arnr\_maxframes =
424     ARG\_DEF(NULL, \textcolor{stringliteral}{"arnr-maxframes"}, 1, \textcolor{stringliteral}{"AltRef max frames (0..15)"});
425 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t arnr\_strength =
426     ARG\_DEF(NULL, \textcolor{stringliteral}{"arnr-strength"}, 1, \textcolor{stringliteral}{"AltRef filter strength (0..6)"});
427 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list tuning\_enum[] = \{
428     \{ \textcolor{stringliteral}{"psnr"}, AOM\_TUNE\_PSNR \},
429     \{ \textcolor{stringliteral}{"ssim"}, AOM\_TUNE\_SSIM \},
430 \textcolor{preprocessor}{#ifdef CONFIG\_DIST\_8X8}
431     \{ \textcolor{stringliteral}{"cdef-dist"}, AOM\_TUNE\_CDEF\_DIST \},
432     \{ \textcolor{stringliteral}{"daala-dist"}, AOM\_TUNE\_DAALA\_DIST \},
433 \textcolor{preprocessor}{#endif}
434     \{ NULL, 0 \}
435 \};
436 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tune\_metric =
437     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"tune"}, 1, \textcolor{stringliteral}{"Distortion metric tuned with"}, tuning\_enum);
438 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t cq\_level =
439     ARG\_DEF(NULL, \textcolor{stringliteral}{"cq-level"}, 1, \textcolor{stringliteral}{"Constant/Constrained Quality level"});
440 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_intra\_rate\_pct =
441     ARG\_DEF(NULL, \textcolor{stringliteral}{"max-intra-rate"}, 1, \textcolor{stringliteral}{"Max I-frame bitrate (pct)"});
442 
443 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
444 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t cpu\_used\_av1 =
445     ARG\_DEF(NULL, \textcolor{stringliteral}{"cpu-used"}, 1, \textcolor{stringliteral}{"CPU Used (0..8)"});
446 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t rowmtarg =
447     ARG\_DEF(NULL, \textcolor{stringliteral}{"row-mt"}, 1,
448         \textcolor{stringliteral}{"Enable row based multi-threading (0: off (default), 1: on)"});
449 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_cols =
450     ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-columns"}, 1, \textcolor{stringliteral}{"Number of tile columns to use, log2"});
451 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_rows =
452     ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-rows"}, 1, \textcolor{stringliteral}{"Number of tile rows to use, log2"});
453 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_tpl\_model =
454     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-tpl-model"}, 1,
455         \textcolor{stringliteral}{"RDO modulation based on frame temporal dependency"});
456 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_width =
457     ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-width"}, 1, \textcolor{stringliteral}{"Tile widths (comma separated)"});
458 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_height =
459     ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-height"}, 1, \textcolor{stringliteral}{"Tile heights (command separated)"});
460 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t lossless =
461     ARG\_DEF(NULL, \textcolor{stringliteral}{"lossless"}, 1, \textcolor{stringliteral}{"Lossless mode (0: false (default), 1: true)"});
462 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_cdef =
463     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-cdef"}, 1,
464         \textcolor{stringliteral}{"Enable the constrained directional enhancement filter (0: false, "}
465         \textcolor{stringliteral}{"1: true (default))"});
466 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_restoration =
467     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-restoration"}, 1,
468         \textcolor{stringliteral}{"Enable the loop restoration filter (0: false, "}
469         \textcolor{stringliteral}{"1: true (default))"});
470 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t disable\_trellis\_quant =
471     ARG\_DEF(NULL, \textcolor{stringliteral}{"disable-trellis-quant"}, 1,
472         \textcolor{stringliteral}{"Disable trellis optimization of quantized coefficients (0: false ("}
473         \textcolor{stringliteral}{"default) 1: true)"});
474 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_qm =
475     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-qm"}, 1,
476         \textcolor{stringliteral}{"Enable quantisation matrices (0: false (default), 1: true)"});
477 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t qm\_min = ARG\_DEF(
478     NULL, \textcolor{stringliteral}{"qm-min"}, 1, \textcolor{stringliteral}{"Min quant matrix flatness (0..15), default is 8"});
479 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t qm\_max = ARG\_DEF(
480     NULL, \textcolor{stringliteral}{"qm-max"}, 1, \textcolor{stringliteral}{"Max quant matrix flatness (0..15), default is 15"});
481 \textcolor{preprocessor}{#if CONFIG\_DIST\_8X8}
482 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_dist\_8x8 =
483     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-dist-8x8"}, 1,
484         \textcolor{stringliteral}{"Enable dist-8x8 (0: false (default), 1: true)"});
485 \textcolor{preprocessor}{#endif  // CONFIG\_DIST\_8X8}
486 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t num\_tg = ARG\_DEF(
487     NULL, \textcolor{stringliteral}{"num-tile-groups"}, 1, \textcolor{stringliteral}{"Maximum number of tile groups, default is 1"});
488 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t mtu\_size =
489     ARG\_DEF(NULL, \textcolor{stringliteral}{"mtu-size"}, 1,
490         \textcolor{stringliteral}{"MTU size for a tile group, default is 0 (no MTU targeting), "}
491         \textcolor{stringliteral}{"overrides maximum number of tile groups"});
492 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list timing\_info\_enum[] = \{
493     \{ \textcolor{stringliteral}{"unspecified"}, AOM\_TIMING\_UNSPECIFIED \},
494     \{ \textcolor{stringliteral}{"constant"}, AOM\_TIMING\_EQUAL \},
495     \{ \textcolor{stringliteral}{"model"}, AOM\_TIMING\_DEC\_MODEL \},
496     \{ NULL, 0 \}
497 \};
498 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t timing\_info =
499     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"timing-info"}, 1,
500         \textcolor{stringliteral}{"Signal timing info in the bitstream (model unly works for no "}
501         \textcolor{stringliteral}{"hidden frames, no super-res yet):"},
502         timing\_info\_enum);
503 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t film\_grain\_test =
504     ARG\_DEF(NULL, \textcolor{stringliteral}{"film-grain-test"}, 1,
505         \textcolor{stringliteral}{"Film grain test vectors (0: none (default), 1: test-1  2: test-2, "}
506         \textcolor{stringliteral}{"... 16: test-16)"});
507 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t film\_grain\_table =
508     ARG\_DEF(NULL, \textcolor{stringliteral}{"film-grain-table"}, 1,
509         \textcolor{stringliteral}{"Path to file containing film grain parameters"});
510 \textcolor{preprocessor}{#if CONFIG\_DENOISE}
511 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t denoise\_noise\_level =
512     ARG\_DEF(NULL, \textcolor{stringliteral}{"denoise-noise-level"}, 1,
513         \textcolor{stringliteral}{"Amount of noise (from 0 = don't denoise, to 50)"});
514 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t denoise\_block\_size =
515     ARG\_DEF(NULL, \textcolor{stringliteral}{"denoise-block-size"}, 1, \textcolor{stringliteral}{"Denoise block size (default = 32)"});
516 \textcolor{preprocessor}{#endif}
517 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_ref\_frame\_mvs =
518     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-ref-frame-mvs"}, 1,
519         \textcolor{stringliteral}{"Enable temporal mv prediction (default is 1)"});
520 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t frame\_parallel\_decoding =
521     ARG\_DEF(NULL, \textcolor{stringliteral}{"frame-parallel"}, 1,
522         \textcolor{stringliteral}{"Enable frame parallel decodability features "}
523         \textcolor{stringliteral}{"(0: false (default), 1: true)"});
524 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t error\_resilient\_mode =
525     ARG\_DEF(NULL, \textcolor{stringliteral}{"error-resilient"}, 1,
526         \textcolor{stringliteral}{"Enable error resilient features "}
527         \textcolor{stringliteral}{"(0: false (default), 1: true)"});
528 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t aq\_mode = ARG\_DEF(
529     NULL, \textcolor{stringliteral}{"aq-mode"}, 1,
530     \textcolor{stringliteral}{"Adaptive quantization mode (0: off (default), 1: variance 2: complexity, "}
531     \textcolor{stringliteral}{"3: cyclic refresh)"});
532 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t deltaq\_mode = ARG\_DEF(
533     NULL, \textcolor{stringliteral}{"deltaq-mode"}, 1,
534     \textcolor{stringliteral}{"Delta qindex mode (0: off (default), 1: deltaq 2: deltaq + deltalf)"});
535 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t frame\_periodic\_boost =
536     ARG\_DEF(NULL, \textcolor{stringliteral}{"frame-boost"}, 1,
537         \textcolor{stringliteral}{"Enable frame periodic boost (0: off (default), 1: on)"});
538 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t gf\_cbr\_boost\_pct = ARG\_DEF(
539     NULL, \textcolor{stringliteral}{"gf-cbr-boost"}, 1, \textcolor{stringliteral}{"Boost for Golden Frame in CBR mode (pct)"});
540 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_inter\_rate\_pct =
541     ARG\_DEF(NULL, \textcolor{stringliteral}{"max-inter-rate"}, 1, \textcolor{stringliteral}{"Max P-frame bitrate (pct)"});
542 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t min\_gf\_interval = ARG\_DEF(
543     NULL, \textcolor{stringliteral}{"min-gf-interval"}, 1,
544     \textcolor{stringliteral}{"min gf/arf frame interval (default 0, indicating in-built behavior)"});
545 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_gf\_interval = ARG\_DEF(
546     NULL, \textcolor{stringliteral}{"max-gf-interval"}, 1,
547     \textcolor{stringliteral}{"max gf/arf frame interval (default 0, indicating in-built behavior)"});
548 
549 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list color\_primaries\_enum[] = \{
550     \{ \textcolor{stringliteral}{"bt709"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa9a2ebe055c0508a2a2f72b6c192fcce9}{AOM\_CICP\_CP\_BT\_709} \},
551     \{ \textcolor{stringliteral}{"unspecified"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa0835a3af8e6ffc6df298b6e64f878431}{AOM\_CICP\_CP\_UNSPECIFIED} \},
552     \{ \textcolor{stringliteral}{"bt601"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa3ce81eb125550ec2f11a58f183eeaee6}{AOM\_CICP\_CP\_BT\_601} \},
553     \{ \textcolor{stringliteral}{"bt470m"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa5b57cb26f04f4df6585335129392d5e2}{AOM\_CICP\_CP\_BT\_470\_M} \},
554     \{ \textcolor{stringliteral}{"bt470bg"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa8b33dc8483c16048c606d75d9f11e38a}{AOM\_CICP\_CP\_BT\_470\_B\_G} \},
555     \{ \textcolor{stringliteral}{"smpte240"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa1a8b2e5694489121f80a406d9da25dfb}{AOM\_CICP\_CP\_SMPTE\_240} \},
556     \{ \textcolor{stringliteral}{"film"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa8dd6ba5106c22d149a233e73232aeb65}{AOM\_CICP\_CP\_GENERIC\_FILM} \},
557     \{ \textcolor{stringliteral}{"bt2020"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa6bb95baf09cd6e1f3596b459712c592a}{AOM\_CICP\_CP\_BT\_2020} \},
558     \{ \textcolor{stringliteral}{"xyz"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa6032cae72a729933a6a75e3b943a542c}{AOM\_CICP\_CP\_XYZ} \},
559     \{ \textcolor{stringliteral}{"smpte431"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa54d519c9ac0ca52ebda7caf736530e57}{AOM\_CICP\_CP\_SMPTE\_431} \},
560     \{ \textcolor{stringliteral}{"smpte432"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa227b6e4116ed0266af20b705aebaf661}{AOM\_CICP\_CP\_SMPTE\_432} \},
561     \{ \textcolor{stringliteral}{"ebu3213"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa9e74dcb338953bfab3101aa33ea44157}{AOM\_CICP\_CP\_EBU\_3213} \},
562     \{ NULL, 0 \}
563 \};
564 
565 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_color\_primaries = ARG\_DEF\_ENUM(
566     NULL, \textcolor{stringliteral}{"color-primaries"}, 1,
567     \textcolor{stringliteral}{"Color primaries (CICP) of input content:"}, color\_primaries\_enum);
568 
569 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list transfer\_characteristics\_enum[] = \{
570     \{ \textcolor{stringliteral}{"unspecified"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa0835a3af8e6ffc6df298b6e64f878431}{AOM\_CICP\_CP\_UNSPECIFIED} \},
571     \{ \textcolor{stringliteral}{"bt709"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992affe340e422646b7d70ef91edd6a8053c}{AOM\_CICP\_TC\_BT\_709} \},
572     \{ \textcolor{stringliteral}{"bt470m"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a356d6943d11d88e7a42370c1c698c214}{AOM\_CICP\_TC\_BT\_470\_M} \},
573     \{ \textcolor{stringliteral}{"bt470bg"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a7a347c6d5605db0a6ee89cc81dec0b37}{AOM\_CICP\_TC\_BT\_470\_B\_G} \},
574     \{ \textcolor{stringliteral}{"bt601"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a5b51bfcf0f3779a7d907ac45ee4067a4}{AOM\_CICP\_TC\_BT\_601} \},
575     \{ \textcolor{stringliteral}{"smpte240"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992ac3b5e95e3400830c334268fca69a1226}{AOM\_CICP\_TC\_SMPTE\_240} \},
576     \{ \textcolor{stringliteral}{"lin"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a99ebdb0b1a35e0bf25808f851aa80a35}{AOM\_CICP\_TC\_LINEAR} \},
577     \{ \textcolor{stringliteral}{"log100"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a54ec8cfad46215d855696bafe371ffe1}{AOM\_CICP\_TC\_LOG\_100} \},
578     \{ \textcolor{stringliteral}{"log100sq10"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a7d79c257042a5958bafa6b5ccfbd96cb}{AOM\_CICP\_TC\_LOG\_100\_SQRT10} \},
579     \{ \textcolor{stringliteral}{"iec61966"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a57f92f410badf8a43b19df18edc9b8b9}{AOM\_CICP\_TC\_IEC\_61966} \},
580     \{ \textcolor{stringliteral}{"bt1361"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992ac60ca749a2d0ca1c860d82f0825a3e2d}{AOM\_CICP\_TC\_BT\_1361} \},
581     \{ \textcolor{stringliteral}{"srgb"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a94553e773e3d3fb005236ed70eeedfea}{AOM\_CICP\_TC\_SRGB} \},
582     \{ \textcolor{stringliteral}{"bt2020-10bit"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a1ce5fbca5277266680d70bb7211646d6}{AOM\_CICP\_TC\_BT\_2020\_10\_BIT} \},
583     \{ \textcolor{stringliteral}{"bt2020-12bit"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992afcc74c6858aefc13c426dd6992198e75}{AOM\_CICP\_TC\_BT\_2020\_12\_BIT} \},
584     \{ \textcolor{stringliteral}{"smpte2084"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992ab48fdcc8c2c0350f6423b9c116c1876d}{AOM\_CICP\_TC\_SMPTE\_2084} \},
585     \{ \textcolor{stringliteral}{"hlg"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a3d7b83c425c539d1a36fb36e9aebf268}{AOM\_CICP\_TC\_HLG} \},
586     \{ \textcolor{stringliteral}{"smpte428"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a45df590313483af0c614708f346028c4}{AOM\_CICP\_TC\_SMPTE\_428} \},
587     \{ NULL, 0 \}
588 \};
589 
590 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_transfer\_characteristics =
591     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"transfer-characteristics"}, 1,
592         \textcolor{stringliteral}{"Transfer characteristics (CICP) of input content:"},
593         transfer\_characteristics\_enum);
594 
595 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list matrix\_coefficients\_enum[] = \{
596     \{ \textcolor{stringliteral}{"identity"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a17489bf0aed544427f7c6bbe4837b212}{AOM\_CICP\_MC\_IDENTITY} \},
597     \{ \textcolor{stringliteral}{"bt709"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081aa70fd9b88bc91bd0d126aaa07421c49a}{AOM\_CICP\_MC\_BT\_709} \},
598     \{ \textcolor{stringliteral}{"unspecified"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a06a4defb1e5d9bb1d2aad092b8656a03}{AOM\_CICP\_MC\_UNSPECIFIED} \},
599     \{ \textcolor{stringliteral}{"fcc73"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081ae368663c2c2f34683b513e159c5738b9}{AOM\_CICP\_MC\_FCC} \},
600     \{ \textcolor{stringliteral}{"bt470bg"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081ae9107262b437659514abdcd928e977db}{AOM\_CICP\_MC\_BT\_470\_B\_G} \},
601     \{ \textcolor{stringliteral}{"bt601"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a0f81310501079cc1184d5265ae2c18a5}{AOM\_CICP\_MC\_BT\_601} \},
602     \{ \textcolor{stringliteral}{"smpte240"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa1a8b2e5694489121f80a406d9da25dfb}{AOM\_CICP\_CP\_SMPTE\_240} \},
603     \{ \textcolor{stringliteral}{"ycgco"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081aa2140164b26b42404c376cc921ce27c5}{AOM\_CICP\_MC\_SMPTE\_YCGCO} \},
604     \{ \textcolor{stringliteral}{"bt2020ncl"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081adf60aa79c6a68f4eb41e1095f8bf7bf6}{AOM\_CICP\_MC\_BT\_2020\_NCL} \},
605     \{ \textcolor{stringliteral}{"bt2020cl"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a34148eae7b467eece6af5c90405dde6b}{AOM\_CICP\_MC\_BT\_2020\_CL} \},
606     \{ \textcolor{stringliteral}{"smpte2085"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a3aeb0ed0afc0a92ce758f109cd05ee80}{AOM\_CICP\_MC\_SMPTE\_2085} \},
607     \{ \textcolor{stringliteral}{"chromncl"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a30661e9d9b70ffe9f51f3bdbfd02865b}{AOM\_CICP\_MC\_CHROMAT\_NCL} \},
608     \{ \textcolor{stringliteral}{"chromcl"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081aa391f9255e4775da0120f7472b417193}{AOM\_CICP\_MC\_CHROMAT\_CL} \},
609     \{ \textcolor{stringliteral}{"ictcp"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a7695b0577d3884a89c578f28f4237aee}{AOM\_CICP\_MC\_ICTCP} \},
610     \{ NULL, 0 \}
611 \};
612 
613 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_matrix\_coefficients = ARG\_DEF\_ENUM(
614     NULL, \textcolor{stringliteral}{"matrix-coefficients"}, 1,
615     \textcolor{stringliteral}{"Matrix coefficients (CICP) of input content:"}, matrix\_coefficients\_enum);
616 
617 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list chroma\_sample\_position\_enum[] = \{
618     \{ \textcolor{stringliteral}{"unknown"}, \hyperlink{aom__image_8h_a10590253ef3dbde7e93ed5d4b4e0e73ba7843506f3e28f720be0d4f03237fb48c}{AOM\_CSP\_UNKNOWN} \},
619     \{ \textcolor{stringliteral}{"vertical"}, \hyperlink{aom__image_8h_a10590253ef3dbde7e93ed5d4b4e0e73baf95ced9b8288642205301cc51e0b55c6}{AOM\_CSP\_VERTICAL} \},
620     \{ \textcolor{stringliteral}{"colocated"}, \hyperlink{aom__image_8h_a10590253ef3dbde7e93ed5d4b4e0e73ba01ef7204c2234ef43acfd493d5e18c84}{AOM\_CSP\_COLOCATED} \},
621     \{ NULL, 0 \}
622 \};
623 
624 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_chroma\_sample\_position =
625     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"chroma-sample-position"}, 1,
626         \textcolor{stringliteral}{"The chroma sample position when chroma 4:2:0 is signaled:"},
627         chroma\_sample\_position\_enum);
628 
629 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list tune\_content\_enum[] = \{
630     \{ \textcolor{stringliteral}{"default"}, AOM\_CONTENT\_DEFAULT \},
631     \{ \textcolor{stringliteral}{"screen"}, AOM\_CONTENT\_SCREEN \},
632     \{ NULL, 0 \}
633 \};
634 
635 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tune\_content = ARG\_DEF\_ENUM(
636     NULL, \textcolor{stringliteral}{"tune-content"}, 1, \textcolor{stringliteral}{"Tune content type"}, tune\_content\_enum);
637 
638 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t cdf\_update\_mode =
639     ARG\_DEF(NULL, \textcolor{stringliteral}{"cdf-update-mode"}, 1,
640         \textcolor{stringliteral}{"CDF update mode for entropy coding "}
641         \textcolor{stringliteral}{"(0: no CDF update; 1: update CDF on all frames(default); "}
642         \textcolor{stringliteral}{"2: selectively update CDF on some frames"});
643 
644 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list superblock\_size\_enum[] = \{
645     \{ \textcolor{stringliteral}{"dynamic"}, \hyperlink{group__codec_ggac34a24f7c6c0fef7518aed0da4425f61aaabb4d9ad771b2fa177ff6fb5437b179}{AOM\_SUPERBLOCK\_SIZE\_DYNAMIC} \},
646     \{ \textcolor{stringliteral}{"64"}, \hyperlink{group__codec_ggac34a24f7c6c0fef7518aed0da4425f61a5abd24080a18d4f7e33217d93a73e968}{AOM\_SUPERBLOCK\_SIZE\_64X64} \},
647     \{ \textcolor{stringliteral}{"128"}, \hyperlink{group__codec_ggac34a24f7c6c0fef7518aed0da4425f61a17127133dafcd42b1d792770981d67d0}{AOM\_SUPERBLOCK\_SIZE\_128X128} \},
648     \{ NULL, 0 \}
649 \};
650 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superblock\_size = ARG\_DEF\_ENUM(
651     NULL, \textcolor{stringliteral}{"sb-size"}, 1, \textcolor{stringliteral}{"Superblock size to use"}, superblock\_size\_enum);
652 
653 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *av1\_args[] = \{ &cpu\_used\_av1,
654     &auto\_altref,
655     &sharpness,
656     &static\_thresh,
657     &rowmtarg,
658     &tile\_cols,
659     &tile\_rows,
660     &enable\_tpl\_model,
661     &arnr\_maxframes,
662     &arnr\_strength,
663     &tune\_metric,
664     &cq\_level,
665     &max\_intra\_rate\_pct,
666     &max\_inter\_rate\_pct,
667     &gf\_cbr\_boost\_pct,
668     &lossless,
669     &enable\_cdef,
670     &enable\_restoration,
671     &disable\_trellis\_quant,
672     &enable\_qm,
673     &qm\_min,
674     &qm\_max,
675 \textcolor{preprocessor}{#if CONFIG\_DIST\_8X8}
676     &enable\_dist\_8x8,
677 \textcolor{preprocessor}{#endif}
678     &frame\_parallel\_decoding,
679     &error\_resilient\_mode,
680     &aq\_mode,
681     &deltaq\_mode,
682     &frame\_periodic\_boost,
683     &noise\_sens,
684     &tune\_content,
685     &cdf\_update\_mode,
686     &input\_color\_primaries,
687     &input\_transfer\_characteristics,
688     &input\_matrix\_coefficients,
689     &input\_chroma\_sample\_position,
690     &min\_gf\_interval,
691     &max\_gf\_interval,
692     &superblock\_size,
693     &num\_tg,
694     &mtu\_size,
695     &timing\_info,
696     &film\_grain\_test,
697     &film\_grain\_table,
698 \textcolor{preprocessor}{#if CONFIG\_DENOISE}
699     &denoise\_noise\_level,
700     &denoise\_block\_size,
701 \textcolor{preprocessor}{#endif}
702     &enable\_ref\_frame\_mvs,
703     &bitdeptharg,
704     &inbitdeptharg,
705     &input\_chroma\_subsampling\_x,
706     &input\_chroma\_subsampling\_y,
707     &sframe\_dist,
708     &sframe\_mode,
709     &save\_as\_annexb,
710     NULL \};
711 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} av1\_arg\_ctrl\_map[] = \{ \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5adac09e1a8da079b08fca5ccbf981f1a6}{AOME\_SET\_CPUUSED},
712     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF},
713     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a0df0d30e82bb9683f3131138dfa2949a}{AOME\_SET\_SHARPNESS},
714     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aa4f58f6a86b710e403daeac055738111}{AOME\_SET\_STATIC\_THRESHOLD},
715     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a095d0817d339940aa2578924a840fc84}{AV1E\_SET\_ROW\_MT},
716     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5acf4ab1ff2fa8d76a78881ad7f1a1294d}{AV1E\_SET\_TILE\_COLUMNS},
717     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a57f2f2a54f593b398a5e97db7982f817}{AV1E\_SET\_TILE\_ROWS},
718     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a174ffbc2e91a020a8225900e38894137}{AV1E\_SET\_ENABLE\_TPL\_MODEL},
719     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a327fb270f37bbb008b0f146542ce7483}{AOME\_SET\_ARNR\_MAXFRAMES},
720     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5affd2c213f24a12d13bb51e31be993e60}{AOME\_SET\_ARNR\_STRENGTH},
721     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aba539b6646278e7ff40f67f38639d294}{AOME\_SET\_TUNING},
722     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af67f265bf63bf8f1268b3a14ae26606c}{AOME\_SET\_CQ\_LEVEL},
723     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a9e1965ffa40d2d87556b65748c63adcc}{AOME\_SET\_MAX\_INTRA\_BITRATE\_PCT},
724     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a54b7c950e51f39a3cb7344a2665b9929}{AV1E\_SET\_MAX\_INTER\_BITRATE\_PCT},
725     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ade327180f01d27d22abd94c1f0a8bc9e}{AV1E\_SET\_GF\_CBR\_BOOST\_PCT},
726     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5afe875c6bb02f236be503c8c7b1f15875}{AV1E\_SET\_LOSSLESS},
727     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a6879fe104e23de00f034ed11eb605031}{AV1E\_SET\_ENABLE\_CDEF},
728     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a2ea70b4b379e701a4b3b7cc33eb05e65}{AV1E\_SET\_ENABLE\_RESTORATION},
729     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a374b5581d0b68d5f8cc3e3f73495cfbb}{AV1E\_SET\_DISABLE\_TRELLIS\_QUANT},
730     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ae63993934cdc5aa36efeec4df87a577e}{AV1E\_SET\_ENABLE\_QM},
731     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ae611944ba148b6446d4387dd9b452917}{AV1E\_SET\_QM\_MIN},
732     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad897674e1b68b24ec14a01a4e3edacc7}{AV1E\_SET\_QM\_MAX},
733 \textcolor{preprocessor}{#if CONFIG\_DIST\_8X8}
734     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a7ef16c780349c5fee8281f1e5b4a6718}{AV1E\_SET\_ENABLE\_DIST\_8X8},
735 \textcolor{preprocessor}{#endif}
736     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING},
737     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aa0d049453fced5f8079861b16e356c69}{AV1E\_SET\_ERROR\_RESILIENT\_MODE},
738     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a17bd297efc31082157785d68fc5a6067}{AV1E\_SET\_AQ\_MODE},
739     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad26eda6211bf3d5fe4f5999ec52b264b}{AV1E\_SET\_DELTAQ\_MODE},
740     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a737368591a37417b108c0706f7510885}{AV1E\_SET\_FRAME\_PERIODIC\_BOOST},
741     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a8d415cd6976ea5860206e1d3cd3dd222}{AV1E\_SET\_NOISE\_SENSITIVITY},
742     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a2625f566fd5c2675eb2bcd40af858652}{AV1E\_SET\_TUNE\_CONTENT},
743     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a277526a4a9b8c413e870ee17ff986e87}{AV1E\_SET\_CDF\_UPDATE\_MODE},
744     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af64e990728fe37287bac0874d77b22db}{AV1E\_SET\_COLOR\_PRIMARIES},
745     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a336fc3607a5987f9077c634f07b3cd53}{AV1E\_SET\_TRANSFER\_CHARACTERISTICS},
746     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a0111ed659d2cd11827ac5cd1f3d774b0}{AV1E\_SET\_MATRIX\_COEFFICIENTS},
747     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5abc5bb5cf57ba1a1193a0593225e881ff}{AV1E\_SET\_CHROMA\_SAMPLE\_POSITION},
748     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a31bcfcb7057884ceb831146c90086ddd}{AV1E\_SET\_MIN\_GF\_INTERVAL},
749     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a0355cea227ab76f9bd77028a39bbfca8}{AV1E\_SET\_MAX\_GF\_INTERVAL},
750     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a8854a06c62269e866d6bac0f3a2e3dc2}{AV1E\_SET\_SUPERBLOCK\_SIZE},
751     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a9ac0044ad63e6848a482db04f0858c44}{AV1E\_SET\_NUM\_TG},
752     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a353037d84b6c47ac0138fa843b70a2bb}{AV1E\_SET\_MTU},
753     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a857e822046c62a4c774b1d16c4e453dd}{AV1E\_SET\_TIMING\_INFO\_TYPE},
754     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a437e6b282a2395b4b08a9acde3e41cfb}{AV1E\_SET\_FILM\_GRAIN\_TEST\_VECTOR},
755     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad5846c6f49d37e65a03c39e68d487097}{AV1E\_SET\_FILM\_GRAIN\_TABLE},
756 \textcolor{preprocessor}{#if CONFIG\_DENOISE}
757     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a54fe460f126a7566aa627cd82826faf0}{AV1E\_SET\_DENOISE\_NOISE\_LEVEL},
758     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ae113c7e68a6c39b872a268ed6cdf6d10}{AV1E\_SET\_DENOISE\_BLOCK\_SIZE},
759 \textcolor{preprocessor}{#endif}
760     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a5e82346d8463bf758967abb0d03ebc88}{AV1E\_SET\_ENABLE\_REF\_FRAME\_MVS},
761     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ab2a89e85539e97b96e057cb063063c86}{AV1E\_SET\_ENABLE\_DF},
762     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad0eaf349d653c8357acbba84ad95d5e6}{AV1E\_SET\_ENABLE\_ORDER\_HINT},
763     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac5c0c60dc1b709c082da28feae3bcad3}{AV1E\_SET\_ENABLE\_JNT\_COMP},
764     \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a86e399de03aa825bb7e594e3df1bf71b}{AV1E\_SET\_ENABLE\_SUPERRES},
765     0 \};
766 \textcolor{preprocessor}{#endif  // CONFIG\_AV1\_ENCODER}
767 
768 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *no\_args[] = \{ NULL \};
769 
770 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_help(FILE *fout, \textcolor{keywordtype}{int} shorthelp) \{
771   fprintf(fout, \textcolor{stringliteral}{"Usage: %s <options> -o dst\_filename src\_filename \(\backslash\)n"},
772       exec\_name);
773 
774   \textcolor{keywordflow}{if} (shorthelp) \{
775     fprintf(fout, \textcolor{stringliteral}{"Use --help to see the full list of options.\(\backslash\)n"});
776     \textcolor{keywordflow}{return};
777   \}
778 
779   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nOptions:\(\backslash\)n"});
780   arg\_show\_usage(fout, main\_args);
781   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nEncoder Global Options:\(\backslash\)n"});
782   arg\_show\_usage(fout, global\_args);
783   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nSparse Coding Options:\(\backslash\)n"});
784   arg\_show\_usage(fout, sparse\_args);
785   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nRate Control Options:\(\backslash\)n"});
786   arg\_show\_usage(fout, rc\_args);
787   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nTwopass Rate Control Options:\(\backslash\)n"});
788   arg\_show\_usage(fout, rc\_twopass\_args);
789   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nKeyframe Placement Options:\(\backslash\)n"});
790   arg\_show\_usage(fout, kf\_args);
791 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
792   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nAV1 Specific Options:\(\backslash\)n"});
793   arg\_show\_usage(fout, av1\_args);
794 \textcolor{preprocessor}{#endif}
795   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)n        "});
796   fprintf(fout,
797       \textcolor{stringliteral}{"\(\backslash\)nStream timebase (--timebase):\(\backslash\)n"}
798       \textcolor{stringliteral}{"  The desired precision of timestamps in the output, expressed\(\backslash\)n"}
799       \textcolor{stringliteral}{"  in fractional seconds. Default is 1/1000.\(\backslash\)n"});
800   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nIncluded encoders:\(\backslash\)n\(\backslash\)n"});
801 
802   \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_encoder = get\_aom\_encoder\_count();
803   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < num\_encoder; ++i) \{
804     \textcolor{keyword}{const} AvxInterface *\textcolor{keyword}{const} encoder = get\_aom\_encoder\_by\_index(i);
805     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *defstr = (i == (num\_encoder - 1)) ? \textcolor{stringliteral}{"(default)"} : \textcolor{stringliteral}{""};
806     fprintf(fout, \textcolor{stringliteral}{"    %-6s - %s %s\(\backslash\)n"}, encoder->name,
807         \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()), defstr);
808   \}
809   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)n        "});
810   fprintf(fout, \textcolor{stringliteral}{"Use --codec to switch to a non-default encoder.\(\backslash\)n\(\backslash\)n"});
811 
812 \}
813 
814 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
815   show\_help(stderr, 1);
816   exit(EXIT\_FAILURE);
817 \}
818 
819 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
820 \textcolor{preprocessor}{#define ARG\_CTRL\_CNT\_MAX NELEMENTS(av1\_arg\_ctrl\_map)}
821 \textcolor{preprocessor}{#endif}
822 
823 \textcolor{preprocessor}{#if !CONFIG\_WEBM\_IO}
824 \textcolor{keyword}{typedef} \textcolor{keywordtype}{int} stereo\_format\_t;
825 \textcolor{keyword}{struct }WebmOutputContext \{
826   \textcolor{keywordtype}{int} debug;
827 \};
828 \textcolor{preprocessor}{#endif}
829 
830 \textcolor{comment}{/* Per-stream configuration */}
831 \textcolor{keyword}{struct }stream\_config \{
832   \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} cfg;
833   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *out\_fn;
834   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *stats\_fn;
835 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
836   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fpmb\_stats\_fn;
837 \textcolor{preprocessor}{#endif}
838   stereo\_format\_t stereo\_fmt;
839   \textcolor{keywordtype}{int} arg\_ctrls[ARG\_CTRL\_CNT\_MAX][2];
840   \textcolor{keywordtype}{int} arg\_ctrl\_cnt;
841   \textcolor{keywordtype}{int} write\_webm;
842   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *film\_grain\_filename;
843   \textcolor{keywordtype}{int} write\_ivf;
844   \textcolor{comment}{// whether to use 16bit internal buffers}
845   \textcolor{keywordtype}{int} use\_16bit\_internal;
846 \};
847 
848 \textcolor{keyword}{struct }stream\_state \{
849   \textcolor{keywordtype}{int} index;
850   \textcolor{keyword}{struct }stream\_state *next;
851   \textcolor{keyword}{struct }stream\_config config;
852   FILE *file;
853   \textcolor{keyword}{struct }rate\_hist *rate\_hist;
854   \textcolor{keyword}{struct }WebmOutputContext webm\_ctx;
855   uint64\_t psnr\_sse\_total;
856   uint64\_t psnr\_samples\_total;
857   \textcolor{keywordtype}{double} psnr\_totals[4];
858   \textcolor{keywordtype}{int} psnr\_count;
859   \textcolor{keywordtype}{int} counts[64];
860   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} encoder;
861   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frames\_out;
862   uint64\_t cx\_time;
863   \textcolor{keywordtype}{size\_t} nbytes;
864   stats\_io\_t stats;
865 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
866   stats\_io\_t fpmb\_stats;
867 \textcolor{preprocessor}{#endif}
868   \textcolor{keyword}{struct }\hyperlink{structaom__image}{aom\_image} *img;
869   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} decoder;
870   \textcolor{keywordtype}{int} mismatch\_seen;
871   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} chroma\_subsampling\_x;
872   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} chroma\_subsampling\_y;
873 \};
874 
875 \textcolor{keyword}{static} \textcolor{keywordtype}{void} validate\_positive\_rational(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg,
876     \textcolor{keyword}{struct} \hyperlink{structaom__rational}{aom\_rational} *rat) \{
877   \textcolor{keywordflow}{if} (rat->\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} < 0) \{
878     rat->\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} *= -1;
879     rat->\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} *= -1;
880   \}
881 
882   \textcolor{keywordflow}{if} (rat->\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} < 0) die(\textcolor{stringliteral}{"Error: %s must be positive\(\backslash\)n"}, msg);
883 
884   \textcolor{keywordflow}{if} (!rat->\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den}) die(\textcolor{stringliteral}{"Error: %s has zero denominator\(\backslash\)n"}, msg);
885 \}
886 
887 \textcolor{comment}{/* Parses global config arguments into the AvxEncoderConfig. Note that}
888 \textcolor{comment}{ * argv is modified and overwrites all parsed arguments.}
889 \textcolor{comment}{ */}
890 \textcolor{keyword}{static} \textcolor{keywordtype}{void} parse\_global\_config(\textcolor{keyword}{struct} AvxEncoderConfig *global, \textcolor{keywordtype}{int} argc,
891     \textcolor{keywordtype}{char} ***argv) \{
892   \textcolor{keywordtype}{char} **argi, **argj;
893   \textcolor{keyword}{struct }arg arg;
894   \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_encoder = get\_aom\_encoder\_count();
895   \textcolor{keywordtype}{char} **argv\_local = (\textcolor{keywordtype}{char} **)*argv;
896 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
897   \textcolor{keywordtype}{int} argc\_local = argc;
898 \textcolor{preprocessor}{#endif}
899   \textcolor{keywordflow}{if} (num\_encoder < 1) die(\textcolor{stringliteral}{"Error: no valid encoder available\(\backslash\)n"});
900 
901   \textcolor{comment}{/* Initialize default parameters */}
902   memset(global, 0, \textcolor{keyword}{sizeof}(*global));
903   global->codec = get\_aom\_encoder\_by\_index(num\_encoder - 1);
904   global->passes = 0;
905   global->color\_type = I420;
906   global->csp = \hyperlink{aom__image_8h_a10590253ef3dbde7e93ed5d4b4e0e73ba7843506f3e28f720be0d4f03237fb48c}{AOM\_CSP\_UNKNOWN};
907 
908 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
909   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *cfg = NULL;
910   \textcolor{keywordtype}{int} cfg\_included = 0;
911 \textcolor{preprocessor}{#endif}
912   \textcolor{keywordflow}{for} (argi = argj = argv\_local; (*argj = *argi); argi += arg.argv\_step) \{
913     arg.argv\_step = 1;
914 
915 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
916     \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_cfg, argi)) \{
917       \textcolor{keywordflow}{if} (cfg\_included) \textcolor{keywordflow}{continue};
918       cfg = arg.val;
919 
920       arg\_cfg(&argc\_local, &argv\_local, cfg);
921 
922       *argj = *argi = *argv\_local;
923       argj = argi = argv\_local;
924       *argv = argv\_local;
925       cfg\_included = 1;
926       \textcolor{keywordflow}{continue};
927     \}
928 \textcolor{preprocessor}{#endif}
929     \textcolor{keywordflow}{if} (arg\_match(&arg, &help, argi)) \{
930       show\_help(stdout, 0);
931       exit(EXIT\_SUCCESS);
932     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &codecarg, argi)) \{
933       global->codec = get\_aom\_encoder\_by\_name(arg.val);
934       \textcolor{keywordflow}{if} (!global->codec)
935         die(\textcolor{stringliteral}{"Error: Unrecognized argument (%s) to --codec\(\backslash\)n"}, arg.val);
936     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &passes, argi)) \{
937       global->passes = arg\_parse\_uint(&arg);
938 
939       \textcolor{keywordflow}{if} (global->passes < 1 || global->passes > 2)
940         die(\textcolor{stringliteral}{"Error: Invalid number of passes (%d)\(\backslash\)n"}, global->passes);
941     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &pass\_arg, argi)) \{
942       global->pass = arg\_parse\_uint(&arg);
943 
944       \textcolor{keywordflow}{if} (global->pass < 1 || global->pass > 2)
945         die(\textcolor{stringliteral}{"Error: Invalid pass selected (%d)\(\backslash\)n"}, global->pass);
946     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &input\_chroma\_sample\_position, argi)) \{
947       global->csp = arg\_parse\_enum(&arg);
948       \textcolor{comment}{/* Flag is used by later code as well, preserve it. */}
949       argj++;
950     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &usage, argi))
951       global->usage = arg\_parse\_uint(&arg);
952     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &good\_dl, argi))
953       warn(\textcolor{stringliteral}{"Deprecated --good option! Ignoring\(\backslash\)n"});
954     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_yv12, argi))
955       global->color\_type = YV12;
956     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i420, argi))
957       global->color\_type = I420;
958     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i422, argi))
959       global->color\_type = I422;
960     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i444, argi))
961       global->color\_type = I444;
962     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &quietarg, argi))
963       global->quiet = 1;
964     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &verbosearg, argi))
965       global->verbose = 1;
966     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &limit, argi))
967       global->limit = arg\_parse\_uint(&arg);
968     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &skip, argi))
969       global->skip\_frames = arg\_parse\_uint(&arg);
970     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &psnrarg, argi))
971       global->show\_psnr = 1;
972     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &recontest, argi))
973       global->test\_decode = arg\_parse\_enum\_or\_int(&arg);
974     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &framerate, argi)) \{
975       global->framerate = arg\_parse\_rational(&arg);
976       validate\_positive\_rational(arg.name, &global->framerate);
977       global->have\_framerate = 1;
978     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &debugmode, argi))
979       global->debug = 1;
980     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &q\_hist\_n, argi))
981       global->show\_q\_hist\_buckets = arg\_parse\_uint(&arg);
982     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &rate\_hist\_n, argi))
983       global->show\_rate\_hist\_buckets = arg\_parse\_uint(&arg);
984     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &disable\_warnings, argi))
985       global->disable\_warnings = 1;
986     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &disable\_warning\_prompt, argi))
987       global->disable\_warning\_prompt = 1;
988     \textcolor{keywordflow}{else}
989       argj++;
990   \}
991 
992   \textcolor{keywordflow}{if} (global->pass) \{
993     \textcolor{comment}{/* DWIM: Assume the user meant passes=2 if pass=2 is specified */}
994     \textcolor{keywordflow}{if} (global->pass > global->passes) \{
995       warn(\textcolor{stringliteral}{"Assuming --pass=%d implies --passes=%d\(\backslash\)n"}, global->pass,
996           global->pass);
997       global->passes = global->pass;
998     \}
999   \}
1000   \textcolor{comment}{/* Validate global config */}
1001   \textcolor{keywordflow}{if} (global->passes == 0) \{
1002 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
1003     \textcolor{comment}{// Make default AV1 passes = 2 until there is a better quality 1-pass}
1004     \textcolor{comment}{// encoder}
1005     \textcolor{keywordflow}{if} (global->codec != NULL && global->codec->name != NULL)
1006       global->passes = (strcmp(global->codec->name, \textcolor{stringliteral}{"av1"}) == 0) ? 2 : 1;
1007 \textcolor{preprocessor}{#else}
1008     global->passes = 1;
1009 \textcolor{preprocessor}{#endif}
1010   \}
1011 \}
1012 
1013 \textcolor{comment}{/* Parses sparse config arguments into the SparseConfig. Note that}
1014 \textcolor{comment}{ * argv is modified and overwrites all parsed arguments.}
1015 \textcolor{comment}{ */}
1016 \textcolor{keyword}{static} \textcolor{keywordtype}{void} parse\_sparse\_config(\textcolor{keyword}{struct} SparseConfig *sparse, \textcolor{keywordtype}{char} ***argv, \textcolor{keywordtype}{int} h) \{
1017   \textcolor{keywordtype}{char} **argi, **argj;
1018   \textcolor{keyword}{struct }arg arg;
1019   \textcolor{keywordtype}{char} **argv\_local = (\textcolor{keywordtype}{char} **)*argv;
1020 
1021   \textcolor{comment}{/* Initialize default parameters */}
1022   memset(sparse, 0, \textcolor{keyword}{sizeof}(*sparse));
1023   sparse->sparse\_coding = 0;
1024   sparse->train\_dict = 32;
1025   sparse->k\_codewords = 512;
1026   sparse->training = RANDOM;
1027   sparse->iterations = 10;
1028   sparse->sparse\_depth = -1;
1029 
1030   \textcolor{keywordflow}{for} (argi = argj = argv\_local; (*argj = *argi); argi += arg.argv\_step) \{
1031     arg.argv\_step = 1;     arg.argv\_step = 1;
1032 
1033     \textcolor{keywordflow}{if} (arg\_match(&arg, &sparse\_coding, argi))
1034       sparse->sparse\_coding = 1;
1035     \textcolor{keywordflow}{else} if (arg\_match(&arg, &k\_codewords, argi))
1036       sparse->k\_codewords = arg\_parse\_uint(&arg);
1037     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &train\_dict, argi))
1038       sparse->train\_dict = arg\_parse\_uint(&arg);
1039     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &sparse\_depth, argi))
1040       sparse->sparse\_depth = arg\_parse\_uint(&arg);
1041     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &iterations, argi))
1042       sparse->iterations = arg\_parse\_uint(&arg);
1043     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &dict\_alg, argi))
1044       sparse->training = arg\_parse\_enum(&arg);
1045     \textcolor{keywordflow}{else}
1046       argj++;
1047   \}
1048 
1049   \textcolor{keywordflow}{if} (sparse->sparse\_depth == -1) \{
1050     \textcolor{keywordflow}{if}(h > 1080) \{
1051       sparse->sparse\_depth = 3;
1052     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(h < 460) \{
1053       sparse->sparse\_depth = 1;
1054     \} \textcolor{keywordflow}{else} \{
1055       sparse->sparse\_depth = 2;
1056     \}
1057   \}
1058 
1059   \textcolor{keywordflow}{if} (sparse->sparse\_depth > 3) \{
1060     sparse->sparse\_depth = 3;
1061   \}
1062 \}
1063 
1064 \textcolor{keyword}{static} \textcolor{keywordtype}{void} open\_input\_file(\textcolor{keyword}{struct} AvxInputContext *input,
1065     \hyperlink{aom__image_8h_a48f259fc7774b1c799b3ebe7530c19bd}{aom\_chroma\_sample\_position\_t} csp) \{
1066   \textcolor{comment}{/* Parse certain options from the input file, if possible */}
1067   input->file = strcmp(input->filename, \textcolor{stringliteral}{"-"}) ? fopen(input->filename, \textcolor{stringliteral}{"rb"})
1068       : set\_binary\_mode(stdin);
1069 
1070   \textcolor{keywordflow}{if} (!input->file) fatal(\textcolor{stringliteral}{"Failed to open input file"});
1071 
1072   \textcolor{keywordflow}{if} (!fseeko(input->file, 0, SEEK\_END)) \{
1073     \textcolor{comment}{/* Input file is seekable. Figure out how long it is, so we can get}
1074 \textcolor{comment}{     * progress info.}
1075 \textcolor{comment}{     */}
1076     input->length = ftello(input->file);
1077     rewind(input->file);
1078   \}
1079 
1080   \textcolor{comment}{/* Default to 1:1 pixel aspect ratio. */}
1081   input->pixel\_aspect\_ratio.numerator = 1;
1082   input->pixel\_aspect\_ratio.denominator = 1;
1083 
1084   \textcolor{comment}{/* For RAW input sources, these bytes will applied on the first frame}
1085 \textcolor{comment}{   *  in read\_frame().}
1086 \textcolor{comment}{   */}
1087   input->detect.buf\_read = fread(input->detect.buf, 1, 4, input->file);
1088   input->detect.position = 0;
1089 
1090   \textcolor{keywordflow}{if} (input->detect.buf\_read == 4 && file\_is\_y4m(input->detect.buf)) \{
1091     \textcolor{keywordflow}{if} (y4m\_input\_open(&input->y4m, input->file, input->detect.buf, 4, csp,
1092         input->only\_i420) >= 0) \{
1093       input->file\_type = FILE\_TYPE\_Y4M;
1094       input->width = input->y4m.pic\_w;
1095       input->height = input->y4m.pic\_h;
1096       input->pixel\_aspect\_ratio.numerator = input->y4m.par\_n;
1097       input->pixel\_aspect\_ratio.denominator = input->y4m.par\_d;
1098       input->framerate.numerator = input->y4m.fps\_n;
1099       input->framerate.denominator = input->y4m.fps\_d;
1100       input->fmt = input->y4m.aom\_fmt;
1101       input->bit\_depth = input->y4m.bit\_depth;
1102     \} \textcolor{keywordflow}{else}
1103       fatal(\textcolor{stringliteral}{"Unsupported Y4M stream."});
1104   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input->detect.buf\_read == 4 && fourcc\_is\_ivf(input->detect.buf)) \{
1105     fatal(\textcolor{stringliteral}{"IVF is not supported as input."});
1106   \} \textcolor{keywordflow}{else} \{
1107     input->file\_type = FILE\_TYPE\_RAW;
1108   \}
1109 \}
1110 
1111 \textcolor{keyword}{static} \textcolor{keywordtype}{void} close\_input\_file(\textcolor{keyword}{struct} AvxInputContext *input) \{
1112   fclose(input->file);
1113   \textcolor{keywordflow}{if} (input->file\_type == FILE\_TYPE\_Y4M) y4m\_input\_close(&input->y4m);
1114 \}
1115 
1116 \textcolor{keyword}{static} \textcolor{keyword}{struct }stream\_state *new\_stream(\textcolor{keyword}{struct} AvxEncoderConfig *global,
1117     \textcolor{keyword}{struct} stream\_state *prev) \{
1118   \textcolor{keyword}{struct }stream\_state *stream;
1119 
1120   stream = calloc(1, \textcolor{keyword}{sizeof}(*stream));
1121   \textcolor{keywordflow}{if} (stream == NULL) \{
1122     fatal(\textcolor{stringliteral}{"Failed to allocate new stream."});
1123   \}
1124 
1125   \textcolor{keywordflow}{if} (prev) \{
1126     memcpy(stream, prev, \textcolor{keyword}{sizeof}(*stream));
1127     stream->index++;
1128     prev->next = stream;
1129   \} \textcolor{keywordflow}{else} \{
1130     \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
1131 
1132     \textcolor{comment}{/* Populate encoder configuration */}
1133     res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(global->codec->codec\_interface(),
1134         &stream->config.cfg, global->usage);
1135     \textcolor{keywordflow}{if} (res) fatal(\textcolor{stringliteral}{"Failed to get config: %s\(\backslash\)n"}, \hyperlink{group__codec_ga83c6525528574d1a88e73a9f605c9115}{aom\_codec\_err\_to\_string}(res));
1136 
1137     \textcolor{comment}{/* Change the default timebase to a high enough value so that the}
1138 \textcolor{comment}{     * encoder will always create strictly increasing timestamps.}
1139 \textcolor{comment}{     */}
1140     stream->config.cfg.g\_timebase.den = 1000;
1141 
1142     \textcolor{comment}{/* Never use the library's default resolution, require it be parsed}
1143 \textcolor{comment}{     * from the file or set on the command line.}
1144 \textcolor{comment}{     */}
1145     stream->config.cfg.g\_w = 0;
1146     stream->config.cfg.g\_h = 0;
1147 
1148     \textcolor{comment}{/* Initialize remaining stream parameters */}
1149     stream->config.write\_webm = 1;
1150     stream->config.write\_ivf = 0;
1151 
1152 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1153     stream->config.stereo\_fmt = STEREO\_FORMAT\_MONO;
1154     stream->webm\_ctx.last\_pts\_ns = -1;
1155     stream->webm\_ctx.writer = NULL;
1156     stream->webm\_ctx.segment = NULL;
1157 \textcolor{preprocessor}{#endif}
1158 
1159     \textcolor{comment}{/* Allows removal of the application version from the EBML tags */}
1160     stream->webm\_ctx.debug = global->debug;
1161   \}
1162 
1163   \textcolor{comment}{/* Output files must be specified for each stream */}
1164   stream->config.out\_fn = NULL;
1165 
1166   stream->next = NULL;
1167   \textcolor{keywordflow}{return} stream;
1168 \}
1169 
1170 \textcolor{keyword}{static} \textcolor{keywordtype}{void} set\_config\_arg\_ctrls(\textcolor{keyword}{struct} stream\_config *config, \textcolor{keywordtype}{int} key,
1171     \textcolor{keyword}{const} \textcolor{keyword}{struct} arg *arg) \{
1172   \textcolor{keywordtype}{int} j;
1173   \textcolor{keywordflow}{if} (key == \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad5846c6f49d37e65a03c39e68d487097}{AV1E\_SET\_FILM\_GRAIN\_TABLE}) \{
1174     config->film\_grain\_filename = arg->val;
1175     \textcolor{keywordflow}{return};
1176   \}
1177 
1178   \textcolor{comment}{/* Point either to the next free element or the first instance of this}
1179 \textcolor{comment}{   * control.}
1180 \textcolor{comment}{   */}
1181   \textcolor{keywordflow}{for} (j = 0; j < config->arg\_ctrl\_cnt; j++)
1182     \textcolor{keywordflow}{if} (config->arg\_ctrls[j][0] == key) \textcolor{keywordflow}{break};
1183 
1184   \textcolor{comment}{/* Update/insert */}
1185   assert(j < (\textcolor{keywordtype}{int})ARG\_CTRL\_CNT\_MAX);
1186   config->arg\_ctrls[j][0] = key;
1187   config->arg\_ctrls[j][1] = arg\_parse\_enum\_or\_int(arg);
1188 
1189   \textcolor{keywordflow}{if} (key == \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF} && config->arg\_ctrls[j][1] > 1) \{
1190     warn(\textcolor{stringliteral}{"auto-alt-ref > 1 is deprecated... setting auto-alt-ref=1\(\backslash\)n"});
1191     config->arg\_ctrls[j][1] = 1;
1192   \}
1193   \textcolor{keywordflow}{if} (j == config->arg\_ctrl\_cnt) config->arg\_ctrl\_cnt++;
1194 \}
1195 
1196 \textcolor{keyword}{static} \textcolor{keywordtype}{int} parse\_stream\_params(\textcolor{keyword}{struct} AvxEncoderConfig *global,
1197     \textcolor{keyword}{struct} stream\_state *stream, \textcolor{keywordtype}{char} **argv) \{
1198   \textcolor{keywordtype}{char} **argi, **argj;
1199   \textcolor{keyword}{struct }arg arg;
1200   \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t **ctrl\_args = no\_args;
1201   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} *ctrl\_args\_map = NULL;
1202   \textcolor{keyword}{struct }stream\_config *config = &stream->config;
1203   \textcolor{keywordtype}{int} eos\_mark\_found = 0;
1204   \textcolor{keywordtype}{int} webm\_forced = 0;
1205 
1206   \textcolor{comment}{// Handle codec specific options}
1207   \textcolor{keywordflow}{if} (0) \{
1208 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
1209   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (strcmp(global->codec->name, \textcolor{stringliteral}{"av1"}) == 0) \{
1210     \textcolor{comment}{// TODO(jingning): Reuse AV1 specific encoder configuration parameters.}
1211     \textcolor{comment}{// Consider to expand this set for AV1 encoder control.}
1212     ctrl\_args = av1\_args;
1213     ctrl\_args\_map = av1\_arg\_ctrl\_map;
1214 \textcolor{preprocessor}{#endif}
1215   \}
1216 
1217   \textcolor{keywordflow}{for} (argi = argj = argv; (*argj = *argi); argi += arg.argv\_step) \{
1218     arg.argv\_step = 1;
1219 
1220     \textcolor{comment}{/* Once we've found an end-of-stream marker (--) we want to continue}
1221 \textcolor{comment}{     * shifting arguments but not consuming them.}
1222 \textcolor{comment}{     */}
1223     \textcolor{keywordflow}{if} (eos\_mark\_found) \{
1224       argj++;
1225       \textcolor{keywordflow}{continue};
1226     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(*argj, \textcolor{stringliteral}{"--"})) \{
1227       eos\_mark\_found = 1;
1228       \textcolor{keywordflow}{continue};
1229     \}
1230 
1231     \textcolor{keywordflow}{if} (arg\_match(&arg, &outputfile, argi)) \{
1232       config->out\_fn = arg.val;
1233       \textcolor{keywordflow}{if} (!webm\_forced) \{
1234         \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} out\_fn\_len = strlen(config->out\_fn);
1235         \textcolor{keywordflow}{if} (out\_fn\_len >= 4 &&
1236             !strcmp(config->out\_fn + out\_fn\_len - 4, \textcolor{stringliteral}{".ivf"})) \{
1237           config->write\_webm = 0;
1238           config->write\_ivf = 1;
1239         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (out\_fn\_len >= 4 &&
1240             !strcmp(config->out\_fn + out\_fn\_len - 4, \textcolor{stringliteral}{".obu"})) \{
1241           config->write\_webm = 0;
1242           config->write\_ivf = 0;
1243         \}
1244       \}
1245     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &fpf\_name, argi)) \{
1246       config->stats\_fn = arg.val;
1247 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
1248     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &fpmbf\_name, argi)) \{
1249       config->fpmb\_stats\_fn = arg.val;
1250 \textcolor{preprocessor}{#endif}
1251     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_webm, argi)) \{
1252 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1253       config->write\_webm = 1;
1254       webm\_forced = 1;
1255 \textcolor{preprocessor}{#else}
1256       die(\textcolor{stringliteral}{"Error: --webm specified but webm is disabled."});
1257 \textcolor{preprocessor}{#endif}
1258     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_ivf, argi)) \{
1259       config->write\_webm = 0;
1260       config->write\_ivf = 1;
1261     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_obu, argi)) \{
1262       config->write\_webm = 0;
1263       config->write\_ivf = 0;
1264     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &threads, argi)) \{
1265       config->cfg.g\_threads = arg\_parse\_uint(&arg);
1266     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &profile, argi)) \{
1267       config->cfg.g\_profile = arg\_parse\_uint(&arg);
1268     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &width, argi)) \{
1269       config->cfg.g\_w = arg\_parse\_uint(&arg);
1270     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &height, argi)) \{
1271       config->cfg.g\_h = arg\_parse\_uint(&arg);
1272     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &forced\_max\_frame\_width, argi)) \{
1273       config->cfg.g\_forced\_max\_frame\_width = arg\_parse\_uint(&arg);
1274     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &forced\_max\_frame\_height, argi)) \{
1275       config->cfg.g\_forced\_max\_frame\_height = arg\_parse\_uint(&arg);
1276     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &bitdeptharg, argi)) \{
1277       config->cfg.g\_bit\_depth = arg\_parse\_enum\_or\_int(&arg);
1278     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &inbitdeptharg, argi)) \{
1279       config->cfg.g\_input\_bit\_depth = arg\_parse\_uint(&arg);
1280     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &input\_chroma\_subsampling\_x, argi)) \{
1281       stream->chroma\_subsampling\_x = arg\_parse\_uint(&arg);
1282     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &input\_chroma\_subsampling\_y, argi)) \{
1283       stream->chroma\_subsampling\_y = arg\_parse\_uint(&arg);
1284 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1285     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &stereo\_mode, argi)) \{
1286       config->stereo\_fmt = arg\_parse\_enum\_or\_int(&arg);
1287 \textcolor{preprocessor}{#endif}
1288     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &timebase, argi)) \{
1289       config->cfg.g\_timebase = arg\_parse\_rational(&arg);
1290       validate\_positive\_rational(arg.name, &config->cfg.g\_timebase);
1291     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &global\_error\_resilient, argi)) \{
1292       config->cfg.g\_error\_resilient = arg\_parse\_uint(&arg);
1293     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &lag\_in\_frames, argi)) \{
1294       config->cfg.g\_lag\_in\_frames = arg\_parse\_uint(&arg);
1295     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &large\_scale\_tile, argi)) \{
1296       config->cfg.large\_scale\_tile = arg\_parse\_uint(&arg);
1297     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &monochrome, argi)) \{
1298       config->cfg.monochrome = 1;
1299     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &full\_still\_picture\_hdr, argi)) \{
1300       config->cfg.full\_still\_picture\_hdr = 1;
1301     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &dropframe\_thresh, argi)) \{
1302       config->cfg.rc\_dropframe\_thresh = arg\_parse\_uint(&arg);
1303     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &resize\_mode, argi)) \{
1304       config->cfg.rc\_resize\_mode = arg\_parse\_uint(&arg);
1305     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &resize\_denominator, argi)) \{
1306       config->cfg.rc\_resize\_denominator = arg\_parse\_uint(&arg);
1307     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &resize\_kf\_denominator, argi)) \{
1308       config->cfg.rc\_resize\_kf\_denominator = arg\_parse\_uint(&arg);
1309     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_mode, argi)) \{
1310       config->cfg.rc\_superres\_mode = arg\_parse\_uint(&arg);
1311     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_denominator, argi)) \{
1312       config->cfg.rc\_superres\_denominator = arg\_parse\_uint(&arg);
1313     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_kf\_denominator, argi)) \{
1314       config->cfg.rc\_superres\_kf\_denominator = arg\_parse\_uint(&arg);
1315     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_qthresh, argi)) \{
1316       config->cfg.rc\_superres\_qthresh = arg\_parse\_uint(&arg);
1317     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_kf\_qthresh, argi)) \{
1318       config->cfg.rc\_superres\_kf\_qthresh = arg\_parse\_uint(&arg);
1319     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &end\_usage, argi)) \{
1320       config->cfg.rc\_end\_usage = arg\_parse\_enum\_or\_int(&arg);
1321     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &target\_bitrate, argi)) \{
1322       config->cfg.rc\_target\_bitrate = arg\_parse\_uint(&arg);
1323     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &min\_quantizer, argi)) \{
1324       config->cfg.rc\_min\_quantizer = arg\_parse\_uint(&arg);
1325     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &max\_quantizer, argi)) \{
1326       config->cfg.rc\_max\_quantizer = arg\_parse\_uint(&arg);
1327     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &undershoot\_pct, argi)) \{
1328       config->cfg.rc\_undershoot\_pct = arg\_parse\_uint(&arg);
1329     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &overshoot\_pct, argi)) \{
1330       config->cfg.rc\_overshoot\_pct = arg\_parse\_uint(&arg);
1331     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &buf\_sz, argi)) \{
1332       config->cfg.rc\_buf\_sz = arg\_parse\_uint(&arg);
1333     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &buf\_initial\_sz, argi)) \{
1334       config->cfg.rc\_buf\_initial\_sz = arg\_parse\_uint(&arg);
1335     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &buf\_optimal\_sz, argi)) \{
1336       config->cfg.rc\_buf\_optimal\_sz = arg\_parse\_uint(&arg);
1337     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &bias\_pct, argi)) \{
1338       config->cfg.rc\_2pass\_vbr\_bias\_pct = arg\_parse\_uint(&arg);
1339       \textcolor{keywordflow}{if} (global->passes < 2)
1340         warn(\textcolor{stringliteral}{"option %s ignored in one-pass mode.\(\backslash\)n"}, arg.name);
1341     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &minsection\_pct, argi)) \{
1342       config->cfg.rc\_2pass\_vbr\_minsection\_pct = arg\_parse\_uint(&arg);
1343 
1344       \textcolor{keywordflow}{if} (global->passes < 2)
1345         warn(\textcolor{stringliteral}{"option %s ignored in one-pass mode.\(\backslash\)n"}, arg.name);
1346     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &maxsection\_pct, argi)) \{
1347       config->cfg.rc\_2pass\_vbr\_maxsection\_pct = arg\_parse\_uint(&arg);
1348 
1349       \textcolor{keywordflow}{if} (global->passes < 2)
1350         warn(\textcolor{stringliteral}{"option %s ignored in one-pass mode.\(\backslash\)n"}, arg.name);
1351     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &fwd\_kf\_enabled, argi)) \{
1352       config->cfg.fwd\_kf\_enabled = arg\_parse\_uint(&arg);
1353     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &kf\_min\_dist, argi)) \{
1354       config->cfg.kf\_min\_dist = arg\_parse\_uint(&arg);
1355     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &kf\_max\_dist, argi)) \{
1356       config->cfg.kf\_max\_dist = arg\_parse\_uint(&arg);
1357     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &kf\_disabled, argi)) \{
1358       config->cfg.kf\_mode = \hyperlink{group__encoder_ggac0498fc02cd368e6d9675cdb0bab5a84af81473ffe0169271763f9c9d05393405}{AOM\_KF\_DISABLED};
1359     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &sframe\_dist, argi)) \{
1360       config->cfg.sframe\_dist = arg\_parse\_uint(&arg);
1361     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &sframe\_mode, argi)) \{
1362       config->cfg.sframe\_mode = arg\_parse\_uint(&arg);
1363     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &save\_as\_annexb, argi)) \{
1364       config->cfg.save\_as\_annexb = arg\_parse\_uint(&arg);
1365     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &tile\_width, argi)) \{
1366       config->cfg.tile\_width\_count =
1367           arg\_parse\_list(&arg, config->cfg.tile\_widths, \hyperlink{aom__encoder_8h_a3ec4904ea175471a03d10705f384d07c}{MAX\_TILE\_WIDTHS});
1368     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &tile\_height, argi)) \{
1369       config->cfg.tile\_height\_count =
1370           arg\_parse\_list(&arg, config->cfg.tile\_heights, \hyperlink{aom__encoder_8h_a446aae868ff07f3971d9e84b6602a890}{MAX\_TILE\_HEIGHTS});
1371 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
1372     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &ext\_partition, argi)) \{
1373       config->cfg.cfg.ext\_partition = !!arg\_parse\_uint(&arg) > 0;
1374 \textcolor{preprocessor}{#endif}
1375     \} \textcolor{keywordflow}{else} \{
1376       \textcolor{keywordtype}{int} i, match = 0;
1377       \textcolor{keywordflow}{for} (i = 0; ctrl\_args[i]; i++) \{
1378         \textcolor{keywordflow}{if} (arg\_match(&arg, ctrl\_args[i], argi)) \{
1379           match = 1;
1380           \textcolor{keywordflow}{if} (ctrl\_args\_map) \{
1381             set\_config\_arg\_ctrls(config, ctrl\_args\_map[i], &arg);
1382           \}
1383         \}
1384       \}
1385       \textcolor{keywordflow}{if} (!match) argj++;
1386     \}
1387   \}
1388   config->use\_16bit\_internal =
1389       config->cfg.g\_bit\_depth > \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8} || !CONFIG\_LOWBITDEPTH;
1390   \textcolor{keywordflow}{return} eos\_mark\_found;
1391 \}
1392 
1393 \textcolor{preprocessor}{#define FOREACH\_STREAM(iterator, list)                 \(\backslash\)}
1394 \textcolor{preprocessor}{    for (struct stream\_state *iterator = list; iterator; \(\backslash\)}
1395 \textcolor{preprocessor}{    iterator = iterator->next)}
1396 
1397 \textcolor{keyword}{static} \textcolor{keywordtype}{void} validate\_stream\_config(\textcolor{keyword}{const} \textcolor{keyword}{struct} stream\_state *stream,
1398     \textcolor{keyword}{const} \textcolor{keyword}{struct} AvxEncoderConfig *global) \{
1399   \textcolor{keyword}{const} \textcolor{keyword}{struct }stream\_state *streami;
1400   (void)global;
1401 
1402   \textcolor{keywordflow}{if} (!stream->config.cfg.g\_w || !stream->config.cfg.g\_h)
1403     fatal(
1404         \textcolor{stringliteral}{"Stream %d: Specify stream dimensions with --width (-w) "}
1405         \textcolor{stringliteral}{" and --height (-h)"},
1406         stream->index);
1407 
1408   \textcolor{comment}{/* Even if bit depth is set on the command line flag to be lower,}
1409 \textcolor{comment}{   * it is upgraded to at least match the input bit depth.}
1410 \textcolor{comment}{   */}
1411   assert(stream->config.cfg.g\_input\_bit\_depth <=
1412       (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})stream->config.cfg.g\_bit\_depth);
1413 
1414   \textcolor{keywordflow}{for} (streami = stream; streami; streami = streami->next) \{
1415     \textcolor{comment}{/* All streams require output files */}
1416     \textcolor{keywordflow}{if} (!streami->config.out\_fn)
1417       fatal(\textcolor{stringliteral}{"Stream %d: Output file is required (specify with -o)"},
1418           streami->index);
1419 
1420     \textcolor{comment}{/* Check for two streams outputting to the same file */}
1421     \textcolor{keywordflow}{if} (streami != stream) \{
1422       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *a = stream->config.out\_fn;
1423       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *b = streami->config.out\_fn;
1424       \textcolor{keywordflow}{if} (!strcmp(a, b) && strcmp(a, \textcolor{stringliteral}{"/dev/null"}) && strcmp(a, \textcolor{stringliteral}{":nul"}))
1425         fatal(\textcolor{stringliteral}{"Stream %d: duplicate output file (from stream %d)"},
1426             streami->index, stream->index);
1427     \}
1428 
1429     \textcolor{comment}{/* Check for two streams sharing a stats file. */}
1430     \textcolor{keywordflow}{if} (streami != stream) \{
1431       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *a = stream->config.stats\_fn;
1432       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *b = streami->config.stats\_fn;
1433       \textcolor{keywordflow}{if} (a && b && !strcmp(a, b))
1434         fatal(\textcolor{stringliteral}{"Stream %d: duplicate stats file (from stream %d)"},
1435             streami->index, stream->index);
1436     \}
1437 
1438 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
1439     \textcolor{comment}{/* Check for two streams sharing a mb stats file. */}
1440     \textcolor{keywordflow}{if} (streami != stream) \{
1441       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *a = stream->config.fpmb\_stats\_fn;
1442       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *b = streami->config.fpmb\_stats\_fn;
1443       \textcolor{keywordflow}{if} (a && b && !strcmp(a, b))
1444         fatal(\textcolor{stringliteral}{"Stream %d: duplicate mb stats file (from stream %d)"},
1445             streami->index, stream->index);
1446     \}
1447 \textcolor{preprocessor}{#endif}
1448   \}
1449 \}
1450 
1451 \textcolor{keyword}{static} \textcolor{keywordtype}{void} set\_stream\_dimensions(\textcolor{keyword}{struct} stream\_state *stream, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} w,
1452     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} h) \{
1453   \textcolor{keywordflow}{if} (!stream->config.cfg.g\_w) \{
1454     \textcolor{keywordflow}{if} (!stream->config.cfg.g\_h)
1455       stream->config.cfg.g\_w = w;
1456     \textcolor{keywordflow}{else}
1457       stream->config.cfg.g\_w = w * stream->config.cfg.g\_h / h;
1458   \}
1459   \textcolor{keywordflow}{if} (!stream->config.cfg.g\_h) \{
1460     stream->config.cfg.g\_h = h * stream->config.cfg.g\_w / w;
1461   \}
1462 \}
1463 
1464 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *file\_type\_to\_string(\textcolor{keyword}{enum} VideoFileType t) \{
1465   \textcolor{keywordflow}{switch} (t) \{
1466   \textcolor{keywordflow}{case} FILE\_TYPE\_RAW: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"RAW"};
1467   \textcolor{keywordflow}{case} FILE\_TYPE\_Y4M: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Y4M"};
1468   \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Other"};
1469   \}
1470 \}
1471 
1472 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *image\_format\_to\_string(\hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} f) \{
1473   \textcolor{keywordflow}{switch} (f) \{
1474   \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I420"};
1475   \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I422"};
1476   \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I444"};
1477   \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cad28244100a2754409f285b77a3db90a0}{AOM\_IMG\_FMT\_YV12}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"YV12"};
1478   \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca6d845490a6333fca3ac22cc1105deadd}{AOM\_IMG\_FMT\_YV1216}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"YV1216"};
1479   \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I42016"};
1480   \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca064683ed4260fc6244af6cfc9d261c22}{AOM\_IMG\_FMT\_I42216}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I42216"};
1481   \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab9b93d397dedbdd6bfafec84d1f8f0f5}{AOM\_IMG\_FMT\_I44416}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I44416"};
1482   \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Other"};
1483   \}
1484 \}
1485 
1486 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_stream\_config(\textcolor{keyword}{struct} stream\_state *stream,
1487     \textcolor{keyword}{struct} AvxEncoderConfig *global,
1488     \textcolor{keyword}{struct} SparseConfig *sparse,
1489     \textcolor{keyword}{struct} AvxInputContext *input) \{
1490 \textcolor{preprocessor}{#define SHOW(field) \(\backslash\)}
1491 \textcolor{preprocessor}{    fprintf(stderr, "    %-28s = %d\(\backslash\)n", #field, stream->config.cfg.field)}
1492 
1493   \textcolor{keywordflow}{if} (stream->index == 0) \{
1494     fprintf(stderr, \textcolor{stringliteral}{"Codec: %s\(\backslash\)n"},
1495         \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(global->codec->codec\_interface()));
1496     fprintf(stderr, \textcolor{stringliteral}{"Source file: %s File Type: %s Format: %s\(\backslash\)n"},
1497         input->filename, file\_type\_to\_string(input->file\_type),
1498         image\_format\_to\_string(input->fmt));
1499   \}
1500   \textcolor{keywordflow}{if} (stream->next || stream->index)
1501     fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)nStream Index: %d\(\backslash\)n"}, stream->index);
1502   fprintf(stderr, \textcolor{stringliteral}{"Destination file: %s\(\backslash\)n"}, stream->config.out\_fn);
1503   fprintf(stderr, \textcolor{stringliteral}{"Coding path: %s\(\backslash\)n"},
1504       stream->config.use\_16bit\_internal ? \textcolor{stringliteral}{"HBD"} : \textcolor{stringliteral}{"LBD"});
1505   fprintf(stderr, \textcolor{stringliteral}{"Encoder parameters:\(\backslash\)n"});
1506   fprintf(stderr, \textcolor{stringliteral}{"    sparse\_coding\(\backslash\)t\(\backslash\)t = %d\(\backslash\)n"}, sparse->sparse\_coding);
1507   \textcolor{keywordflow}{if}(sparse->sparse\_coding) \{
1508     fprintf(stderr, \textcolor{stringliteral}{"    k-Codewords\(\backslash\)t\(\backslash\)t\(\backslash\)t = %d\(\backslash\)n"}, sparse->k\_codewords);
1509     fprintf(stderr, \textcolor{stringliteral}{"    re-training\(\backslash\)t\(\backslash\)t\(\backslash\)t = %d\(\backslash\)n"}, sparse->train\_dict);
1510     fprintf(stderr, \textcolor{stringliteral}{"    Dict Algorithm\(\backslash\)t\(\backslash\)t = %d\(\backslash\)n"}, sparse->training);
1511     fprintf(stderr, \textcolor{stringliteral}{"    Sparse depth\(\backslash\)t\(\backslash\)t = %d\(\backslash\)n"}, sparse->sparse\_depth);
1512     fprintf(stderr, \textcolor{stringliteral}{"    Iterations\(\backslash\)t\(\backslash\)t\(\backslash\)t = %d\(\backslash\)n"}, sparse->iterations);
1513   \}
1514 
1515   SHOW(g\_usage);
1516   SHOW(g\_threads);
1517   SHOW(g\_profile);
1518   SHOW(g\_w);
1519   SHOW(g\_h);
1520   SHOW(g\_bit\_depth);
1521   SHOW(g\_input\_bit\_depth);
1522   SHOW(g\_timebase.num);
1523   SHOW(g\_timebase.den);
1524   SHOW(g\_error\_resilient);
1525   SHOW(g\_pass);
1526   SHOW(g\_lag\_in\_frames);
1527   SHOW(large\_scale\_tile);
1528   SHOW(rc\_dropframe\_thresh);
1529   SHOW(rc\_resize\_mode);
1530   SHOW(rc\_resize\_denominator);
1531   SHOW(rc\_resize\_kf\_denominator);
1532   SHOW(rc\_superres\_mode);
1533   SHOW(rc\_superres\_denominator);
1534   SHOW(rc\_superres\_kf\_denominator);
1535   SHOW(rc\_superres\_qthresh);
1536   SHOW(rc\_superres\_kf\_qthresh);
1537   SHOW(rc\_end\_usage);
1538   SHOW(rc\_target\_bitrate);
1539   SHOW(rc\_min\_quantizer);
1540   SHOW(rc\_max\_quantizer);
1541   SHOW(rc\_undershoot\_pct);
1542   SHOW(rc\_overshoot\_pct);
1543   SHOW(rc\_buf\_sz);
1544   SHOW(rc\_buf\_initial\_sz);
1545   SHOW(rc\_buf\_optimal\_sz);
1546   SHOW(rc\_2pass\_vbr\_bias\_pct);
1547   SHOW(rc\_2pass\_vbr\_minsection\_pct);
1548   SHOW(rc\_2pass\_vbr\_maxsection\_pct);
1549   SHOW(fwd\_kf\_enabled);
1550   SHOW(kf\_mode);
1551   SHOW(kf\_min\_dist);
1552   SHOW(kf\_max\_dist);
1553 \}
1554 
1555 \textcolor{keyword}{static} \textcolor{keywordtype}{void} open\_output\_file(\textcolor{keyword}{struct} stream\_state *stream,
1556     \textcolor{keyword}{struct} AvxEncoderConfig *global,
1557     \textcolor{keyword}{const} \textcolor{keyword}{struct} AvxRational *pixel\_aspect\_ratio) \{
1558   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fn = stream->config.out\_fn;
1559   \textcolor{keyword}{const} \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} *\textcolor{keyword}{const} cfg = &stream->config.cfg;
1560 
1561   \textcolor{keywordflow}{if} (cfg->\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} == \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS}) \textcolor{keywordflow}{return};
1562 
1563   stream->file = strcmp(fn, \textcolor{stringliteral}{"-"}) ? fopen(fn, \textcolor{stringliteral}{"wb"}) : set\_binary\_mode(stdout);
1564 
1565   \textcolor{keywordflow}{if} (!stream->file) fatal(\textcolor{stringliteral}{"Failed to open output file"});
1566 
1567   \textcolor{keywordflow}{if} (stream->config.write\_webm && fseek(stream->file, 0, SEEK\_CUR))
1568     fatal(\textcolor{stringliteral}{"WebM output to pipes not supported."});
1569 
1570 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1571   \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
1572     stream->webm\_ctx.stream = stream->file;
1573     \textcolor{keywordflow}{if} (write\_webm\_file\_header(&stream->webm\_ctx, &stream->encoder, cfg,
1574         stream->config.stereo\_fmt, global->codec->fourcc,
1575         pixel\_aspect\_ratio) != 0) \{
1576       fatal(\textcolor{stringliteral}{"WebM writer initialization failed."});
1577     \}
1578   \}
1579 \textcolor{preprocessor}{#else}
1580   (void)pixel\_aspect\_ratio;
1581 \textcolor{preprocessor}{#endif}
1582 
1583   \textcolor{keywordflow}{if} (!stream->config.write\_webm && stream->config.write\_ivf) \{
1584     ivf\_write\_file\_header(stream->file, cfg, global->codec->fourcc, 0);
1585   \}
1586 \}
1587 
1588 \textcolor{keyword}{static} \textcolor{keywordtype}{void} close\_output\_file(\textcolor{keyword}{struct} stream\_state *stream,
1589     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} fourcc) \{
1590   \textcolor{keyword}{const} \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} *\textcolor{keyword}{const} cfg = &stream->config.cfg;
1591 
1592   \textcolor{keywordflow}{if} (cfg->\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} == \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS}) \textcolor{keywordflow}{return};
1593 
1594 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1595   \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
1596     \textcolor{keywordflow}{if} (write\_webm\_file\_footer(&stream->webm\_ctx) != 0) \{
1597       fatal(\textcolor{stringliteral}{"WebM writer finalization failed."});
1598     \}
1599   \}
1600 \textcolor{preprocessor}{#endif}
1601 
1602   \textcolor{keywordflow}{if} (!stream->config.write\_webm && stream->config.write\_ivf) \{
1603     \textcolor{keywordflow}{if} (!fseek(stream->file, 0, SEEK\_SET))
1604       ivf\_write\_file\_header(stream->file, &stream->config.cfg, fourcc,
1605           stream->frames\_out);
1606   \}
1607 
1608   fclose(stream->file);
1609 \}
1610 
1611 \textcolor{keyword}{static} \textcolor{keywordtype}{void} setup\_pass(\textcolor{keyword}{struct} stream\_state *stream,
1612     \textcolor{keyword}{struct} AvxEncoderConfig *global, \textcolor{keywordtype}{int} pass) \{
1613   \textcolor{keywordflow}{if} (stream->config.stats\_fn) \{
1614     \textcolor{keywordflow}{if} (!stats\_open\_file(&stream->stats, stream->config.stats\_fn, pass))
1615       fatal(\textcolor{stringliteral}{"Failed to open statistics store"});
1616   \} \textcolor{keywordflow}{else} \{
1617     \textcolor{keywordflow}{if} (!stats\_open\_mem(&stream->stats, pass))
1618       fatal(\textcolor{stringliteral}{"Failed to open statistics store"});
1619   \}
1620 
1621 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
1622   \textcolor{keywordflow}{if} (stream->config.fpmb\_stats\_fn) \{
1623     \textcolor{keywordflow}{if} (!stats\_open\_file(&stream->fpmb\_stats, stream->config.fpmb\_stats\_fn,
1624         pass))
1625       fatal(\textcolor{stringliteral}{"Failed to open mb statistics store"});
1626   \} \textcolor{keywordflow}{else} \{
1627     \textcolor{keywordflow}{if} (!stats\_open\_mem(&stream->fpmb\_stats, pass))
1628       fatal(\textcolor{stringliteral}{"Failed to open mb statistics store"});
1629   \}
1630 \textcolor{preprocessor}{#endif}
1631 
1632   stream->config.cfg.g\_pass = global->passes == 2
1633       ? pass ? \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1a621c3f07937527618dc06e962425f6cc}{AOM\_RC\_LAST\_PASS} : \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS}
1634           : \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1a1b4b8ee9c1910fc59ac9dfd9700f3f02}{AOM\_RC\_ONE\_PASS};
1635   \textcolor{keywordflow}{if} (pass) \{
1636     stream->config.cfg.rc\_twopass\_stats\_in = stats\_get(&stream->stats);
1637 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
1638     stream->config.cfg.rc\_firstpass\_mb\_stats\_in =
1639         stats\_get(&stream->fpmb\_stats);
1640 \textcolor{preprocessor}{#endif}
1641   \}
1642 
1643   stream->cx\_time = 0;
1644   stream->nbytes = 0;
1645   stream->frames\_out = 0;
1646 \}
1647 
1648 \textcolor{keyword}{static} \textcolor{keywordtype}{void} initialize\_encoder(\textcolor{keyword}{struct} stream\_state *stream,
1649     \textcolor{keyword}{struct} AvxEncoderConfig *global) \{
1650   \textcolor{keywordtype}{int} i;
1651   \textcolor{keywordtype}{int} flags = 0;
1652 
1653   flags |= global->show\_psnr ? \hyperlink{group__encoder_gae722c9f9ba9b4ca8dba6bbe7c0692024}{AOM\_CODEC\_USE\_PSNR} : 0;
1654   flags |= stream->config.use\_16bit\_internal ? \hyperlink{group__encoder_gae30bbbdef18e9da3631b69c170533e92}{AOM\_CODEC\_USE\_HIGHBITDEPTH} : 0;
1655 
1656   \textcolor{comment}{/* Construct Encoder Context */}
1657   \hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&stream->encoder, global->codec->codec\_interface(),
1658       &stream->config.cfg, flags);
1659   ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to initialize encoder"});
1660 
1661   \textcolor{comment}{/* Note that we bypass the aom\_codec\_control wrapper macro because}
1662 \textcolor{comment}{   * we're being clever to store the control IDs in an array. Real}
1663 \textcolor{comment}{   * applications will want to make use of the enumerations directly}
1664 \textcolor{comment}{   */}
1665   \textcolor{keywordflow}{for} (i = 0; i < stream->config.arg\_ctrl\_cnt; i++) \{
1666     \textcolor{keywordtype}{int} ctrl = stream->config.arg\_ctrls[i][0];
1667     \textcolor{keywordtype}{int} value = stream->config.arg\_ctrls[i][1];
1668     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&stream->encoder, ctrl, value))
1669       fprintf(stderr, \textcolor{stringliteral}{"Error: Tried to set control %d = %d\(\backslash\)n"}, ctrl, value);
1670 
1671     ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to control codec"});
1672   \}
1673   \textcolor{keywordflow}{if} (stream->config.film\_grain\_filename) \{
1674     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad5846c6f49d37e65a03c39e68d487097}{AV1E\_SET\_FILM\_GRAIN\_TABLE},
1675         stream->config.film\_grain\_filename);
1676   \}
1677 
1678 \textcolor{preprocessor}{#if CONFIG\_AV1\_DECODER}
1679   \textcolor{keywordflow}{if} (global->test\_decode != TEST\_DECODE\_OFF) \{
1680     \textcolor{keyword}{const} AvxInterface *decoder = get\_aom\_decoder\_by\_name(global->codec->name);
1681     \hyperlink{structaom__codec__dec__cfg}{aom\_codec\_dec\_cfg\_t} cfg = \{ 0, 0, 0, CONFIG\_LOWBITDEPTH, \{ 1 \} \};
1682     \hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&stream->decoder, decoder->codec\_interface(), &
      \hyperlink{structaom__codec__enc__cfg_a91c4b8e91211a9cea98a8003ef2e4e65}{cfg}, 0);
1683 
1684     \textcolor{keywordflow}{if} (strcmp(global->codec->name, \textcolor{stringliteral}{"av1"}) == 0) \{
1685       \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE},
1686           stream->config.cfg.large\_scale\_tile);
1687       ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to set decode\_tile\_mode"});
1688 
1689       \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba1fb269c5c5913d9995b6c35d28e2a788}{AV1D\_SET\_IS\_ANNEXB},
1690           stream->config.cfg.save\_as\_annexb);
1691       ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to set is\_annexb"});
1692 
1693       \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, 
      \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bac056b4cf80427fd05e3c4c9fc46edb78}{AV1\_SET\_DECODE\_TILE\_ROW}, -1);
1694       ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to set decode\_tile\_row"});
1695 
1696       \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, AV1\_SET\_DECODE\_TILE\_COL, -1);
1697       ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to set decode\_tile\_col"});
1698     \}
1699   \}
1700 \textcolor{preprocessor}{#endif}
1701 \}
1702 
1703 \textcolor{keyword}{static} \textcolor{keywordtype}{void} encode\_frame(\textcolor{keyword}{struct} stream\_state *stream,
1704     \textcolor{keyword}{struct} AvxEncoderConfig *global, \textcolor{keyword}{struct} \hyperlink{structaom__image}{aom\_image} *img,
1705     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frames\_in) \{
1706   \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} frame\_start, next\_frame\_start;
1707   \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} *cfg = &stream->config.cfg;
1708   \textcolor{keyword}{struct }aom\_usec\_timer timer;
1709 
1710   frame\_start =
1711       (cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} * (int64\_t)(frames\_in - 1) * global->framerate.den) /
1712       cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} / global->framerate.num;
1713   next\_frame\_start =
1714       (cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} * (int64\_t)(frames\_in)*global->framerate.den) /
1715       cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} / global->framerate.num;
1716 
1717   \textcolor{comment}{/* Scale if necessary */}
1718   \textcolor{keywordflow}{if} (img) \{
1719     \textcolor{keywordflow}{if} ((img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) &&
1720         (img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} != cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} || img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} != cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h})) \{
1721       \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}) \{
1722         fprintf(stderr, \textcolor{stringliteral}{"%s can only scale 4:2:0 inputs\(\backslash\)n"}, exec\_name);
1723         exit(EXIT\_FAILURE);
1724       \}
1725 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
1726       \textcolor{keywordflow}{if} (!stream->img) \{
1727         stream->img =
1728             \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(NULL, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}, cfg->
      \hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w}, cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h}, 16);
1729       \}
1730       I420Scale\_16(
1731           (uint16\_t *)img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_Y] / 2,
1732           (uint16\_t *)img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U] / 2,
1733           (uint16\_t *)img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V] / 2,
1734           img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, (uint16\_t *)stream->img->planes[AOM\_PLANE\_Y],
1735           stream->img->stride[AOM\_PLANE\_Y] / 2,
1736           (uint16\_t *)stream->img->planes[AOM\_PLANE\_U],
1737           stream->img->stride[AOM\_PLANE\_U] / 2,
1738           (uint16\_t *)stream->img->planes[AOM\_PLANE\_V],
1739           stream->img->stride[AOM\_PLANE\_V] / 2, stream->img->d\_w,
1740           stream->img->d\_h, kFilterBox);
1741       img = stream->img;
1742 \textcolor{preprocessor}{#else}
1743       stream->encoder.err = 1;
1744       ctx\_exit\_on\_error(&stream->encoder,
1745           \textcolor{stringliteral}{"Stream %d: Failed to encode frame.\(\backslash\)n"}
1746           \textcolor{stringliteral}{"libyuv is required for scaling but is currently "}
1747           \textcolor{stringliteral}{"disabled.\(\backslash\)n"}
1748           \textcolor{stringliteral}{"Be sure to specify -DCONFIG\_LIBYUV=1 when running "}
1749           \textcolor{stringliteral}{"cmake.\(\backslash\)n"},
1750           stream->index);
1751 \textcolor{preprocessor}{#endif}
1752     \}
1753   \}
1754   \textcolor{keywordflow}{if} (img && (img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} != cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} || img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} != cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h})) \{
1755     \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} && img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != 
      \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cad28244100a2754409f285b77a3db90a0}{AOM\_IMG\_FMT\_YV12}) \{
1756       fprintf(stderr, \textcolor{stringliteral}{"%s can only scale 4:2:0 8bpp inputs\(\backslash\)n"}, exec\_name);
1757       exit(EXIT\_FAILURE);
1758     \}
1759 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
1760     \textcolor{keywordflow}{if} (!stream->img)
1761       stream->img =
1762           \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(NULL, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, cfg->
      \hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w}, cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h}, 16);
1763     I420Scale(
1764         img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
1765         img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U],
1766         img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V], img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->
      \hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h},
1767         stream->img->planes[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], stream->img->stride[
      \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
1768         stream->img->planes[AOM\_PLANE\_U], stream->img->stride[AOM\_PLANE\_U],
1769         stream->img->planes[AOM\_PLANE\_V], stream->img->stride[AOM\_PLANE\_V],
1770         stream->img->d\_w, stream->img->d\_h, kFilterBox);
1771     img = stream->img;
1772 \textcolor{preprocessor}{#else}
1773     stream->encoder.err = 1;
1774     ctx\_exit\_on\_error(&stream->encoder,
1775         \textcolor{stringliteral}{"Stream %d: Failed to encode frame.\(\backslash\)n"}
1776         \textcolor{stringliteral}{"Scaling disabled in this configuration. \(\backslash\)n"}
1777         \textcolor{stringliteral}{"To enable, configure with --enable-libyuv\(\backslash\)n"},
1778         stream->index);
1779 \textcolor{preprocessor}{#endif}
1780   \}
1781 
1782   aom\_usec\_timer\_start(&timer);
1783   \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(&stream->encoder, img, frame\_start,
1784       (uint32\_t)(next\_frame\_start - frame\_start), 0);
1785   aom\_usec\_timer\_mark(&timer);
1786   stream->cx\_time += aom\_usec\_timer\_elapsed(&timer);
1787   ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Stream %d: Failed to encode frame"},
1788       stream->index);
1789 \}
1790 
1791 \textcolor{keyword}{static} \textcolor{keywordtype}{void} update\_quantizer\_histogram(\textcolor{keyword}{struct} stream\_state *stream) \{
1792   \textcolor{keywordflow}{if} (stream->config.cfg.g\_pass != \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS}) \{
1793     \textcolor{keywordtype}{int} q;
1794 
1795     \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a17b924cadd3c942f9e57fe6fc4d5e2ab}{AOME\_GET\_LAST\_QUANTIZER\_64}, &q);
1796     ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to read quantizer"});
1797     stream->counts[q]++;
1798   \}
1799 \}
1800 
1801 \textcolor{keyword}{static} \textcolor{keywordtype}{void} get\_cx\_data(\textcolor{keyword}{struct} stream\_state *stream,
1802     \textcolor{keyword}{struct} AvxEncoderConfig *global, \textcolor{keywordtype}{int} *got\_data) \{
1803   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt;
1804   \textcolor{keyword}{const} \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} *cfg = &stream->config.cfg;
1805   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
1806 
1807   *got\_data = 0;
1808   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(&stream->encoder, &iter))) \{
1809     \textcolor{keyword}{static} \textcolor{keywordtype}{size\_t} fsize = 0;
1810     \textcolor{keyword}{static} FileOffset ivf\_header\_pos = 0;
1811 
1812     \textcolor{keywordflow}{switch} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind}) \{
1813     \textcolor{keywordflow}{case} \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}:
1814       ++stream->frames\_out;
1815       \textcolor{keywordflow}{if} (!global->quiet)
1816         fprintf(stderr, \textcolor{stringliteral}{" %6luF"}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz);
1817 
1818       update\_rate\_histogram(stream->rate\_hist, cfg, pkt);
1819 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1820       \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
1821         \textcolor{keywordflow}{if} (write\_webm\_block(&stream->webm\_ctx, cfg, pkt) != 0) \{
1822           fatal(\textcolor{stringliteral}{"WebM writer failed."});
1823         \}
1824       \}
1825 \textcolor{preprocessor}{#endif}
1826       \textcolor{keywordflow}{if} (!stream->config.write\_webm) \{
1827         \textcolor{keywordflow}{if} (stream->config.write\_ivf) \{
1828           \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.partition\_id <= 0) \{
1829             ivf\_header\_pos = ftello(stream->file);
1830             fsize = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz;
1831 
1832             ivf\_write\_frame\_header(stream->file, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts, fsize);
1833           \} \textcolor{keywordflow}{else} \{
1834             fsize += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz;
1835 
1836             \textcolor{keyword}{const} FileOffset currpos = ftello(stream->file);
1837             fseeko(stream->file, ivf\_header\_pos, SEEK\_SET);
1838             ivf\_write\_frame\_size(stream->file, fsize);
1839             fseeko(stream->file, currpos, SEEK\_SET);
1840           \}
1841         \}
1842 
1843         (void)fwrite(pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf, 1, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
1844             stream->file);
1845       \}
1846       stream->nbytes += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4fc6ea5e240c5df0acbf77aa2fe5ec6f}{raw}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
1847 
1848       *got\_data = 1;
1849 \textcolor{preprocessor}{#if CONFIG\_AV1\_DECODER}
1850       \textcolor{keywordflow}{if} (global->test\_decode != TEST\_DECODE\_OFF && !stream->mismatch\_seen) \{
1851         \hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&stream->decoder, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
1852             pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz, NULL);
1853         \textcolor{keywordflow}{if} (stream->decoder.err) \{
1854           warn\_or\_exit\_on\_error(&stream->decoder,
1855               global->test\_decode == TEST\_DECODE\_FATAL,
1856               \textcolor{stringliteral}{"Failed to decode frame %d in stream %d"},
1857               stream->frames\_out + 1, stream->index);
1858           stream->mismatch\_seen = stream->frames\_out + 1;
1859         \}
1860       \}
1861 \textcolor{preprocessor}{#endif}
1862       \textcolor{keywordflow}{break};
1863     \textcolor{keywordflow}{case} \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda7dcdcb6c401cac64ca98b51f52de8d4b}{AOM\_CODEC\_STATS\_PKT}:
1864       stream->frames\_out++;
1865       stats\_write(&stream->stats, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf},
1866           pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz});
1867       stream->nbytes += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4fc6ea5e240c5df0acbf77aa2fe5ec6f}{raw}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
1868       \textcolor{keywordflow}{break};
1869 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
1870     \textcolor{keywordflow}{case} \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfedaaa76df44da4c92b08150b8a5326f5ebe}{AOM\_CODEC\_FPMB\_STATS\_PKT}:
1871       stats\_write(&stream->fpmb\_stats, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a8ce39bab39da5a247a27e42eb78386e2}{firstpass\_mb\_stats}.
      \hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf},
1872           pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a8ce39bab39da5a247a27e42eb78386e2}{firstpass\_mb\_stats}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz});
1873       stream->nbytes += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4fc6ea5e240c5df0acbf77aa2fe5ec6f}{raw}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
1874       \textcolor{keywordflow}{break};
1875 \textcolor{preprocessor}{#endif}
1876     \textcolor{keywordflow}{case} \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda3293bb764f30c11e9583510029578b75}{AOM\_CODEC\_PSNR\_PKT}:
1877 
1878       \textcolor{keywordflow}{if} (global->show\_psnr) \{
1879         \textcolor{keywordtype}{int} i;
1880 
1881         stream->psnr\_sse\_total += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a3a38e942aa0da463260a05eb05f51762}{psnr}.sse[0];
1882         stream->psnr\_samples\_total += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a3a38e942aa0da463260a05eb05f51762}{psnr}.samples[0];
1883         \textcolor{keywordflow}{for} (i = 0; i < 4; i++) \{
1884           \textcolor{keywordflow}{if} (!global->quiet)
1885             fprintf(stderr, \textcolor{stringliteral}{"%.3f "}, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a3a38e942aa0da463260a05eb05f51762}{psnr}.psnr[i]);
1886           stream->psnr\_totals[i] += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a3a38e942aa0da463260a05eb05f51762}{psnr}.psnr[i];
1887         \}
1888         stream->psnr\_count++;
1889       \}
1890 
1891       \textcolor{keywordflow}{break};
1892     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};
1893     \}
1894   \}
1895 \}
1896 
1897 \textcolor{keyword}{static} \textcolor{keywordtype}{float} calculate\_threshold(\textcolor{keyword}{struct} AvxInputContext *sparse\_input\_ctx, \textcolor{keywordtype}{int} limit\_frame) \{
1898   \hyperlink{structaom__image}{aom\_image\_t} raw\_thres;
1899   image\_t image;
1900   \textcolor{keywordtype}{char} filename[60] = \textcolor{stringliteral}{""};
1901 
1902   \textcolor{keywordtype}{int} frame\_availaible = 1;
1903   \textcolor{keywordtype}{int} frame\_calculated = 0;
1904   \textcolor{keywordtype}{float} difference = 0;
1905 
1906   \textcolor{keywordflow}{if} (sparse\_input\_ctx->file\_type == FILE\_TYPE\_Y4M)\{
1907     memset(&raw\_thres, 0, \textcolor{keyword}{sizeof}(raw\_thres));
1908   \} \textcolor{keywordflow}{else} \{
1909     \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw\_thres, sparse\_input\_ctx->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt}, sparse\_input\_ctx->width, 
      sparse\_input\_ctx->height, 32);
1910   \}
1911   image\_alloc(&image, raw\_thres.\hyperlink{structaom__image_a695141e492ab146dc15e8131827eb237}{w}, raw\_thres.\hyperlink{structaom__image_a3fcffff0a25a4fd9218ed38842014ef2}{h});
1912 
1913   \textcolor{comment}{// read first frame}
1914   read\_frame(sparse\_input\_ctx, &raw\_thres);
1915 
1916   \textcolor{keywordtype}{int} histogram\_size = 1 << raw\_thres.\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth};
1917 
1918   \textcolor{keywordtype}{float} *histogram\_raw = (\textcolor{keywordtype}{float}*)calloc(histogram\_size, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}));
1919   \textcolor{keywordtype}{float} *histogram\_raw\_previous = (\textcolor{keywordtype}{float}*)calloc(histogram\_size, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}));
1920   \textcolor{keywordtype}{float} *histogram\_diff = (\textcolor{keywordtype}{float}*)calloc(histogram\_size, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}));
1921 
1922   \textcolor{comment}{// calculate histogram for first frame}
1923   calculate\_histogram(raw\_thres.\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], raw\_thres.
      \hyperlink{structaom__image_a695141e492ab146dc15e8131827eb237}{w}, raw\_thres.\hyperlink{structaom__image_a3fcffff0a25a4fd9218ed38842014ef2}{h}, histogram\_raw\_previous);
1924   frame\_calculated++;
1925 
1926   \textcolor{keywordflow}{while} (frame\_availaible) \{
1927     \textcolor{keywordflow}{if} (!limit\_frame|| frame\_calculated < limit\_frame) \{
1928       frame\_availaible = read\_frame(sparse\_input\_ctx, &raw\_thres);
1929       \textcolor{keywordflow}{if} (frame\_availaible)
1930         frame\_calculated++;
1931 
1932       calculate\_histogram(raw\_thres.\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], raw\_thres.
      \hyperlink{structaom__image_a695141e492ab146dc15e8131827eb237}{w}, raw\_thres.\hyperlink{structaom__image_a3fcffff0a25a4fd9218ed38842014ef2}{h}, histogram\_raw);
1933       difference += normalized\_histogram\_difference(histogram\_raw, histogram\_raw\_previous, histogram\_diff, 
      raw\_thres.\hyperlink{structaom__image_a695141e492ab146dc15e8131827eb237}{w} * raw\_thres.\hyperlink{structaom__image_a3fcffff0a25a4fd9218ed38842014ef2}{h}, histogram\_size);
1934 
1935       memcpy(histogram\_raw\_previous, histogram\_raw, histogram\_size * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));
1936       memset(histogram\_raw, 0, histogram\_size * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}));
1937 
1938       fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)rCalculate histogram difference to frame %d"}, frame\_calculated);
1939     \} \textcolor{keywordflow}{else} \{
1940       frame\_availaible = 0;
1941     \}
1942 
1943   \}
1944 
1945   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)ndifference: %f\(\backslash\)n"}, difference/frame\_calculated);
1946 
1947   \textcolor{keywordtype}{float} total\_values = 0;
1948   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < histogram\_size; i++) \{
1949     total\_values += histogram\_diff[i];
1950   \}
1951 
1952   \textcolor{keywordtype}{float} mean = histogram\_mean(histogram\_diff, total\_values, histogram\_size);
1953   \textcolor{keywordtype}{float} deviation = histogram\_deviation(histogram\_diff, mean, total\_values, histogram\_size);
1954 
1955   free(histogram\_raw);
1956   free(histogram\_raw\_previous);
1957   free(histogram\_diff);
1958   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw\_thres);
1959 
1960   \textcolor{keywordflow}{return} mean + ((float)ALPHA\_THRES * deviation);
1961 \}
1962 
1963 \textcolor{keyword}{static} \textcolor{keywordtype}{bool} sparse\_analysis(\textcolor{keyword}{struct} AvxInputContext *sparse\_input\_ctx, \textcolor{keywordtype}{int} *frame\_in\_sparse, \textcolor{keywordtype}{int} frame\_in, 
      \hyperlink{structaom__image}{aom\_image\_t} *raw,
1964     \hyperlink{structaom__image}{aom\_image\_t} *raw\_to\_analyze, \textcolor{keywordtype}{int} threshold\_value) \{
1965 
1966   \textcolor{keywordtype}{char} filename[60] = \textcolor{stringliteral}{""};
1967   image\_t image\_local;
1968 
1969 
1970   strcpy(filename, \textcolor{stringliteral}{"/home/augusto/Downloads/images/image\_analysis"});
1971   sprintf(filename + strlen(filename), \textcolor{stringliteral}{"%d.jpg"}, *frame\_in\_sparse);
1972   copy\_image(raw->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], raw->\hyperlink{structaom__image_a695141e492ab146dc15e8131827eb237}{w}, &image\_local);
1973   write\_image(filename, &image\_local);
1974   \textcolor{comment}{/*}
1975 \textcolor{comment}{  int histogram\_size = 1 << raw->bit\_depth;}
1976 \textcolor{comment}{}
1978 \textcolor{comment}{  //float difference\_thres = 1000.0;}
1979 \textcolor{comment}{}
1980 \textcolor{comment}{  float *histogram\_raw = (float*)calloc(histogram\_size, sizeof(float));}
1981 \textcolor{comment}{  float *histogram\_raw\_analyze = (float*)calloc(histogram\_size, sizeof(float));}
1982 \textcolor{comment}{  float *histogram\_diff = (float*)calloc(histogram\_size, sizeof(float));}
1983 \textcolor{comment}{}
1984 \textcolor{comment}{  image\_alloc(&image\_local, raw\_to\_analyze->w, raw\_to\_analyze->h);}
1985 \textcolor{comment}{}
1986 \textcolor{comment}{  read\_frame(sparse\_input\_ctx, raw\_to\_analyze);}
1987 \textcolor{comment}{}
1988 \textcolor{comment}{}
1989 \textcolor{comment}{  int changed\_blocks = 0;}
1990 \textcolor{comment}{  bool change\_scene = false;}
1991 \textcolor{comment}{}
1992 \textcolor{comment}{}
1993 \textcolor{comment}{  /*}
1994 \textcolor{comment}{}
1995 \textcolor{comment}{}
1996 \textcolor{comment}{  if (changed\_blocks > ((rows * columns) / 2) + 1) \{}
1997 \textcolor{comment}{    fprintf(stderr, "change scene in frame %d\(\backslash\)n", *frame\_in\_sparse);}
1998 \textcolor{comment}{    change\_scene = true;}
1999 \textcolor{comment}{  \}}
2000 \textcolor{comment}{}
2001 \textcolor{comment}{  (*frame\_in\_sparse)++;}
2002 \textcolor{comment}{}
2003 \textcolor{comment}{  return change\_scene;}
2004 \textcolor{comment}{}
2005 \textcolor{comment}{}
2006 \textcolor{comment}{}
2007 \textcolor{comment}{  /*}
2008 \textcolor{comment}{  if( changed\_blocks > ((rows * columns) / 2) + 1)\{}
2009 \textcolor{comment}{    int i = 0;}
2010 \textcolor{comment}{     bool end\_read = false;}
2011 \textcolor{comment}{}
2012 \textcolor{comment}{     while(end\_read) \{}
2013 \textcolor{comment}{   *frame\_in\_sparse += 5;}
2014 \textcolor{comment}{}
2015 \textcolor{comment}{       if(*frame\_in\_sparse <= frame\_in) \{}
2016 \textcolor{comment}{         continue;}
2017 \textcolor{comment}{       \}}
2018 \textcolor{comment}{}
2019 \textcolor{comment}{       strcpy(filename, "/home/augusto/Downloads/images/image\_analysis");}
2020 \textcolor{comment}{       sprintf(filename + strlen(filename), "%d.jpg", *frame\_in\_sparse);}
2021 \textcolor{comment}{       copy\_image(raw\_to\_analyze->planes[AOM\_PLANE\_Y], raw\_to\_analyze->w, &image\_local);}
2022 \textcolor{comment}{       write\_image(filename, &image\_local);}
2023 \textcolor{comment}{       /*}
2024 \textcolor{comment}{     \}}
2025 \textcolor{comment}{  \}*/}
2026 
2027   \textcolor{keywordflow}{return} 0;
2028 \}
2029 
2030 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_psnr(\textcolor{keyword}{struct} stream\_state *stream, \textcolor{keywordtype}{double} peak, int64\_t bps) \{
2031   \textcolor{keywordtype}{int} i;
2032   \textcolor{keywordtype}{double} ovpsnr;
2033 
2034   \textcolor{keywordflow}{if} (!stream->psnr\_count) \textcolor{keywordflow}{return};
2035 
2036   fprintf(stderr, \textcolor{stringliteral}{"Stream %d PSNR (Overall/Avg/Y/U/V)"}, stream->index);
2037   ovpsnr = sse\_to\_psnr((\textcolor{keywordtype}{double})stream->psnr\_samples\_total, peak,
2038       (\textcolor{keywordtype}{double})stream->psnr\_sse\_total);
2039   fprintf(stderr, \textcolor{stringliteral}{" %.3f"}, ovpsnr);
2040 
2041   \textcolor{keywordflow}{for} (i = 0; i < 4; i++) \{
2042     fprintf(stderr, \textcolor{stringliteral}{" %.3f"}, stream->psnr\_totals[i] / stream->psnr\_count);
2043   \}
2044   \textcolor{keywordflow}{if} (bps > 0) \{
2045     fprintf(stderr, \textcolor{stringliteral}{" %7"} PRId64 \textcolor{stringliteral}{" bps"}, bps);
2046   \}
2047   fprintf(stderr, \textcolor{stringliteral}{" %7"} PRId64 \textcolor{stringliteral}{" ms"}, stream->cx\_time / 1000);
2048   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)n"});
2049 \}
2050 
2051 \textcolor{keyword}{static} \textcolor{keywordtype}{float} usec\_to\_fps(uint64\_t usec, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frames) \{
2052   \textcolor{keywordflow}{return} (\textcolor{keywordtype}{float})(usec > 0 ? frames * 1000000.0 / (float)usec : 0);
2053 \}
2054 
2055 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_decode(\textcolor{keyword}{struct} stream\_state *stream,
2056     \textcolor{keyword}{enum} TestDecodeFatality fatal) \{
2057   \hyperlink{structaom__image}{aom\_image\_t} enc\_img, dec\_img;
2058 
2059   \textcolor{keywordflow}{if} (stream->mismatch\_seen) \textcolor{keywordflow}{return};
2060 
2061   \textcolor{comment}{/* Get the internal reference frame */}
2062   \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a410c706a34f5295996658cc5044a700f}{AV1\_GET\_NEW\_FRAME\_IMAGE}, &
      enc\_img);
2063   \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a410c706a34f5295996658cc5044a700f}{AV1\_GET\_NEW\_FRAME\_IMAGE}, &
      dec\_img);
2064 
2065   \textcolor{keywordflow}{if} ((enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) !=
2066       (dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH})) \{
2067     \textcolor{keywordflow}{if} (enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
2068       \hyperlink{structaom__image}{aom\_image\_t} enc\_hbd\_img;
2069       \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&enc\_hbd\_img, enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} - 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
2070           enc\_img.\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, enc\_img.\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
2071       aom\_img\_truncate\_16\_to\_8(&enc\_hbd\_img, &enc\_img);
2072       enc\_img = enc\_hbd\_img;
2073     \}
2074     \textcolor{keywordflow}{if} (dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
2075       \hyperlink{structaom__image}{aom\_image\_t} dec\_hbd\_img;
2076       \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&dec\_hbd\_img, dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} - 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
2077           dec\_img.\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, dec\_img.\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
2078       aom\_img\_truncate\_16\_to\_8(&dec\_hbd\_img, &dec\_img);
2079       dec\_img = dec\_hbd\_img;
2080     \}
2081   \}
2082 
2083   ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to get encoder reference frame"});
2084   ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to get decoder reference frame"});
2085 
2086   \textcolor{keywordflow}{if} (!aom\_compare\_img(&enc\_img, &dec\_img)) \{
2087     \textcolor{keywordtype}{int} y[4], u[4], v[4];
2088     \textcolor{keywordflow}{if} (enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
2089       aom\_find\_mismatch\_high(&enc\_img, &dec\_img, y, u, v);
2090     \} \textcolor{keywordflow}{else} \{
2091       aom\_find\_mismatch(&enc\_img, &dec\_img, y, u, v);
2092     \}
2093     stream->decoder.err = 1;
2094     warn\_or\_exit\_on\_error(&stream->decoder, fatal == TEST\_DECODE\_FATAL,
2095         \textcolor{stringliteral}{"Stream %d: Encode/decode mismatch on frame %d at"}
2096         \textcolor{stringliteral}{" Y[%d, %d] \{%d/%d\},"}
2097         \textcolor{stringliteral}{" U[%d, %d] \{%d/%d\},"}
2098         \textcolor{stringliteral}{" V[%d, %d] \{%d/%d\}"},
2099         stream->index, stream->frames\_out, y[0], y[1], y[2],
2100         y[3], u[0], u[1], u[2], u[3], v[0], v[1], v[2], v[3]);
2101     stream->mismatch\_seen = stream->frames\_out;
2102   \}
2103 
2104   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&enc\_img);
2105   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&dec\_img);
2106 \}
2107 
2108 \textcolor{keyword}{static} \textcolor{keywordtype}{void} print\_time(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *label, int64\_t etl) \{
2109   int64\_t hours;
2110   int64\_t mins;
2111   int64\_t secs;
2112 
2113   \textcolor{keywordflow}{if} (etl >= 0) \{
2114     hours = etl / 3600;
2115     etl -= hours * 3600;
2116     mins = etl / 60;
2117     etl -= mins * 60;
2118     secs = etl;
2119 
2120     fprintf(stderr, \textcolor{stringliteral}{"[%3s %2"} PRId64 \textcolor{stringliteral}{":%02"} PRId64 \textcolor{stringliteral}{":%02"} PRId64 \textcolor{stringliteral}{"] "}, label,
2121         hours, mins, secs);
2122   \} \textcolor{keywordflow}{else} \{
2123     fprintf(stderr, \textcolor{stringliteral}{"[%3s  unknown] "}, label);
2124   \}
2125 \}
2126 
2127 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **argv\_) \{
2128   \textcolor{keywordtype}{int} pass;
2129   \hyperlink{structaom__image}{aom\_image\_t} raw;
2130   \hyperlink{structaom__image}{aom\_image\_t} raw\_shift;
2131 
2132   \textcolor{comment}{// image for sparse coding}
2133   \hyperlink{structaom__image}{aom\_image\_t} raw\_sparse;
2134   \hyperlink{structaom__image}{aom\_image\_t} raw\_to\_analyze;
2135 
2136   \textcolor{keywordtype}{int} allocated\_raw\_shift = 0;
2137   \textcolor{keywordtype}{int} use\_16bit\_internal = 0;
2138   \textcolor{keywordtype}{int} input\_shift = 0;
2139   \textcolor{keywordtype}{int} frame\_avail, got\_data;
2140 
2141   \textcolor{keyword}{struct }AvxInputContext input;
2142   \textcolor{keyword}{struct }AvxInputContext sparse\_input;
2143   \textcolor{keyword}{struct }AvxEncoderConfig global;
2144   \textcolor{keyword}{struct }SparseConfig sparse;
2145   \textcolor{keyword}{struct }stream\_state *streams = NULL;
2146   \textcolor{keywordtype}{char} **argv, **argi;
2147   uint64\_t cx\_time = 0;
2148   \textcolor{keywordtype}{int} stream\_cnt = 0;
2149   \textcolor{keywordtype}{int} res = 0;
2150   \textcolor{keywordtype}{int} profile\_updated = 0;
2151 
2152 
2153   \textcolor{comment}{// store sparse elements for 8x8, 16x16, 32x32, 64x64}
2154   \textcolor{keywordtype}{int} thres\_calculated = 0;
2155   \textcolor{keywordtype}{float} threshold;
2156 
2157   image\_t image;
2158 
2159   image\_t image\_result[4];
2160   dictionary\_t dictionaries[4];
2161   sample\_t samples\_dict[4];
2162   sparse\_coeff\_t sparse\_coeff[4];
2163 
2164   memset(&input, 0, \textcolor{keyword}{sizeof}(input));
2165   memset(&sparse\_input, 0, \textcolor{keyword}{sizeof}(sparse\_input));
2166   exec\_name = argv\_[0];
2167 
2168   \textcolor{comment}{/* Setup default input stream settings */}
2169   input.framerate.numerator = 30;
2170   input.framerate.denominator = 1;
2171   input.only\_i420 = 1;
2172   input.bit\_depth = 0;
2173 
2174   \textcolor{comment}{/* First parse the global configuration values, because we want to apply}
2175 \textcolor{comment}{   * other parameters on top of the default configuration provided by the}
2176 \textcolor{comment}{   * codec.}
2177 \textcolor{comment}{   */}
2178   argv = argv\_dup(argc - 1, argv\_ + 1);
2179   parse\_global\_config(&global, argc, &argv);
2180   parse\_sparse\_config(&sparse, &argv, input.height);
2181 
2182 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
2183   \textcolor{keywordflow}{if} (argc < 2) usage\_exit();
2184 \textcolor{preprocessor}{#else}
2185   \textcolor{keywordflow}{if} (argc < 3) usage\_exit();
2186 \textcolor{preprocessor}{#endif}
2187 
2188   \textcolor{keywordflow}{switch} (global.color\_type) \{
2189   \textcolor{keywordflow}{case} I420: input.fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}; \textcolor{keywordflow}{break};
2190   \textcolor{keywordflow}{case} I422: input.fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422}; \textcolor{keywordflow}{break};
2191   \textcolor{keywordflow}{case} I444: input.fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444}; \textcolor{keywordflow}{break};
2192   \textcolor{keywordflow}{case} YV12: input.fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cad28244100a2754409f285b77a3db90a0}{AOM\_IMG\_FMT\_YV12}; \textcolor{keywordflow}{break};
2193   \}
2194 
2195   \{
2196     \textcolor{comment}{/* Now parse each stream's parameters. Using a local scope here}
2197 \textcolor{comment}{     * due to the use of 'stream' as loop variable in FOREACH\_STREAM}
2198 \textcolor{comment}{     * loops}
2199 \textcolor{comment}{     */}
2200     \textcolor{keyword}{struct }stream\_state *stream = NULL;
2201 
2202     \textcolor{keywordflow}{do} \{
2203       stream = new\_stream(&global, stream);
2204       stream\_cnt++;
2205       \textcolor{keywordflow}{if} (!streams) streams = stream;
2206     \} \textcolor{keywordflow}{while} (parse\_stream\_params(&global, stream, argv));
2207   \}
2208 
2209   \textcolor{comment}{/* Check for unrecognized options */}
2210   \textcolor{keywordflow}{for} (argi = argv; *argi; argi++)
2211     \textcolor{keywordflow}{if} (argi[0][0] == \textcolor{charliteral}{'-'} && argi[0][1])
2212       die(\textcolor{stringliteral}{"Error: Unrecognized option %s\(\backslash\)n"}, *argi);
2213 
2214   FOREACH\_STREAM(stream, streams) \{
2215     check\_encoder\_config(global.disable\_warning\_prompt, &global,
2216         &stream->config.cfg);
2217   \}
2218 
2219   \textcolor{comment}{/* Handle non-option arguments */}
2220   input.filename = argv[0];
2221 
2222   \textcolor{keywordflow}{if} (!input.filename) \{
2223     fprintf(stderr, \textcolor{stringliteral}{"No input file specified!\(\backslash\)n"});
2224     usage\_exit();
2225   \}
2226 
2227   \textcolor{comment}{/* Decide if other chroma subsamplings than 4:2:0 are supported */}
2228   \textcolor{keywordflow}{if} (global.codec->fourcc == AV1\_FOURCC) input.only\_i420 = 0;
2229 
2230   \textcolor{keywordflow}{for} (pass = global.pass ? global.pass - 1 : 0; pass < global.passes; pass++) \{
2231     \textcolor{keywordtype}{int} frames\_in = 0, seen\_frames = 0, frames\_in\_sparse = 0;
2232     int64\_t estimated\_time\_left = -1;
2233     int64\_t average\_rate = -1;
2234     int64\_t lagged\_count = 0;
2235 
2236     open\_input\_file(&input, global.csp);
2237 
2238     \textcolor{comment}{/* If the input file doesn't specify its w/h (raw files), try to get}
2239 \textcolor{comment}{     * the data from the first stream's configuration.}
2240 \textcolor{comment}{     */}
2241     \textcolor{keywordflow}{if} (!input.width || !input.height) \{
2242       FOREACH\_STREAM(stream, streams) \{
2243         \textcolor{keywordflow}{if} (stream->config.cfg.g\_w && stream->config.cfg.g\_h) \{
2244           input.width = stream->config.cfg.g\_w;
2245           input.height = stream->config.cfg.g\_h;
2246           \textcolor{keywordflow}{break};
2247         \}
2248       \};
2249     \}
2250 
2251     \textcolor{comment}{/* Update stream configurations from the input file's parameters */}
2252     \textcolor{keywordflow}{if} (!input.width || !input.height)
2253       fatal(
2254           \textcolor{stringliteral}{"Specify stream dimensions with --width (-w) "}
2255           \textcolor{stringliteral}{" and --height (-h)"});
2256 
2257     \textcolor{comment}{/* If input file does not specify bit-depth but input-bit-depth parameter}
2258 \textcolor{comment}{     * exists, assume that to be the input bit-depth. However, if the}
2259 \textcolor{comment}{     * input-bit-depth paramter does not exist, assume the input bit-depth}
2260 \textcolor{comment}{     * to be the same as the codec bit-depth.}
2261 \textcolor{comment}{     */}
2262     \textcolor{keywordflow}{if} (!input.bit\_depth) \{
2263       FOREACH\_STREAM(stream, streams) \{
2264         \textcolor{keywordflow}{if} (stream->config.cfg.g\_input\_bit\_depth)
2265           input.bit\_depth = stream->config.cfg.g\_input\_bit\_depth;
2266         \textcolor{keywordflow}{else}
2267           input.bit\_depth = stream->config.cfg.g\_input\_bit\_depth =
2268               (int)stream->config.cfg.g\_bit\_depth;
2269       \}
2270       \textcolor{keywordflow}{if} (input.bit\_depth > 8) input.fmt |= \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH};
2271     \} \textcolor{keywordflow}{else} \{
2272       FOREACH\_STREAM(stream, streams) \{
2273         stream->config.cfg.g\_input\_bit\_depth = input.bit\_depth;
2274       \}
2275     \}
2276 
2277     FOREACH\_STREAM(stream, streams) \{
2278       \textcolor{keywordflow}{if} (input.fmt != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} && input.fmt != 
      \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}) \{
2279         \textcolor{comment}{/* Automatically upgrade if input is non-4:2:0 but a 4:2:0 profile}
2280 \textcolor{comment}{           was selected. */}
2281         \textcolor{keywordflow}{switch} (stream->config.cfg.g\_profile) \{
2282         \textcolor{keywordflow}{case} 0:
2283           \textcolor{keywordflow}{if} (input.bit\_depth < 12 && (input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444} ||
2284               input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab9b93d397dedbdd6bfafec84d1f8f0f5}{AOM\_IMG\_FMT\_I44416})) \{
2285             \textcolor{keywordflow}{if} (!stream->config.cfg.monochrome) \{
2286               stream->config.cfg.g\_profile = 1;
2287               profile\_updated = 1;
2288             \}
2289           \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth == 12 || input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422} ||
2290               input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca064683ed4260fc6244af6cfc9d261c22}{AOM\_IMG\_FMT\_I42216}) \{
2291             stream->config.cfg.g\_profile = 2;
2292             profile\_updated = 1;
2293           \}
2294           \textcolor{keywordflow}{break};
2295         \textcolor{keywordflow}{case} 1:
2296           \textcolor{keywordflow}{if} (input.bit\_depth == 12 || input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422} ||
2297               input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca064683ed4260fc6244af6cfc9d261c22}{AOM\_IMG\_FMT\_I42216}) \{
2298             stream->config.cfg.g\_profile = 2;
2299             profile\_updated = 1;
2300           \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth < 12 &&
2301               (input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} ||
2302                   input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016})) \{
2303             stream->config.cfg.g\_profile = 0;
2304             profile\_updated = 1;
2305           \}
2306           \textcolor{keywordflow}{break};
2307         \textcolor{keywordflow}{case} 2:
2308           \textcolor{keywordflow}{if} (input.bit\_depth < 12 && (input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444} ||
2309               input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab9b93d397dedbdd6bfafec84d1f8f0f5}{AOM\_IMG\_FMT\_I44416})) \{
2310             stream->config.cfg.g\_profile = 1;
2311             profile\_updated = 1;
2312           \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth < 12 &&
2313               (input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} ||
2314                   input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016})) \{
2315             stream->config.cfg.g\_profile = 0;
2316             profile\_updated = 1;
2317           \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth == 12 &&
2318               input.file\_type == FILE\_TYPE\_Y4M) \{
2319             \textcolor{comment}{// Note that here the input file values for chroma subsampling}
2320             \textcolor{comment}{// are used instead of those from the command line.}
2321             \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a283dd3f4387e5f3a754fea0d206b1cb0}{AV1E\_SET\_CHROMA\_SUBSAMPLING\_X},
2322                 input.y4m.dst\_c\_dec\_h >> 1);
2323             \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a501a9453d5790f32c001e9877d3db40c}{AV1E\_SET\_CHROMA\_SUBSAMPLING\_Y},
2324                 input.y4m.dst\_c\_dec\_v >> 1);
2325           \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth == 12 &&
2326               input.file\_type == FILE\_TYPE\_RAW) \{
2327             \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a283dd3f4387e5f3a754fea0d206b1cb0}{AV1E\_SET\_CHROMA\_SUBSAMPLING\_X},
2328                 stream->chroma\_subsampling\_x);
2329             \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a501a9453d5790f32c001e9877d3db40c}{AV1E\_SET\_CHROMA\_SUBSAMPLING\_Y},
2330                 stream->chroma\_subsampling\_y);
2331           \}
2332           \textcolor{keywordflow}{break};
2333         \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};
2334         \}
2335       \}
2336       \textcolor{comment}{/* Automatically set the codec bit depth to match the input bit depth.}
2337 \textcolor{comment}{       * Upgrade the profile if required. */}
2338       \textcolor{keywordflow}{if} (stream->config.cfg.g\_input\_bit\_depth >
2339           (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})stream->config.cfg.g\_bit\_depth) \{
2340         stream->config.cfg.g\_bit\_depth = stream->config.cfg.g\_input\_bit\_depth;
2341         \textcolor{keywordflow}{if} (!global.quiet) \{
2342           fprintf(stderr,
2343               \textcolor{stringliteral}{"Warning: automatically updating bit depth to %d to "}
2344               \textcolor{stringliteral}{"match input format.\(\backslash\)n"},
2345               stream->config.cfg.g\_input\_bit\_depth);
2346         \}
2347       \}
2348       \textcolor{keywordflow}{if} (stream->config.cfg.g\_bit\_depth > 10) \{
2349         \textcolor{keywordflow}{switch} (stream->config.cfg.g\_profile) \{
2350         \textcolor{keywordflow}{case} 0:
2351         \textcolor{keywordflow}{case} 1:
2352           stream->config.cfg.g\_profile = 2;
2353           profile\_updated = 1;
2354           \textcolor{keywordflow}{break};
2355         \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};
2356         \}
2357       \}
2358       \textcolor{keywordflow}{if} (stream->config.cfg.g\_bit\_depth > 8) \{
2359         stream->config.use\_16bit\_internal = 1;
2360       \}
2361       \textcolor{keywordflow}{if} (profile\_updated && !global.quiet) \{
2362         fprintf(stderr,
2363             \textcolor{stringliteral}{"Warning: automatically updating to profile %d to "}
2364             \textcolor{stringliteral}{"match input format.\(\backslash\)n"},
2365             stream->config.cfg.g\_profile);
2366       \}
2367       \textcolor{comment}{/* Set limit */}
2368       stream->config.cfg.g\_limit = global.limit;
2369     \}
2370 
2371     FOREACH\_STREAM(stream, streams) \{
2372       set\_stream\_dimensions(stream, input.width, input.height);
2373     \}
2374     FOREACH\_STREAM(stream, streams) \{ validate\_stream\_config(stream, &global); \}
2375 
2376     \textcolor{comment}{/* Ensure that --passes and --pass are consistent. If --pass is set and}
2377 \textcolor{comment}{     * --passes=2, ensure --fpf was set.}
2378 \textcolor{comment}{     */}
2379     \textcolor{keywordflow}{if} (global.pass && global.passes == 2) \{
2380       FOREACH\_STREAM(stream, streams) \{
2381         \textcolor{keywordflow}{if} (!stream->config.stats\_fn)
2382           die(\textcolor{stringliteral}{"Stream %d: Must specify --fpf when --pass=%d"}
2383               \textcolor{stringliteral}{" and --passes=2\(\backslash\)n"},
2384               stream->index, global.pass);
2385       \}
2386     \}
2387 
2388 \textcolor{preprocessor}{#if !CONFIG\_WEBM\_IO}
2389     FOREACH\_STREAM(stream, streams) \{
2390       \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
2391         stream->config.write\_webm = 0;
2392         stream->config.write\_ivf = 0;
2393         warn(\textcolor{stringliteral}{"aomenc compiled w/o WebM support. Writing OBU stream."});
2394       \}
2395     \}
2396 \textcolor{preprocessor}{#endif}
2397 
2398     \textcolor{comment}{/* Use the frame rate from the file only if none was specified}
2399 \textcolor{comment}{     * on the command-line.}
2400 \textcolor{comment}{     */}
2401     \textcolor{keywordflow}{if} (!global.have\_framerate) \{
2402       global.framerate.num = input.framerate.numerator;
2403       global.framerate.den = input.framerate.denominator;
2404     \}
2405     FOREACH\_STREAM(stream, streams) \{
2406       stream->config.cfg.g\_timebase.den = global.framerate.num;
2407       stream->config.cfg.g\_timebase.num = global.framerate.den;
2408     \}
2409     \textcolor{comment}{/* Show configuration */}
2410     \textcolor{keywordflow}{if} (global.verbose && pass == 0) \{
2411       FOREACH\_STREAM(stream, streams) \{
2412         show\_stream\_config(stream, &global, &sparse, &input);
2413       \}
2414     \}
2415 
2416     \textcolor{keywordflow}{if} (pass == (global.pass ? global.pass - 1 : 0)) \{
2417       \textcolor{keywordflow}{if} (input.file\_type == FILE\_TYPE\_Y4M)\{
2418         \textcolor{comment}{/*The Y4M reader does its own allocation.}
2419 \textcolor{comment}{          Just initialize this here to avoid problems if we never read any}
2420 \textcolor{comment}{          frames.*/}
2421         memset(&raw, 0, \textcolor{keyword}{sizeof}(raw));
2422         \textcolor{keywordflow}{if} (sparse.sparse\_coding) \{
2423           memset(&raw\_sparse, 0, \textcolor{keyword}{sizeof}(raw\_sparse));
2424           memset(&raw\_to\_analyze, 0, \textcolor{keyword}{sizeof}(raw\_to\_analyze));
2425         \}
2426       \} \textcolor{keywordflow}{else} \{
2427         \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, input.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt}, input.width, input.height, 32);
2428         \textcolor{keywordflow}{if} (sparse.sparse\_coding) \{
2429           \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw\_sparse, input.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt}, input.width, input.height, 32);
2430           \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw\_to\_analyze, input.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt}, input.width, input.height, 32);
2431         \}
2432       \}
2433 
2434       FOREACH\_STREAM(stream, streams) \{
2435         stream->rate\_hist =
2436             init\_rate\_histogram(&stream->config.cfg, &global.framerate);
2437       \}
2438     \}
2439 
2440     FOREACH\_STREAM(stream, streams) \{ setup\_pass(stream, &global, pass); \}
2441     FOREACH\_STREAM(stream, streams) \{ initialize\_encoder(stream, &global); \}
2442     FOREACH\_STREAM(stream, streams) \{
2443       open\_output\_file(stream, &global, &input.pixel\_aspect\_ratio);
2444     \}
2445 
2446     \textcolor{keywordflow}{if} (strcmp(global.codec->name, \textcolor{stringliteral}{"av1"}) == 0 ||
2447         strcmp(global.codec->name, \textcolor{stringliteral}{"av1"}) == 0) \{
2448       \textcolor{comment}{// Check to see if at least one stream uses 16 bit internal.}
2449       \textcolor{comment}{// Currently assume that the bit\_depths for all streams using}
2450       \textcolor{comment}{// highbitdepth are the same.}
2451       FOREACH\_STREAM(stream, streams) \{
2452         \textcolor{keywordflow}{if} (stream->config.use\_16bit\_internal) \{
2453           use\_16bit\_internal = 1;
2454         \}
2455         input\_shift = (int)stream->config.cfg.g\_bit\_depth -
2456             stream->config.cfg.g\_input\_bit\_depth;
2457       \};
2458     \}
2459 
2460     frame\_avail = 1;
2461     got\_data = 0;
2462 
2463     \textcolor{keywordtype}{char} filename[60] = \textcolor{stringliteral}{""};
2464     \textcolor{keywordtype}{char} filename\_sparse[60] = \textcolor{stringliteral}{""};
2465     \textcolor{keywordtype}{char} filename\_recon[60] = \textcolor{stringliteral}{""};
2466 
2467     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} block\_size = 8;
2468 
2469     \textcolor{comment}{// allocate image and allocate sample}
2470     \textcolor{keywordflow}{if}(sparse.sparse\_coding) \{
2471 
2472       memcpy(&sparse\_input, &input, \textcolor{keyword}{sizeof}(input));
2473       open\_input\_file(&sparse\_input, global.csp);
2474 
2475       \textcolor{keywordflow}{if} (!thres\_calculated) \{
2476         threshold = calculate\_threshold(&sparse\_input, global.limit);
2477         fprintf(stderr, \textcolor{stringliteral}{"Threshold: %f\(\backslash\)n"}, threshold);
2478         thres\_calculated = 1;
2479       \}
2480 
2481       \textcolor{keywordtype}{int} block\_it = 0;
2482       \textcolor{keywordflow}{while}(block\_it <= sparse.sparse\_depth) \{
2483         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sample\_block = block\_size  * block\_size ;
2484         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k = sample\_block * 2;
2485         \textcolor{keywordtype}{int} max\_rand = (int)(raw.\hyperlink{structaom__image_a695141e492ab146dc15e8131827eb237}{w} / block\_size) * (int)(raw.\hyperlink{structaom__image_a3fcffff0a25a4fd9218ed38842014ef2}{h} / block\_size);
2486 
2487         dictionary\_alloc(&dictionaries[block\_it], sample\_block, k);
2488         samples\_alloc(&samples\_dict[block\_it], sample\_block, max\_rand);
2489         sparse\_coeff\_alloc(&sparse\_coeff[block\_it], k, max\_rand);
2490         image\_alloc(&image\_result[block\_it], ((\textcolor{keywordtype}{int})(raw.\hyperlink{structaom__image_a695141e492ab146dc15e8131827eb237}{w} / block\_size)) * block\_size, ((\textcolor{keywordtype}{int})(raw.
      \hyperlink{structaom__image_a3fcffff0a25a4fd9218ed38842014ef2}{h} / block\_size ) * block\_size));
2491         block\_it++;
2492         block\_size *= 2;
2493       \}
2494     \}
2495 
2496     \textcolor{keywordtype}{bool} first\_frame = \textcolor{keyword}{true};
2497 
2498     \textcolor{keywordflow}{while} (frame\_avail || got\_data) \{
2499       \textcolor{keyword}{struct }aom\_usec\_timer timer;
2500 
2501       \textcolor{keywordflow}{if} (!global.limit || frames\_in < global.limit) \{
2502         frame\_avail = read\_frame(&input, &raw);
2503 
2504         \textcolor{keywordflow}{if} (frame\_avail) frames\_in++;
2505         seen\_frames =
2506             frames\_in > global.skip\_frames ? frames\_in - global.skip\_frames : 0;
2507 
2508         \textcolor{keywordflow}{if} (!global.quiet) \{
2509           \textcolor{keywordtype}{float} fps = usec\_to\_fps(cx\_time, seen\_frames);
2510           fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)rPass %d/%d "}, pass + 1, global.passes);
2511 
2512           \textcolor{keywordflow}{if} (stream\_cnt == 1)
2513             fprintf(stderr, \textcolor{stringliteral}{"frame %4d/%-4d %7"} PRId64 \textcolor{stringliteral}{"B "}, frames\_in,
2514                 streams->frames\_out, (int64\_t)streams->nbytes);
2515           \textcolor{keywordflow}{else}
2516             fprintf(stderr, \textcolor{stringliteral}{"frame %4d "}, frames\_in);
2517 
2518           fprintf(stderr, \textcolor{stringliteral}{"%7"} PRId64 \textcolor{stringliteral}{" %s %.2f %s "},
2519               cx\_time > 9999999 ? cx\_time / 1000 : cx\_time,
2520                   cx\_time > 9999999 ? \textcolor{stringliteral}{"ms"} : \textcolor{stringliteral}{"us"}, fps >= 1.0 ? fps : fps * 60,
2521                       fps >= 1.0 ? \textcolor{stringliteral}{"fps"} : \textcolor{stringliteral}{"fpm"});
2522           print\_time(\textcolor{stringliteral}{"ETA"}, estimated\_time\_left);
2523         \}
2524 
2525       \} \textcolor{keywordflow}{else} \{
2526         frame\_avail = 0;
2527       \}
2528 
2529 
2530       \textcolor{keywordflow}{if} (frames\_in > global.skip\_frames) \{
2531 
2532         \hyperlink{structaom__image}{aom\_image\_t} *frame\_to\_encode;
2533 
2534         \textcolor{keywordflow}{if}(sparse.sparse\_coding) \{
2535           \textcolor{keywordtype}{int} block\_it = 0;
2536 
2537           \textcolor{keywordflow}{while}(block\_it <= sparse.sparse\_depth) \{
2538             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} block = (\textcolor{keywordtype}{unsigned} int)sqrt(samples\_dict[block\_it].sample\_size);
2539 
2540             \textcolor{comment}{// Generate filename for video frames}
2541             \textcolor{comment}{/* strcpy(filename\_recon, "/home/augusto/Downloads/images/images-recon");}
2542 \textcolor{comment}{            strcpy(filename\_sparse, "/home/augusto/Downloads/images/sparse");}
2543 \textcolor{comment}{            strcpy(filename, "/home/augusto/Downloads/images/image");}
2544 \textcolor{comment}{            sprintf(filename + strlen(filename), "%dx%d - %d.jpg", block, block, frames\_in);}
2545 \textcolor{comment}{            sprintf(filename\_recon + strlen(filename\_recon), "%dx%d - %d.jpg", block, block, frames\_in);}
2546 \textcolor{comment}{            sprintf(filename\_sparse + strlen(filename\_sparse), "%dx%d - %d.csv", block, block, frames\_in);
      */}
2547             \textcolor{comment}{//write\_image(filename, &images[block\_it]);}
2548 
2549             \textcolor{keywordflow}{if}(first\_frame)
2550               memcpy(&raw\_sparse, &raw, \textcolor{keyword}{sizeof}(raw));
2551 
2552             \textcolor{keywordtype}{bool} change\_scene = sparse\_analysis(&sparse\_input, &frames\_in\_sparse, frames\_in, &raw\_sparse, &
      raw\_to\_analyze, threshold);
2553 
2554             \textcolor{keywordflow}{if}(change\_scene) \{
2555               fprintf(stderr, \textcolor{stringliteral}{"Change scene in %d\(\backslash\)n"}, frames\_in);
2556               memcpy(&raw\_sparse, &raw, \textcolor{keyword}{sizeof}(raw));
2557             \}
2558             \textcolor{comment}{/*}
2559 \textcolor{comment}{            clock\_t start, end;}
2560 \textcolor{comment}{            start = clock();}
2561 \textcolor{comment}{            batch\_OMP(sparse.iterations, &dictionaries[block\_it], &samples\_dict[block\_it],
       samples\_dict[block\_it].number\_blocks, dictionaries[block\_it].sample\_size, &sparse\_coeff[block\_it]);}
2562 \textcolor{comment}{            mat\_mat(1, dictionaries[block\_it].data, sparse\_coeff[block\_it].data, image\_recon,
       samples\_dict[block\_it].sample\_size, dictionaries[block\_it].k, samples\_dict[block\_it].number\_blocks);}
2563 \textcolor{comment}{            write\_blocks(image\_recon, samples\_dict[block\_it].sample\_size,
       samples\_dict[block\_it].number\_blocks, &image\_result[block\_it], false);}
2564 \textcolor{comment}{            write\_image(filename\_recon, &image\_result[block\_it]);}
2565 \textcolor{comment}{            print\_sparse\_csv(&sparse\_coeff[block\_it], filename\_sparse);}
2566 \textcolor{comment}{            end = clock();}
2567 \textcolor{comment}{            fprintf(stderr, "Frame %d-%dx%d reconstructed -->[%lf ms]\(\backslash\)n", frames\_in, block, block, (double)
       (end-start) / CLOCKS\_PER\_SEC);}
2568 \textcolor{comment}{}
2569 \textcolor{comment}{            memset(sparse\_coeff[block\_it].data, 0, sparse\_coeff[block\_it].k *
       sparse\_coeff[block\_it].number\_blocks * sizeof(double));}
2570 \textcolor{comment}{}
2571 \textcolor{comment}{            free(image\_recon);*/}
2572             block\_it++;
2573           \}
2574         \}
2575 
2576         first\_frame = \textcolor{keyword}{false};
2577 
2578         \textcolor{keywordflow}{if} (input\_shift || (use\_16bit\_internal && input.bit\_depth == 8)) \{
2579           assert(use\_16bit\_internal);
2580           \textcolor{comment}{// Input bit depth and stream bit depth do not match, so up}
2581           \textcolor{comment}{// shift frame to stream bit depth}
2582           \textcolor{keywordflow}{if} (!allocated\_raw\_shift) \{
2583             \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw\_shift, raw.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} | 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
2584                 input.width, input.height, 32);
2585             allocated\_raw\_shift = 1;
2586           \}
2587           aom\_img\_upshift(&raw\_shift, &raw, input\_shift);
2588           frame\_to\_encode = &raw\_shift;
2589         \} \textcolor{keywordflow}{else} \{
2590           frame\_to\_encode = &raw;
2591         \}
2592 
2593         aom\_usec\_timer\_start(&timer);
2594         \textcolor{keywordflow}{if} (use\_16bit\_internal) \{
2595           assert(frame\_to\_encode->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH});
2596           FOREACH\_STREAM(stream, streams) \{
2597             \textcolor{keywordflow}{if} (stream->config.use\_16bit\_internal)
2598               encode\_frame(stream, &global,
2599                   frame\_avail ? frame\_to\_encode : NULL, frames\_in);
2600             \textcolor{keywordflow}{else}
2601               assert(0);
2602           \};
2603         \} \textcolor{keywordflow}{else} \{
2604           assert((frame\_to\_encode->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) == 0);
2605           FOREACH\_STREAM(stream, streams) \{
2606             encode\_frame(stream, &global, frame\_avail ? frame\_to\_encode : NULL,
2607                 frames\_in);
2608           \}
2609         \}
2610         aom\_usec\_timer\_mark(&timer);
2611         cx\_time += aom\_usec\_timer\_elapsed(&timer);
2612 
2613         FOREACH\_STREAM(stream, streams) \{ update\_quantizer\_histogram(stream); \}
2614 
2615         got\_data = 0;
2616         FOREACH\_STREAM(stream, streams) \{
2617           get\_cx\_data(stream, &global, &got\_data);
2618         \}
2619 
2620         \textcolor{keywordflow}{if} (!got\_data && input.length && streams != NULL &&
2621             !streams->frames\_out) \{
2622           lagged\_count = global.limit ? seen\_frames : ftello(input.file);
2623         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.length) \{
2624           int64\_t remaining;
2625           int64\_t rate;
2626 
2627           \textcolor{keywordflow}{if} (global.limit) \{
2628             \textcolor{keyword}{const} int64\_t frame\_in\_lagged = (seen\_frames - lagged\_count) * 1000;
2629 
2630             rate = cx\_time ? frame\_in\_lagged * (int64\_t)1000000 / cx\_time : 0;
2631             remaining = 1000 * (global.limit - global.skip\_frames -
2632                 seen\_frames + lagged\_count);
2633           \} \textcolor{keywordflow}{else} \{
2634             \textcolor{keyword}{const} int64\_t input\_pos = ftello(input.file);
2635             \textcolor{keyword}{const} int64\_t input\_pos\_lagged = input\_pos - lagged\_count;
2636             \textcolor{keyword}{const} int64\_t input\_limit = input.length;
2637 
2638             rate = cx\_time ? input\_pos\_lagged * (int64\_t)1000000 / cx\_time : 0;
2639             remaining = input\_limit - input\_pos + lagged\_count;
2640           \}
2641 
2642           average\_rate =
2643               (average\_rate <= 0) ? rate : (average\_rate * 7 + rate) / 8;
2644           estimated\_time\_left = average\_rate ? remaining / average\_rate : -1;
2645         \}
2646 
2647         \textcolor{keywordflow}{if} (got\_data && global.test\_decode != TEST\_DECODE\_OFF) \{
2648           FOREACH\_STREAM(stream, streams) \{
2649             test\_decode(stream, global.test\_decode);
2650           \}
2651         \}
2652       \}
2653 
2654       fflush(stdout);
2655       \textcolor{keywordflow}{if} (!global.quiet) fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)033[K"});
2656     \}
2657 
2658     \textcolor{keywordflow}{if} (stream\_cnt > 1) fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)n"});
2659 
2660     \textcolor{keywordflow}{if} (!global.quiet) \{
2661       FOREACH\_STREAM(stream, streams) \{
2662         \textcolor{keyword}{const} int64\_t bpf =
2663             seen\_frames ? (int64\_t)(stream->nbytes * 8 / seen\_frames) : 0;
2664         \textcolor{keyword}{const} int64\_t bps = bpf * global.framerate.num / global.framerate.den;
2665         fprintf(stderr,
2666             \textcolor{stringliteral}{"\(\backslash\)rPass %d/%d frame %4d/%-4d %7"} PRId64 \textcolor{stringliteral}{"B %7"} PRId64
2667             \textcolor{stringliteral}{"b/f %7"} PRId64
2668             \textcolor{stringliteral}{"b/s"}
2669             \textcolor{stringliteral}{" %7"} PRId64 \textcolor{stringliteral}{" %s (%.2f fps)\(\backslash\)033[K\(\backslash\)n"},
2670             pass + 1, global.passes, frames\_in, stream->frames\_out,
2671             (int64\_t)stream->nbytes, bpf, bps,
2672             stream->cx\_time > 9999999 ? stream->cx\_time / 1000
2673                 : stream->cx\_time,
2674                   stream->cx\_time > 9999999 ? \textcolor{stringliteral}{"ms"} : \textcolor{stringliteral}{"us"},
2675                       usec\_to\_fps(stream->cx\_time, seen\_frames));
2676       \}
2677     \}
2678 
2679     \textcolor{keywordflow}{if} (global.show\_psnr) \{
2680       \textcolor{keywordflow}{if} (global.codec->fourcc == AV1\_FOURCC) \{
2681         FOREACH\_STREAM(stream, streams) \{
2682           int64\_t bps = 0;
2683           \textcolor{keywordflow}{if} (stream->psnr\_count && seen\_frames && global.framerate.den) \{
2684             bps = (int64\_t)stream->nbytes * 8 * (int64\_t)global.framerate.num /
2685                 global.framerate.den / seen\_frames;
2686           \}
2687           show\_psnr(stream, (1 << stream->config.cfg.g\_input\_bit\_depth) - 1,
2688               bps);
2689         \}
2690       \} \textcolor{keywordflow}{else} \{
2691         FOREACH\_STREAM(stream, streams) \{ show\_psnr(stream, 255.0, 0); \}
2692       \}
2693     \}
2694 
2695     FOREACH\_STREAM(stream, streams) \{ \hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&stream->encoder); \}
2696 
2697     \textcolor{keywordflow}{if} (global.test\_decode != TEST\_DECODE\_OFF) \{
2698       FOREACH\_STREAM(stream, streams) \{ \hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&stream->decoder); \}
2699     \}
2700 
2701     close\_input\_file(&input);
2702 
2703     \textcolor{keywordflow}{if} (global.test\_decode == TEST\_DECODE\_FATAL) \{
2704       FOREACH\_STREAM(stream, streams) \{ res |= stream->mismatch\_seen; \}
2705     \}
2706     FOREACH\_STREAM(stream, streams) \{
2707       close\_output\_file(stream, global.codec->fourcc);
2708     \}
2709 
2710     FOREACH\_STREAM(stream, streams) \{
2711       stats\_close(&stream->stats, global.passes - 1);
2712     \}
2713 
2714 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
2715     FOREACH\_STREAM(stream, streams) \{
2716       stats\_close(&stream->fpmb\_stats, global.passes - 1);
2717     \}
2718 \textcolor{preprocessor}{#endif}
2719 
2720     \textcolor{keywordflow}{if} (global.pass) \textcolor{keywordflow}{break};
2721   \}
2722 
2723   \textcolor{keywordflow}{if} (global.show\_q\_hist\_buckets) \{
2724     FOREACH\_STREAM(stream, streams) \{
2725       show\_q\_histogram(stream->counts, global.show\_q\_hist\_buckets);
2726     \}
2727   \}
2728 
2729   \textcolor{keywordflow}{if} (global.show\_rate\_hist\_buckets) \{
2730     FOREACH\_STREAM(stream, streams) \{
2731       show\_rate\_histogram(stream->rate\_hist, &stream->config.cfg,
2732           global.show\_rate\_hist\_buckets);
2733     \}
2734   \}
2735   FOREACH\_STREAM(stream, streams) \{ destroy\_rate\_histogram(stream->rate\_hist); \}
2736 
2737 \textcolor{preprocessor}{#if CONFIG\_INTERNAL\_STATS}
2738   \textcolor{comment}{/* TODO(jkoleszar): This doesn't belong in this executable. Do it for now,}
2739 \textcolor{comment}{   * to match some existing utilities.}
2740 \textcolor{comment}{   */}
2741   \textcolor{keywordflow}{if} (!(global.pass == 1 && global.passes == 2)) \{
2742     FOREACH\_STREAM(stream, streams) \{
2743       FILE *f = fopen(\textcolor{stringliteral}{"opsnr.stt"}, \textcolor{stringliteral}{"a"});
2744       \textcolor{keywordflow}{if} (stream->mismatch\_seen) \{
2745         fprintf(f, \textcolor{stringliteral}{"First mismatch occurred in frame %d\(\backslash\)n"},
2746             stream->mismatch\_seen);
2747       \} \textcolor{keywordflow}{else} \{
2748         fprintf(f, \textcolor{stringliteral}{"No mismatch detected in recon buffers\(\backslash\)n"});
2749       \}
2750       fclose(f);
2751     \}
2752   \}
2753 \textcolor{preprocessor}{#endif}
2754 
2755   \textcolor{keywordflow}{if} (allocated\_raw\_shift) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw\_shift);
2756   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
2757   free(argv);
2758   free(streams);
2759   \textcolor{keywordflow}{return} res ? EXIT\_FAILURE : EXIT\_SUCCESS;
2760 \}
\end{DoxyCodeInclude}
 